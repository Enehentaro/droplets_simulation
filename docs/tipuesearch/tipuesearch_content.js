var tipuesearch = {"pages":[{"title":" Droplets Simulation ","text":"Droplets Simulation ウイルス飛沫を飛ばそう。 Warning Work in progress 概要 流れ場のもとで、飛沫の蒸発方程式と運動方程式を解く。 Note がんばってます。 Todo kd-treeの導入 Bug バグあると思うけど今のところ顕在化してない Developer Info Y.Ida","tags":"home","loc":"index.html"},{"title":"boxResult_t – Droplets Simulation ","text":"type :: boxResult_t Contents Variables flowVelocity Components Type Visibility Attributes Name Initial real, public :: flowVelocity (3)","tags":"","loc":"type/boxresult_t.html"},{"title":"boxResult_t – Droplets Simulation ","text":"type :: boxResult_t Contents Variables num_droplet volume RoI Components Type Visibility Attributes Name Initial integer, public :: num_droplet real, public :: volume real, public :: RoI","tags":"","loc":"type/boxresult_t~2.html"},{"title":"BasicParameter – Droplets Simulation ","text":"type, public :: BasicParameter 基礎変数クラス\n時間間隔や代表値を格納 Inherited by type~~basicparameter~~InheritedByGraph type~basicparameter BasicParameter type~dropletequationsolver DropletEquationSolver type~dropletequationsolver->type~basicparameter type~dropletgenerator DropletGenerator type~dropletgenerator->type~dropletequationsolver equation Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dt L U Re TimeStep2RealTime Type-Bound Procedures repValue Components Type Visibility Attributes Name Initial double precision, public :: dt double precision, public :: L double precision, public :: U double precision, public :: Re procedure, public :: TimeStep2RealTime Type-Bound Procedures procedure, public :: repValue => representativeValue private function representativeValue(self, name) Arguments Type Intent Optional Attributes Name class( BasicParameter ) :: self character, intent(in) :: name Return Value doubleprecision","tags":"","loc":"type/basicparameter.html"},{"title":"DropletEquationSolver – Droplets Simulation ","text":"type, public, extends( BasicParameter ) :: DropletEquationSolver 飛沫方程式ソルバクラス\n蒸発方程式や運動方程式を解くメソッドを保持 Inherits type~~dropletequationsolver~~InheritsGraph type~dropletequationsolver DropletEquationSolver type~basicparameter BasicParameter type~dropletequationsolver->type~basicparameter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~dropletequationsolver~~InheritedByGraph type~dropletequationsolver DropletEquationSolver type~dropletgenerator DropletGenerator type~dropletgenerator->type~dropletequationsolver equation Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dt L U Re TimeStep2RealTime coeff_drdt G T RH minimumRadiusRatio minimumRadiusMatrix set_gravity_acceleration set_dropletEnvironment dropletEnvironment set_coeff_drdt set_minimumRadiusRatio next_position next_velocity get_radiusLowerLimitRatio solve_motionEquation Type-Bound Procedures repValue evaporationEq Components Type Visibility Attributes Name Initial double precision, public :: dt double precision, public :: L double precision, public :: U double precision, public :: Re procedure, public :: TimeStep2RealTime double precision, public :: coeff_drdt double precision, public :: G (3) real, public :: T real, public :: RH double precision, public :: minimumRadiusRatio double precision, public, allocatable :: minimumRadiusMatrix (:,:) procedure, public :: set_gravity_acceleration procedure, public :: set_dropletEnvironment procedure, public :: dropletEnvironment procedure, public :: set_coeff_drdt procedure, public :: set_minimumRadiusRatio procedure, public :: next_position procedure, public :: next_velocity procedure, public :: get_radiusLowerLimitRatio procedure, public :: solve_motionEquation Type-Bound Procedures procedure, public :: repValue => representativeValue private function representativeValue(self, name) Arguments Type Intent Optional Attributes Name class( BasicParameter ) :: self character, intent(in) :: name Return Value doubleprecision procedure, public :: evaporationEq => evaporationEquation private function evaporationEquation(self, radius) result(dr) Arguments Type Intent Optional Attributes Name class( DropletEquationSolver ) :: self double precision, intent(in) :: radius Return Value double precision","tags":"","loc":"type/dropletequationsolver.html"},{"title":"node_t – Droplets Simulation ","text":"type, public :: node_t 節点構造体（ただの座標配列） Inherited by type~~node_t~~InheritedByGraph type~node_t node_t type~flowfieldunstructuredgrid FlowFieldUnstructuredGrid type~flowfieldunstructuredgrid->type~node_t NODEs type~unstructuredgrid_invtk UnstructuredGrid_inVTK type~unstructuredgrid_invtk->type~node_t node_array type~flowfield FlowField type~flowfield->type~flowfieldunstructuredgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables coordinate Components Type Visibility Attributes Name Initial real, public :: coordinate (3)","tags":"","loc":"type/node_t.html"},{"title":"cell_t – Droplets Simulation ","text":"type, public :: cell_t セル構造体（節点のID配列） Inherited by type~~cell_t~~InheritedByGraph type~cell_t cell_t type~cell_inflow_t cell_inFlow_t type~cell_inflow_t->type~cell_t type~cell_invtk_t cell_inVTK_t type~cell_invtk_t->type~cell_t type~flowfieldunstructuredgrid FlowFieldUnstructuredGrid type~flowfieldunstructuredgrid->type~cell_inflow_t CELLs type~unstructuredgrid_invtk UnstructuredGrid_inVTK type~unstructuredgrid_invtk->type~cell_invtk_t cell_array type~flowfield FlowField type~flowfield->type~flowfieldunstructuredgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nodeID Components Type Visibility Attributes Name Initial integer, public, allocatable :: nodeID (:)","tags":"","loc":"type/cell_t.html"},{"title":"DateAndTime – Droplets Simulation ","text":"type, public :: DateAndTime Inherited by type~~dateandtime~~InheritedByGraph type~dateandtime DateAndTime type~timekeeper TimeKeeper type~timekeeper->type~dateandtime startDAT Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures string Type-Bound Procedures procedure, public :: string => DateAndTime2string private function DateAndTime2string(self) result(str) Arguments Type Intent Optional Attributes Name class( DateAndTime ), intent(in) :: self Return Value character,allocatable","tags":"","loc":"type/dateandtime.html"},{"title":"TimeKeeper – Droplets Simulation ","text":"type, public :: TimeKeeper Inherits type~~timekeeper~~InheritsGraph type~timekeeper TimeKeeper type~dateandtime DateAndTime type~timekeeper->type~dateandtime startDAT Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables startCPUtime lastLapCPUtime startDAT startDateAndTime erapsedTime lapTime Components Type Visibility Attributes Name Initial real, public :: startCPUtime real, public :: lastLapCPUtime type( DateAndTime ), public :: startDAT procedure, public :: startDateAndTime procedure, public :: erapsedTime procedure, public :: lapTime","tags":"","loc":"type/timekeeper.html"},{"title":"FlowFieldUnstructuredGrid – Droplets Simulation ","text":"type, public :: FlowFieldUnstructuredGrid Inherits type~~flowfieldunstructuredgrid~~InheritsGraph type~flowfieldunstructuredgrid FlowFieldUnstructuredGrid type~node_t node_t type~flowfieldunstructuredgrid->type~node_t NODEs type~cell_inflow_t cell_inFlow_t type~flowfieldunstructuredgrid->type~cell_inflow_t CELLs type~boundarytriangle_t boundaryTriangle_t type~flowfieldunstructuredgrid->type~boundarytriangle_t BoundFACEs type~kdtree kdTree type~flowfieldunstructuredgrid->type~kdtree kd_tree type~cell_t cell_t type~cell_inflow_t->type~cell_t type~node_in_kdtree_t node_in_kdTree_t type~kdtree->type~node_in_kdtree_t node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~flowfieldunstructuredgrid~~InheritedByGraph type~flowfieldunstructuredgrid FlowFieldUnstructuredGrid type~flowfield FlowField type~flowfield->type~flowfieldunstructuredgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables NODEs CELLs BoundFACEs kd_tree MIN_CDN MAX_CDN num_refCellSearchFalse num_refCellSearch set_cellCenter set_cellThreshold set_MinMaxCDN point2cellVelocity nearer_cell AdjacencySolvingProcess read_adjacency read_boundaries solve_adacencyOnFlowFieldUnstructuredGrid output_boundaries output_adjacency boundary_setting output_STL setup_kdTree Type-Bound Procedures nearcell_check nearest_cell nearest_search_kdTree nearest_search_exact get_movementVectorOfBoundarySurface get_flowVelocityInCELL get_allOfCellCenters get_cellCenterOf get_MinMaxOfGrid get_cellVerticesOf get_info read_FLD read_INP read_array read_VTK updateWithFlowFieldFile setupWithFlowFieldFile search_refCELL adhesionCheckOnBound get_nearerSearchFalseRate get_num_nearerSearchFalse Components Type Visibility Attributes Name Initial type( node_t ), public, allocatable :: NODEs (:) type(cell_inFlow_t), public, allocatable :: CELLs (:) type(boundaryTriangle_t), public, allocatable :: BoundFACEs (:) type( kdTree ), public :: kd_tree real, public :: MIN_CDN (3) real, public :: MAX_CDN (3) integer, public :: num_refCellSearchFalse = 0 integer, public :: num_refCellSearch = 0 procedure, public :: set_cellCenter procedure, public :: set_cellThreshold procedure, public :: set_MinMaxCDN procedure, public :: point2cellVelocity procedure, public :: nearer_cell procedure, public :: AdjacencySolvingProcess procedure, public :: read_adjacency procedure, public :: read_boundaries procedure, public :: solve_adacencyOnFlowFieldUnstructuredGrid procedure, public :: output_boundaries procedure, public :: output_adjacency procedure, public :: boundary_setting procedure, public :: output_STL procedure, public :: setup_kdTree Type-Bound Procedures procedure, public :: nearcell_check private function nearcell_check(self, X, NCN) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self real, intent(in) :: X (3) integer, intent(in) :: NCN Return Value logical procedure, public :: nearest_cell private function nearest_cell(self, X) 最近傍セル探索 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self real, intent(in) :: X (3) Return Value integer procedure, public :: nearest_search_kdTree private function nearest_search_kdTree(self, X) kdツリーによる最近傍セル探索 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self real, intent(in) :: X (3) Return Value integer procedure, public :: nearest_search_exact private function nearest_search_exact(self, X) 厳密最近傍セル探索 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self real, intent(in) :: X (3) Return Value integer procedure, public :: get_movementVectorOfBoundarySurface private function get_movementVectorOfBoundarySurface(self, ID) result(vector) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real(3) procedure, public :: get_flowVelocityInCELL private function get_flowVelocityInCELL(self, ID) result(velocity) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real(3) procedure, public :: get_allOfCellCenters private function get_allOfCellCenters(self) result(centers) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self Return Value real,allocatable, (:,:) procedure, public :: get_cellCenterOf private function get_cellCenterOf(self, ID) result(center) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real(3) procedure, public :: get_MinMaxOfGrid private subroutine get_MinMaxOfGrid(self, MIN_CDN, MAX_CDN) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self real, intent(out) :: MIN_CDN (3) real, intent(out) :: MAX_CDN (3) procedure, public :: get_cellVerticesOf private function get_cellVerticesOf(self, ID) result(vertices) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real,allocatable, (:,:) procedure, public :: get_info => get_gridInformation private function get_gridInformation(self, name) result(info) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self character, intent(in) :: name Return Value integer procedure, public :: read_FLD private subroutine read_FLD(self, FNAME, findTopology, findVelocity) ファイルが存在し, かつトポロジー情報が存在する場合以下の処理が行われる. Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME logical, intent(in) :: findTopology logical, intent(in) :: findVelocity procedure, public :: read_INP private subroutine read_INP(self, FNAME) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME procedure, public :: read_array => read_Array private subroutine read_Array(self, FNAME) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME procedure, public :: read_VTK private subroutine read_VTK(self, FNAME, meshOnly) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME logical, intent(in) :: meshOnly procedure, public :: updateWithFlowFieldFile private subroutine updateWithFlowFieldFile(self, FNAME) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME procedure, public :: setupWithFlowFieldFile private subroutine setupWithFlowFieldFile(self, FNAME, meshFile) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME character, intent(in), optional :: meshFile procedure, public :: search_refCELL private subroutine search_refCELL(self, X, reference_cell, stat) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self real, intent(in) :: X (3) integer, intent(inout) :: reference_cell logical, optional :: stat procedure, public :: adhesionCheckOnBound private subroutine adhesionCheckOnBound(self, position, radius, cellID, stat) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self double precision, intent(in) :: position (3) double precision, intent(in) :: radius integer, intent(in) :: cellID integer, intent(out) :: stat procedure, public :: get_nearerSearchFalseRate private function get_nearerSearchFalseRate(self) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self Return Value real procedure, public :: get_num_nearerSearchFalse private function get_num_nearerSearchFalse(self) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self Return Value integer","tags":"","loc":"type/flowfieldunstructuredgrid.html"},{"title":"kdTree – Droplets Simulation ","text":"type, public :: kdTree Inherits type~~kdtree~~InheritsGraph type~kdtree kdTree type~node_in_kdtree_t node_in_kdTree_t type~kdtree->type~node_in_kdtree_t node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~kdtree~~InheritedByGraph type~kdtree kdTree type~flowfieldunstructuredgrid FlowFieldUnstructuredGrid type~flowfieldunstructuredgrid->type~kdtree kd_tree type~flowfield FlowField type~flowfield->type~flowfieldunstructuredgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables node set_relation saveAsDOT saveAsTXT read_kdTree Type-Bound Procedures search Components Type Visibility Attributes Name Initial type(node_in_kdTree_t), public, allocatable :: node (:) procedure, public :: set_relation procedure, public :: saveAsDOT procedure, public :: saveAsTXT procedure, public :: read_kdTree Type-Bound Procedures procedure, public :: search => search_kdTree private subroutine search_kdTree(self, xyz, droplet_position, nearest_ID) 探索サブルーチン Arguments Type Intent Optional Attributes Name class( kdTree ), intent(in) :: self real, intent(in) :: xyz (:,:) real, intent(in) :: droplet_position (3) integer, intent(out) :: nearest_ID","tags":"","loc":"type/kdtree.html"},{"title":"FlowField – Droplets Simulation ","text":"type, public, extends( FlowFieldUnstructuredGrid ) :: FlowField Inherits type~~flowfield~~InheritsGraph type~flowfield FlowField type~flowfieldunstructuredgrid FlowFieldUnstructuredGrid type~flowfield->type~flowfieldunstructuredgrid type~node_t node_t type~flowfieldunstructuredgrid->type~node_t NODEs type~cell_inflow_t cell_inFlow_t type~flowfieldunstructuredgrid->type~cell_inflow_t CELLs type~boundarytriangle_t boundaryTriangle_t type~flowfieldunstructuredgrid->type~boundarytriangle_t BoundFACEs type~kdtree kdTree type~flowfieldunstructuredgrid->type~kdtree kd_tree type~cell_t cell_t type~cell_inflow_t->type~cell_t type~node_in_kdtree_t node_in_kdTree_t type~kdtree->type~node_in_kdtree_t node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables NODEs CELLs BoundFACEs kd_tree MIN_CDN MAX_CDN num_refCellSearchFalse num_refCellSearch set_cellCenter set_cellThreshold set_MinMaxCDN point2cellVelocity nearer_cell AdjacencySolvingProcess read_adjacency read_boundaries solve_adacencyOnFlowFieldUnstructuredGrid output_boundaries output_adjacency boundary_setting output_STL setup_kdTree INTERVAL LoopHead LoopTail OFFSET DT STEP NextUpdate FullFileName FileNameFormat set_FileNameFormat calc_NextUpdate get_FileNumber clamp_STEP Type-Bound Procedures nearcell_check nearest_cell nearest_search_kdTree nearest_search_exact get_movementVectorOfBoundarySurface get_flowVelocityInCELL get_allOfCellCenters get_cellCenterOf get_MinMaxOfGrid get_cellVerticesOf get_info read_FLD read_INP read_array read_VTK updateWithFlowFieldFile setupWithFlowFieldFile search_refCELL adhesionCheckOnBound get_nearerSearchFalseRate get_num_nearerSearchFalse update isUpdateTiming get_defaultFlowFileName set_time get_requiredFileName Components Type Visibility Attributes Name Initial type( node_t ), public, allocatable :: NODEs (:) type(cell_inFlow_t), public, allocatable :: CELLs (:) type(boundaryTriangle_t), public, allocatable :: BoundFACEs (:) type( kdTree ), public :: kd_tree real, public :: MIN_CDN (3) real, public :: MAX_CDN (3) integer, public :: num_refCellSearchFalse = 0 integer, public :: num_refCellSearch = 0 procedure, public :: set_cellCenter procedure, public :: set_cellThreshold procedure, public :: set_MinMaxCDN procedure, public :: point2cellVelocity procedure, public :: nearer_cell procedure, public :: AdjacencySolvingProcess procedure, public :: read_adjacency procedure, public :: read_boundaries procedure, public :: solve_adacencyOnFlowFieldUnstructuredGrid procedure, public :: output_boundaries procedure, public :: output_adjacency procedure, public :: boundary_setting procedure, public :: output_STL procedure, public :: setup_kdTree integer, public :: INTERVAL integer, public :: LoopHead integer, public :: LoopTail integer, public :: OFFSET double precision, public :: DT integer, public :: STEP integer, public :: NextUpdate character, public, allocatable :: FullFileName character, public, allocatable :: FileNameFormat procedure, public :: set_FileNameFormat procedure, public :: calc_NextUpdate procedure, public :: get_FileNumber procedure, public :: clamp_STEP Type-Bound Procedures procedure, public :: nearcell_check private function nearcell_check(self, X, NCN) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self real, intent(in) :: X (3) integer, intent(in) :: NCN Return Value logical procedure, public :: nearest_cell private function nearest_cell(self, X) 最近傍セル探索 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self real, intent(in) :: X (3) Return Value integer procedure, public :: nearest_search_kdTree private function nearest_search_kdTree(self, X) kdツリーによる最近傍セル探索 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self real, intent(in) :: X (3) Return Value integer procedure, public :: nearest_search_exact private function nearest_search_exact(self, X) 厳密最近傍セル探索 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self real, intent(in) :: X (3) Return Value integer procedure, public :: get_movementVectorOfBoundarySurface private function get_movementVectorOfBoundarySurface(self, ID) result(vector) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real(3) procedure, public :: get_flowVelocityInCELL private function get_flowVelocityInCELL(self, ID) result(velocity) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real(3) procedure, public :: get_allOfCellCenters private function get_allOfCellCenters(self) result(centers) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self Return Value real,allocatable, (:,:) procedure, public :: get_cellCenterOf private function get_cellCenterOf(self, ID) result(center) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real(3) procedure, public :: get_MinMaxOfGrid private subroutine get_MinMaxOfGrid(self, MIN_CDN, MAX_CDN) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self real, intent(out) :: MIN_CDN (3) real, intent(out) :: MAX_CDN (3) procedure, public :: get_cellVerticesOf private function get_cellVerticesOf(self, ID) result(vertices) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real,allocatable, (:,:) procedure, public :: get_info => get_gridInformation private function get_gridInformation(self, name) result(info) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self character, intent(in) :: name Return Value integer procedure, public :: read_FLD private subroutine read_FLD(self, FNAME, findTopology, findVelocity) ファイルが存在し, かつトポロジー情報が存在する場合以下の処理が行われる. Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME logical, intent(in) :: findTopology logical, intent(in) :: findVelocity procedure, public :: read_INP private subroutine read_INP(self, FNAME) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME procedure, public :: read_array => read_Array private subroutine read_Array(self, FNAME) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME procedure, public :: read_VTK private subroutine read_VTK(self, FNAME, meshOnly) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME logical, intent(in) :: meshOnly procedure, public :: updateWithFlowFieldFile private subroutine updateWithFlowFieldFile(self, FNAME) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME procedure, public :: setupWithFlowFieldFile private subroutine setupWithFlowFieldFile(self, FNAME, meshFile) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME character, intent(in), optional :: meshFile procedure, public :: search_refCELL private subroutine search_refCELL(self, X, reference_cell, stat) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self real, intent(in) :: X (3) integer, intent(inout) :: reference_cell logical, optional :: stat procedure, public :: adhesionCheckOnBound private subroutine adhesionCheckOnBound(self, position, radius, cellID, stat) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self double precision, intent(in) :: position (3) double precision, intent(in) :: radius integer, intent(in) :: cellID integer, intent(out) :: stat procedure, public :: get_nearerSearchFalseRate private function get_nearerSearchFalseRate(self) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self Return Value real procedure, public :: get_num_nearerSearchFalse private function get_num_nearerSearchFalse(self) Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self Return Value integer procedure, public :: update => update_FlowField private subroutine update_FlowField(self) Arguments Type Intent Optional Attributes Name class( FlowField ) :: self procedure, public :: isUpdateTiming private function isUpdateTiming(self) Arguments Type Intent Optional Attributes Name class( FlowField ) :: self Return Value logical procedure, public :: get_defaultFlowFileName private function get_defaultFlowFileName(self) result(fname) Arguments Type Intent Optional Attributes Name class( FlowField ) :: self Return Value character,allocatable procedure, public :: set_time => set_timeSTEPinFLOW private subroutine set_timeSTEPinFLOW(self, time) Arguments Type Intent Optional Attributes Name class( FlowField ) :: self double precision, intent(in) :: time procedure, public :: get_requiredFileName => get_requiredFlowFieldFileName private function get_requiredFlowFieldFileName(self) result(FileName) Arguments Type Intent Optional Attributes Name class( FlowField ) :: self Return Value character,allocatable","tags":"","loc":"type/flowfield.html"},{"title":"AdjacencySolver – Droplets Simulation ","text":"type, public :: AdjacencySolver 隣接関係ソルバークラス Inherits type~~adjacencysolver~~InheritsGraph type~adjacencysolver AdjacencySolver type~halfface_t halfFace_t type~adjacencysolver->type~halfface_t halfFaceArray Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables set_halfFaceArray check_halfFace find_boundFaceInformation find_adjacentCellID Components Type Visibility Attributes Name Initial procedure, public :: set_halfFaceArray procedure, public :: check_halfFace procedure, public :: find_boundFaceInformation procedure, public :: find_adjacentCellID","tags":"","loc":"type/adjacencysolver.html"},{"title":"conditionValue_t – Droplets Simulation ","text":"type, public :: conditionValue_t 条件値クラス\n条件指定ファイル（namelist）を読み込んだ結果を格納する\n飛沫計算用の諸条件をまとめた構造体 Contents Variables dt L U direction_g initialDistributionFName restart stepEnd outputInterval num_drop periodicGeneration T RH path2FlowFile meshFile DT_FLOW OFFSET INTERVAL_FLOW LoopHead LoopTail isInitialDistributionSpecified isMeshFileSpecified Components Type Visibility Attributes Name Initial double precision, public :: dt double precision, public :: L double precision, public :: U double precision, public :: direction_g (3) character, public, allocatable :: initialDistributionFName integer, public :: restart integer, public :: stepEnd integer, public :: outputInterval integer, public :: num_drop integer, public :: periodicGeneration real, public :: T real, public :: RH character, public, allocatable :: path2FlowFile character, public, allocatable :: meshFile double precision, public :: DT_FLOW integer, public :: OFFSET integer, public :: INTERVAL_FLOW integer, public :: LoopHead integer, public :: LoopTail procedure, public :: isInitialDistributionSpecified 飛沫初期分布ファイルが指定されたか否かを返す procedure, public :: isMeshFileSpecified メッシュファイルが別途指定されたか否かを返す","tags":"","loc":"type/conditionvalue_t.html"},{"title":"UnstructuredGrid_inVTK – Droplets Simulation ","text":"type, public :: UnstructuredGrid_inVTK Inherits type~~unstructuredgrid_invtk~~InheritsGraph type~unstructuredgrid_invtk UnstructuredGrid_inVTK type~node_t node_t type~unstructuredgrid_invtk->type~node_t node_array type~cell_invtk_t cell_inVTK_t type~unstructuredgrid_invtk->type~cell_invtk_t cell_array type~cell_t cell_t type~cell_invtk_t->type~cell_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables node_array cell_array get_numCell get_numNode get_nodeCoordinate get_cellVertices set_nodeCoordinate set_cellVertices Type-Bound Procedures read output Components Type Visibility Attributes Name Initial type( node_t ), public, allocatable :: node_array (:) type(cell_inVTK_t), public, allocatable :: cell_array (:) procedure, public :: get_numCell procedure, public :: get_numNode procedure, public :: get_nodeCoordinate procedure, public :: get_cellVertices procedure, public :: set_nodeCoordinate procedure, public :: set_cellVertices Type-Bound Procedures procedure, public :: read => read_UnstructuredGrid_inVTK private subroutine read_UnstructuredGrid_inVTK(self, FNAME, action, cellScalar, cellVector) Arguments Type Intent Optional Attributes Name class( UnstructuredGrid_inVTK ) :: self character, intent(in) :: FNAME character, intent(in), optional :: action real, intent(out), optional allocatable :: cellScalar (:) real, intent(out), optional allocatable :: cellVector (:,:) procedure, public :: output => output_UnstructuredGrid_inVTK private subroutine output_UnstructuredGrid_inVTK(self, FNAME, cellScalar, cellVector, scalarName, vectorName) Arguments Type Intent Optional Attributes Name class( UnstructuredGrid_inVTK ) :: self character, intent(in) :: FNAME real, intent(in), optional :: cellScalar (:) real, intent(in), optional :: cellVector (:,:) character, intent(in), optional :: scalarName character, intent(in), optional :: vectorName","tags":"","loc":"type/unstructuredgrid_invtk.html"},{"title":"boxCounter – Droplets Simulation ","text":"type, public :: boxCounter Contents Variables center width min_cdn max_cdn Flag add_Flag get_FlagID Components Type Visibility Attributes Name Initial real, public :: center (3) real, public :: width (3) real, public :: min_cdn (3) real, public :: max_cdn (3) logical, public, allocatable :: Flag (:) procedure, public :: add_Flag procedure, public :: get_FlagID","tags":"","loc":"type/boxcounter.html"},{"title":"SequentialArray – Droplets Simulation ","text":"type, public :: SequentialArray Inherited by type~~sequentialarray~~InheritedByGraph type~sequentialarray SequentialArray type~dropletgenerator DropletGenerator type~dropletgenerator->type~sequentialarray initialRadiusArray, deadlineArray Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables set_SequentialArray Type-Bound Procedures get_value get_valueArray Components Type Visibility Attributes Name Initial procedure, public :: set_SequentialArray Type-Bound Procedures procedure, public :: get_value => get_valueFromSequentialArray private function get_valueFromSequentialArray(self) Arguments Type Intent Optional Attributes Name class( SequentialArray ) :: self Return Value real procedure, public :: get_valueArray => get_valueArrayFromSequentialArray private function get_valueArrayFromSequentialArray(self, arraySize) result(array) Arguments Type Intent Optional Attributes Name class( SequentialArray ) :: self integer, intent(in) :: arraySize Return Value real,allocatable, (:)","tags":"","loc":"type/sequentialarray.html"},{"title":"DropletGenerator – Droplets Simulation ","text":"type, public :: DropletGenerator Inherits type~~dropletgenerator~~InheritsGraph type~dropletgenerator DropletGenerator type~dropletequationsolver DropletEquationSolver type~dropletgenerator->type~dropletequationsolver equation type~sequentialarray SequentialArray type~dropletgenerator->type~sequentialarray initialRadiusArray, deadlineArray type~placementbox placementBox type~dropletgenerator->type~placementbox pBox_array type~basicparameter BasicParameter type~dropletequationsolver->type~basicparameter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables equation pBox_array initialRadiusArray deadlineArray generateRate set_dropletPlacementBox calc_initialPosition Type-Bound Procedures generateDroplet periodicGeneration Components Type Visibility Attributes Name Initial type( DropletEquationSolver ), public, pointer :: equation type(placementBox), public, allocatable :: pBox_array (:) type( SequentialArray ), public :: initialRadiusArray type( SequentialArray ), public :: deadlineArray integer, public :: generateRate = 0 procedure, public :: set_dropletPlacementBox procedure, public :: calc_initialPosition Type-Bound Procedures procedure, public :: generateDroplet private function generateDroplet(self, num_droplet, nowTime) Arguments Type Intent Optional Attributes Name class( DropletGenerator ) :: self integer, intent(in) :: num_droplet double precision, intent(in) :: nowTime Return Value type( DropletGroup ) procedure, public :: periodicGeneration => dropletPeriodicGeneration private subroutine dropletPeriodicGeneration(self, dGroup, nowTime, stat) Arguments Type Intent Optional Attributes Name class( DropletGenerator ) :: self type( DropletGroup ) :: dGroup double precision, intent(in) :: nowTime logical, intent(out) :: stat","tags":"","loc":"type/dropletgenerator.html"},{"title":"virusDroplet_t – Droplets Simulation ","text":"type, public :: virusDroplet_t Inherited by type~~virusdroplet_t~~InheritedByGraph type~virusdroplet_t virusDroplet_t type~dropletgroup DropletGroup type~dropletgroup->type~virusdroplet_t droplet Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables position velocity coalesID refCellID adhesBoundID stop_droplet isEvaporating evaporation get_radius Type-Bound Procedures isFloating coalescenceID Components Type Visibility Attributes Name Initial double precision, public :: position (3) double precision, public :: velocity (3) = 0.d0 integer, public :: coalesID = 0 integer, public :: refCellID = 0 integer, public :: adhesBoundID = 0 procedure, public :: stop_droplet procedure, public :: isEvaporating procedure, public :: evaporation procedure, public :: get_radius Type-Bound Procedures procedure, public :: isFloating => isDropletFloating private function isDropletFloating(self) Arguments Type Intent Optional Attributes Name class( virusDroplet_t ), intent(in) :: self Return Value logical procedure, public :: coalescenceID => dropletCoalescneceID private function dropletCoalescneceID(self) Arguments Type Intent Optional Attributes Name class( virusDroplet_t ), intent(in) :: self Return Value integer","tags":"","loc":"type/virusdroplet_t.html"},{"title":"DropletGroup – Droplets Simulation ","text":"type, public :: DropletGroup Inherits type~~dropletgroup~~InheritsGraph type~dropletgroup DropletGroup type~virusdroplet_t virusDroplet_t type~dropletgroup->type~virusdroplet_t droplet Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables droplet statusCSV output_backup set_initialRadius set_radiusLowerLimit survival_check coalescence_check Type-Bound Procedures output_VTK output_CSV counter IDinBox inBox totalVolume IDinState getArea set_status set_deadline Components Type Visibility Attributes Name Initial type( virusDroplet_t ), public, allocatable :: droplet (:) integer, public, allocatable :: statusCSV (:) procedure, public :: output_backup procedure, public :: set_initialRadius procedure, public :: set_radiusLowerLimit procedure, public :: survival_check procedure, public :: coalescence_check Type-Bound Procedures procedure, public :: output_VTK => output_droplet_VTK private subroutine output_droplet_VTK(self, fname, deadline) Arguments Type Intent Optional Attributes Name class( DropletGroup ) :: self character, intent(in) :: fname logical, optional :: deadline procedure, public :: output_CSV => output_droplet_CSV private subroutine output_droplet_CSV(self, fname, time, initial) Arguments Type Intent Optional Attributes Name class( DropletGroup ) :: self character, intent(in) :: fname double precision, intent(in) :: time logical, intent(in) :: initial procedure, public :: counter => dropletCounter private function dropletCounter(self, name) Arguments Type Intent Optional Attributes Name class( DropletGroup ) :: self character, intent(in) :: name Return Value integer procedure, public :: IDinBox => dropletIDinBox private function dropletIDinBox(self, min_cdn, max_cdn, status) result(ID_array) Arguments Type Intent Optional Attributes Name class( DropletGroup ) :: self double precision, intent(in) :: min_cdn (3) double precision, intent(in) :: max_cdn (3) integer, intent(in), optional :: status Return Value integer,allocatable, (:) procedure, public :: inBox => dropletInBox private function dropletInBox(self, min_cdn, max_cdn) Arguments Type Intent Optional Attributes Name class( DropletGroup ) :: self double precision, intent(in) :: min_cdn (3) double precision, intent(in) :: max_cdn (3) Return Value type( DropletGroup ) procedure, public :: totalVolume => dropletTotalVolume private function dropletTotalVolume(self) Arguments Type Intent Optional Attributes Name class( DropletGroup ) :: self Return Value doubleprecision procedure, public :: IDinState => dropletIDinState private function dropletIDinState(self, status) result(ID_array) Arguments Type Intent Optional Attributes Name class( DropletGroup ) :: self character, intent(in) :: status Return Value integer,allocatable, (:) procedure, public :: getArea => get_dropletGroupArea private subroutine get_dropletGroupArea(self, AreaMin, AreaMax) Arguments Type Intent Optional Attributes Name class( DropletGroup ) :: self double precision, intent(out) :: AreaMin (3) double precision, intent(out) :: AreaMax (3) procedure, public :: set_status => set_dropletGroupStatus private subroutine set_dropletGroupStatus(self, status, ID) Arguments Type Intent Optional Attributes Name class( DropletGroup ) :: self character, intent(in) :: status integer, intent(in), optional :: ID (:) procedure, public :: set_deadline => set_virusDeadline private subroutine set_virusDeadline(self, deadline) Arguments Type Intent Optional Attributes Name class( DropletGroup ) :: self double precision, intent(in) :: deadline (:)","tags":"","loc":"type/dropletgroup.html"},{"title":"content_t – Droplets Simulation ","text":"type, public :: content_t コンテンツ構造体\n実数とIDをメンバに持つ Inherited by type~~content_t~~InheritedByGraph type~content_t content_t type~heaptree HeapTree type~heaptree->type~content_t node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables originID value Components Type Visibility Attributes Name Initial integer, public :: originID real, public :: value","tags":"","loc":"type/content_t.html"},{"title":"HeapTree – Droplets Simulation ","text":"type, public :: HeapTree ヒープ木クラス\n実体は単なる配列だがツリー構造を表現している\n要素 i に注目すると、親ノードは要素 i/2(小数切り捨て) であり、子ノードは要素 2i, 2i + 1 である Inherits type~~heaptree~~InheritsGraph type~heaptree HeapTree type~content_t content_t type~heaptree->type~content_t node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables totalHeaplification get_featuredChildID rebuild_tree Components Type Visibility Attributes Name Initial procedure, public :: totalHeaplification procedure, public :: get_featuredChildID procedure, public :: rebuild_tree","tags":"","loc":"type/heaptree.html"},{"title":"cube_inP3D – Droplets Simulation ","text":"type, public :: cube_inP3D cube（Plot3D形式における立方体）構造体 Inherits type~~cube_inp3d~~InheritsGraph type~cube_inp3d cube_inP3D type~area_t area_t type~cube_inp3d->type~area_t area Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~cube_inp3d~~InheritedByGraph type~cube_inp3d cube_inP3D type~plot3dmesh Plot3dMesh type~plot3dmesh->type~cube_inp3d cubes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables areaOfCube nearest_nodeID Type-Bound Procedures isIncluded Components Type Visibility Attributes Name Initial procedure, public :: areaOfCube procedure, public :: nearest_nodeID Type-Bound Procedures procedure, public :: isIncluded private function isIncluded(self, cdn) cubeのエリア内に任意座標（引数）が含まれているかを返す関数 Arguments Type Intent Optional Attributes Name class( cube_inP3D ), intent(in) :: self real, intent(in) :: cdn (3) Return Value logical","tags":"","loc":"type/cube_inp3d.html"},{"title":"plot3dNodeInfo – Droplets Simulation ","text":"type, public :: plot3dNodeInfo 節点情報構造体 Contents Variables cubeID nodeID Components Type Visibility Attributes Name Initial integer, public :: cubeID integer, public :: nodeID (3)","tags":"","loc":"type/plot3dnodeinfo.html"},{"title":"Plot3dMesh – Droplets Simulation ","text":"type, public :: Plot3dMesh Plot3Dメッシュクラス Inherits type~~plot3dmesh~~InheritsGraph type~plot3dmesh Plot3dMesh type~cube_inp3d cube_inP3D type~plot3dmesh->type~cube_inp3d cubes type~area_t area_t type~cube_inp3d->type~area_t area Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables cubes areaOfMesh Type-Bound Procedures get_cubeShape get_velocity get_numCube read_plot3d_function nearestNodeInfo get_cubeID_contains Components Type Visibility Attributes Name Initial type( cube_inP3D ), public, allocatable :: cubes (:) cube配列 procedure, public :: areaOfMesh Type-Bound Procedures procedure, public :: get_cubeShape private function get_cubeShape(self) result(cubeShape) cubeの形状（i,j,k節点数）を返す関数 Arguments Type Intent Optional Attributes Name class( Plot3dMesh ), intent(in) :: self Return Value integer(3) procedure, public :: get_velocity private function get_velocity(self, node) result(velocity) 任意節点（引数）における流速を返す関数 Arguments Type Intent Optional Attributes Name class( Plot3dMesh ) :: self type( plot3dNodeInfo ), intent(in) :: node 節点 Return Value real(3) procedure, public :: get_numCube private function get_numCube(self) メッシュを構成するcube数を返す関数 Arguments Type Intent Optional Attributes Name class( Plot3dMesh ), intent(in) :: self Return Value integer procedure, public :: read_plot3d_function private subroutine read_plot3d_function(self, fName) メッシュクラスメソッド\n保存量ファイル（.f）を読み込み、メッシュクラスに格納する Arguments Type Intent Optional Attributes Name class( Plot3dMesh ) :: self character, intent(in) :: fName procedure, public :: nearestNodeInfo private function nearestNodeInfo(self, cdn) 任意座標（引数）に最近傍な節点を探し、その情報（cubeID,nodeID）を返す関数 Arguments Type Intent Optional Attributes Name class( Plot3dMesh ), intent(in) :: self real, intent(in) :: cdn (3) Return Value type( plot3dNodeInfo ) procedure, public :: get_cubeID_contains private function get_cubeID_contains(self, cdn) 任意座標（引数）を含むcubeをメッシュの中から探してそのIDを返す関数 Arguments Type Intent Optional Attributes Name class( Plot3dMesh ), intent(in) :: self real, intent(in) :: cdn (3) Return Value integer","tags":"","loc":"type/plot3dmesh.html"},{"title":"sctregion_t – Droplets Simulation ","text":"type, public :: sctregion_t Inherited by type~~sctregion_t~~InheritedByGraph type~sctregion_t sctregion_t type~sct_grid_t sct_grid_t type~sct_grid_t->type~sctregion_t region Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents None","tags":"","loc":"type/sctregion_t.html"},{"title":"sct_data_name_list_t – Droplets Simulation ","text":"type, public :: sct_data_name_list_t スカラーorベクトルデータの名前だけを取り出す. 構造体の配列にして使用する.\nregion用に使うことも出来る. その場合abbreviatedは使わない.\n異なる文字長の配列が実装できなかったのでこれで代用する. Contents None","tags":"","loc":"type/sct_data_name_list_t.html"},{"title":"sct_grid_t – Droplets Simulation ","text":"type, public :: sct_grid_t SC/TETRA メッシュクラス. \n必要最低限の変数のみ保持. 変数名はフォーマットに準拠. メッシュそのものを取り扱うのでメモリ圧迫する可能性大. \nソルバ内で使う場合はサブルーチンのローカル変数として扱う方が無難(自動開放されるはず) Inherits type~~sct_grid_t~~InheritsGraph type~sct_grid_t sct_grid_t type~sctregion_t sctregion_t type~sct_grid_t->type~sctregion_t region type~ls_scalar_t LS_Scalar_t type~sct_grid_t->type~ls_scalar_t scalars type~ls_vector_t LS_Vector_t type~sct_grid_t->type~ls_vector_t vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures includes_topology is_fld_file print_self read_SCT_file extract_original_cell_vertices extract_cell_vertices extract_ordered_cell_vertices get_2d_array_of_point_coords get_cell_types get_element_count get_vertex_count get_tetrahedron_count get_wedge_count get_pyramid_count get_hexahedron_count get_region_count get_region_namelist extract_face2vertices_on_region search_scalar_data search_vector_data get_data_titles Type-Bound Procedures procedure, public :: includes_topology private function includes_topology(this) 格子ファイルがトポロジを含むか. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value logical procedure, public :: is_fld_file private function is_fld_file(this) ファイルがFLDか. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value logical procedure, public :: print_self private subroutine print_self(this, unit) Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this integer, intent(in) :: unit procedure, public :: read_SCT_file private subroutine read_SCT_file(this, filename) SCTファイルを開き，データを取得する. 事実上のコンストラクタ. \n既に別のファイルを開いていた場合，そのデータを破棄して開く. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(inout) :: this character, intent(in) :: filename procedure, public :: extract_original_cell_vertices private subroutine extract_original_cell_vertices(this, cell2vertices) Sc/Tetraで出力されたセル-頂点関係の配列をそのまま出力する. \nセルの種類毎に並んでいないのが特徴.  頂点番号は1から始まる. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this integer, intent(inout), allocatable :: cell2vertices (:,:) 頂点配列. 1st arg: vertex count, 2nd arg: cell number procedure, public :: extract_cell_vertices private subroutine extract_cell_vertices(this, tetras, pyramids, wedges, hexas) afdet solver との互換性のため, セルタイプごとの頂点配列を出力する. \n頂点配列にはセル毎の頂点のインデックスが格納される. 頂点番号は1から始まる. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this integer, intent(inout), optional allocatable :: tetras (:,:) integer, intent(inout), optional allocatable :: pyramids (:,:) integer, intent(inout), optional allocatable :: wedges (:,:) integer, intent(inout), optional allocatable :: hexas (:,:) procedure, public :: extract_ordered_cell_vertices private subroutine extract_ordered_cell_vertices(this, cell2vertices) セルの種類毎に並んだ格子全体の頂点配列を作成する. \nセルはtetra→pyramid→wedge→hexaの順に並べられる. 頂点番号は1から始まる. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this integer, intent(inout), allocatable :: cell2vertices (:,:) procedure, public :: get_2d_array_of_point_coords private subroutine get_2d_array_of_point_coords(this, xyz) 節点座標を2次元配列で出力する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this real(kind=8), intent(inout), allocatable :: xyz (:,:) procedure, public :: get_cell_types private subroutine get_cell_types(this, celltypes, conversion) セルタイプ配列を出力する. \nextract_original_cell_verticesで出力したセル-節点配列に対して有効. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this integer, intent(inout), allocatable :: celltypes (:) セルタイプ配列 character, intent(in), optional :: conversion セルタイプ番号をvtk, xdmfいずれかに変換する. procedure, public :: get_element_count private function get_element_count(this) 要素数を取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_vertex_count private function get_vertex_count(this) 節点数を取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_tetrahedron_count private function get_tetrahedron_count(this) 格子に含まれるテトラ格子数を取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_wedge_count private function get_wedge_count(this) 格子に含まれるプリズム格子数を取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_pyramid_count private function get_pyramid_count(this) 格子に含まれるピラミッド格子数を取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_hexahedron_count private function get_hexahedron_count(this) 格子に含まれるヘキサ格子数を取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_region_count private function get_region_count(this) 領域の個数. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_region_namelist private subroutine get_region_namelist(this, name_list) Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this type( sct_data_name_list_t ), intent(inout), allocatable :: name_list (:) procedure, public :: extract_face2vertices_on_region private subroutine extract_face2vertices_on_region(this, region_num, cell2vertices, face2vertices) 任意のregionを構成する頂点配列を取得する. 体積領域は無視する. \ncell2verticesはoriginalの物でなければならない. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this integer, intent(in) :: region_num region番号. integer, intent(in), allocatable :: cell2vertices (:,:) 並べ替えのされていないセル-頂点配列. integer, intent(inout), allocatable :: face2vertices (:,:) regionを構成する面-頂点配列. procedure, public :: search_scalar_data private subroutine search_scalar_data(this, key, scalar) .fldに含まれるスカラー場データを取得する.\nkeyにタイトル名を入れて検索する. 該当しない場合含まれるデータ一覧を表示. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this character, intent(in) :: key 取り出したいデータのSC/TETRAでの名称. real(kind=8), intent(inout), allocatable :: scalar (:) procedure, public :: search_vector_data private subroutine search_vector_data(this, key, vector) .fldに含まれるベクトル場データを取得する.\nkeyにタイトル名を入れて検索する. 該当しない場合含まれるデータ一覧を表示. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this character, intent(in) :: key 取り出したいデータのSC/TETRAでの名称. real(kind=8), intent(inout), allocatable :: vector (:,:) procedure, public :: get_data_titles private subroutine get_data_titles(this, titles, data_type) .fldに含まれるデータのタイトルを取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this type( sct_data_name_list_t ), intent(inout), allocatable :: titles (:) character, intent(in) :: data_type","tags":"","loc":"type/sct_grid_t.html"},{"title":"output_countCSV – Droplets Simulation","text":"subroutine output_countCSV() Arguments None Called by proc~~output_countcsv~~CalledByGraph proc~output_countcsv output_countCSV program~boxflowfield boxFlowField program~boxflowfield->proc~output_countcsv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_countcsv.html"},{"title":"output_boxVTK – Droplets Simulation","text":"subroutine output_boxVTK() Uses VTK_operator_m proc~~output_boxvtk~~UsesGraph proc~output_boxvtk output_boxVTK module~vtk_operator_m VTK_operator_m proc~output_boxvtk->module~vtk_operator_m module~unstructuredelement_m unstructuredElement_m module~vtk_operator_m->module~unstructuredelement_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~output_boxvtk~~CallsGraph proc~output_boxvtk output_boxVTK proc~unstructuredgrid_invtk_ UnstructuredGrid_inVTK_ proc~output_boxvtk->proc~unstructuredgrid_invtk_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~output_boxvtk~~CalledByGraph proc~output_boxvtk output_boxVTK program~boxflowfield boxFlowField program~boxflowfield->proc~output_boxvtk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_boxvtk.html"},{"title":"RateOfInfection – Droplets Simulation","text":"elemental function RateOfInfection(volume) 1分間あたりの感染確率を計算（もとの資料では1時間あたりの感染確率だが、1分間あたりに換算） Arguments Type Intent Optional Attributes Name real, intent(in) :: volume Return Value real Called by proc~~rateofinfection~~CalledByGraph proc~rateofinfection RateOfInfection program~dropletcount dropletCount program~dropletcount->proc~rateofinfection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rateofinfection.html"},{"title":"output_countCSV – Droplets Simulation","text":"subroutine output_countCSV() Arguments None Called by proc~~output_countcsv~2~~CalledByGraph proc~output_countcsv~2 output_countCSV program~dropletcount dropletCount program~dropletcount->proc~output_countcsv~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_countcsv~2.html"},{"title":"output_boxVTK – Droplets Simulation","text":"subroutine output_boxVTK() Uses VTK_operator_m proc~~output_boxvtk~2~~UsesGraph proc~output_boxvtk~2 output_boxVTK module~vtk_operator_m VTK_operator_m proc~output_boxvtk~2->module~vtk_operator_m module~unstructuredelement_m unstructuredElement_m module~vtk_operator_m->module~unstructuredelement_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~output_boxvtk~2~~CallsGraph proc~output_boxvtk~2 output_boxVTK proc~unstructuredgrid_invtk_ UnstructuredGrid_inVTK_ proc~output_boxvtk~2->proc~unstructuredgrid_invtk_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~output_boxvtk~2~~CalledByGraph proc~output_boxvtk~2 output_boxVTK program~dropletcount dropletCount program~dropletcount->proc~output_boxvtk~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_boxvtk~2.html"},{"title":"output_nodeInfo – Droplets Simulation","text":"subroutine output_nodeInfo() 対応する節点情報をアスキーファイルで出力するサブルーチン Arguments None Called by proc~~output_nodeinfo~~CalledByGraph proc~output_nodeinfo output_nodeInfo proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~output_nodeinfo program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_nodeinfo.html"},{"title":"search_nodeInfo – Droplets Simulation","text":"subroutine search_nodeInfo() Uses terminalControler_m unstructuredElement_m timeKeeper_m proc~~search_nodeinfo~~UsesGraph proc~search_nodeinfo search_nodeInfo module~terminalcontroler_m terminalControler_m proc~search_nodeinfo->module~terminalcontroler_m module~unstructuredelement_m unstructuredElement_m proc~search_nodeinfo->module~unstructuredelement_m module~timekeeper_m timeKeeper_m proc~search_nodeinfo->module~timekeeper_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. 非構造格子に対応する節点情報を探すサブルーチン Arguments None Calls proc~~search_nodeinfo~~CallsGraph proc~search_nodeinfo search_nodeInfo proc~timekeeper_ TimeKeeper_ proc~search_nodeinfo->proc~timekeeper_ proc~set_formattc set_formatTC proc~search_nodeinfo->proc~set_formattc proc~get_cellcenters get_cellCenters proc~search_nodeinfo->proc~get_cellcenters interface~print_progress print_progress proc~search_nodeinfo->interface~print_progress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~search_nodeinfo~~CalledByGraph proc~search_nodeinfo search_nodeInfo proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~search_nodeinfo program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/search_nodeinfo.html"},{"title":"read_nodeInfo – Droplets Simulation","text":"subroutine read_nodeInfo(success) Uses array_m proc~~read_nodeinfo~~UsesGraph proc~read_nodeinfo read_nodeInfo module~array_m array_m proc~read_nodeinfo->module~array_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. 節点情報対応付けファイルを読み込むサブルーチン Arguments Type Intent Optional Attributes Name logical, intent(out) :: success Called by proc~~read_nodeinfo~~CalledByGraph proc~read_nodeinfo read_nodeInfo proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~read_nodeinfo program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_nodeinfo.html"},{"title":"solve_correspondence – Droplets Simulation","text":"subroutine solve_correspondence() 格子と節点の対応付けを解決するサブルーチン Arguments None Calls proc~~solve_correspondence~~CallsGraph proc~solve_correspondence solve_correspondence proc~read_nodeinfo read_nodeInfo proc~solve_correspondence->proc~read_nodeinfo proc~search_nodeinfo search_nodeInfo proc~solve_correspondence->proc~search_nodeinfo proc~output_nodeinfo output_nodeInfo proc~solve_correspondence->proc~output_nodeinfo proc~timekeeper_ TimeKeeper_ proc~search_nodeinfo->proc~timekeeper_ proc~set_formattc set_formatTC proc~search_nodeinfo->proc~set_formattc proc~get_cellcenters get_cellCenters proc~search_nodeinfo->proc~get_cellcenters interface~print_progress print_progress proc~search_nodeinfo->interface~print_progress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~solve_correspondence~~CalledByGraph proc~solve_correspondence solve_correspondence program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_correspondence.html"},{"title":"mean_2dArray – Droplets Simulation","text":"public function mean_2dArray(array) result(mean) Arguments Type Intent Optional Attributes Name real, intent(in) :: array (:,:) Return Value real(size(array,dim=2)) Contents None","tags":"","loc":"proc/mean_2darray.html"},{"title":"FisherYates_shuffle – Droplets Simulation","text":"public function FisherYates_shuffle(a) result(b) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (:) Return Value real(size(a)) Called by proc~~fisheryates_shuffle~~CalledByGraph proc~fisheryates_shuffle FisherYates_shuffle proc~testing testing proc~testing->proc~fisheryates_shuffle program~sort_test sort_test program~sort_test->proc~testing Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fisheryates_shuffle.html"},{"title":"output_2dArray_asBinary – Droplets Simulation","text":"public subroutine output_2dArray_asBinary(fname, array) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname real, intent(in) :: array (:,:) Called by proc~~output_2darray_asbinary~~CalledByGraph proc~output_2darray_asbinary output_2dArray_asBinary program~cube2usg CUBE2USG program~cube2usg->proc~output_2darray_asbinary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_2darray_asbinary.html"},{"title":"read_2dArray_asBinary – Droplets Simulation","text":"public subroutine read_2dArray_asBinary(fname, array) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname real, intent(out), allocatable :: array (:,:) Contents None","tags":"","loc":"proc/read_2darray_asbinary.html"},{"title":"read_1dArray_real – Droplets Simulation","text":"public subroutine read_1dArray_real(fname, array) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname real, intent(out), allocatable :: array (:) Contents None","tags":"","loc":"proc/read_1darray_real.html"},{"title":"BasicParameter_ – Droplets Simulation","text":"public function BasicParameter_(delta_t, L_represent, U_represent) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: delta_t double precision, intent(in) :: L_represent double precision, intent(in) :: U_represent Return Value type( BasicParameter ) Called by proc~~basicparameter_~~CalledByGraph proc~basicparameter_ BasicParameter_ proc~dropletequationsolver_ DropletEquationSolver_ proc~dropletequationsolver_->proc~basicparameter_ program~droplet2csv droplet2CSV program~droplet2csv->proc~basicparameter_ proc~simulationsetup simulationSetUp proc~simulationsetup->proc~dropletequationsolver_ program~main MAIN program~main->proc~simulationsetup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/basicparameter_.html"},{"title":"DropletEquationSolver_ – Droplets Simulation","text":"public function DropletEquationSolver_(delta_t, L_represent, U_represent, direction_g, Temperature, RelativeHumidity) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: delta_t double precision, intent(in) :: L_represent double precision, intent(in) :: U_represent double precision, intent(in) :: direction_g (3) real, intent(in) :: Temperature real, intent(in) :: RelativeHumidity Return Value type( DropletEquationSolver ) Calls proc~~dropletequationsolver_~~CallsGraph proc~dropletequationsolver_ DropletEquationSolver_ proc~basicparameter_ BasicParameter_ proc~dropletequationsolver_->proc~basicparameter_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dropletequationsolver_~~CalledByGraph proc~dropletequationsolver_ DropletEquationSolver_ proc~simulationsetup simulationSetUp proc~simulationsetup->proc~dropletequationsolver_ program~main MAIN program~main->proc~simulationsetup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dropletequationsolver_.html"},{"title":"replace_str – Droplets Simulation","text":"public function replace_str(str, from, to) Arguments Type Intent Optional Attributes Name character, intent(in) :: str character(len=1), intent(in) :: from character(len=1), intent(in) :: to Return Value character Called by proc~~replace_str~~CalledByGraph proc~replace_str replace_str proc~make_directory make_directory proc~make_directory->proc~replace_str program~kdtree_test kdTree_test program~kdtree_test->proc~make_directory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/replace_str.html"},{"title":"make_directory – Droplets Simulation","text":"public subroutine make_directory(path) Arguments Type Intent Optional Attributes Name character, intent(in) :: path Calls proc~~make_directory~~CallsGraph proc~make_directory make_directory proc~replace_str replace_str proc~make_directory->proc~replace_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~make_directory~~CalledByGraph proc~make_directory make_directory program~kdtree_test kdTree_test program~kdtree_test->proc~make_directory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/make_directory.html"},{"title":"get_DirFromPath – Droplets Simulation","text":"public subroutine get_DirFromPath(path, directory, filename) Arguments Type Intent Optional Attributes Name character, intent(in) :: path character, intent(out), allocatable :: directory character, intent(out), optional allocatable :: filename Called by proc~~get_dirfrompath~~CalledByGraph proc~get_dirfrompath get_DirFromPath proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ proc~flowfieldunstructuredgrid_->proc~get_dirfrompath proc~flowfield_ FlowField_ proc~flowfield_->proc~flowfieldunstructuredgrid_ program~boxflowfield boxFlowField program~boxflowfield->proc~flowfieldunstructuredgrid_ proc~simulationsetup simulationSetUp proc~simulationsetup->proc~flowfield_ program~main MAIN program~main->proc~simulationsetup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_dirfrompath.html"},{"title":"reset_formatTC – Droplets Simulation","text":"public subroutine reset_formatTC() Arguments None Contents None","tags":"","loc":"proc/reset_formattc.html"},{"title":"set_formatTC – Droplets Simulation","text":"public subroutine set_formatTC(fmt_str) Arguments Type Intent Optional Attributes Name character, intent(in) :: fmt_str Called by proc~~set_formattc~~CalledByGraph proc~set_formattc set_formatTC proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->proc~set_formattc proc~kdtree_ kdTree_ proc~kdtree_->proc~set_formattc program~boxflowfield boxFlowField program~boxflowfield->proc~set_formattc proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~search_nodeinfo program~kdtree_test kdTree_test program~kdtree_test->proc~kdtree_ program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_formattc.html"},{"title":"print_sameLine – Droplets Simulation","text":"public subroutine print_sameLine(str) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Contents None","tags":"","loc":"proc/print_sameline.html"},{"title":"print_progress – Droplets Simulation","text":"public interface print_progress Called by interface~~print_progress~~CalledByGraph interface~print_progress print_progress proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->interface~print_progress proc~kdtree_ kdTree_ proc~kdtree_->interface~print_progress program~boxflowfield boxFlowField program~boxflowfield->interface~print_progress proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~search_nodeinfo program~kdtree_test kdTree_test program~kdtree_test->proc~kdtree_ program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures print_progress_int print_progress_real Module Procedures private subroutine print_progress_int(array) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) private subroutine print_progress_real(array) Arguments Type Intent Optional Attributes Name real, intent(in) :: array (:)","tags":"","loc":"interface/print_progress.html"},{"title":"get_MinMaxCDN – Droplets Simulation","text":"public function get_MinMaxCDN(node) result(MinMax) 節点群の座標の最大最小を返す Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: node (:) Return Value real(3,2) Contents None","tags":"","loc":"proc/get_minmaxcdn.html"},{"title":"get_cellCenters – Droplets Simulation","text":"public function get_cellCenters(node, cell) result(centers) すべてのセル重心を計算し、配列で返す Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: node (:) class( cell_t ), intent(in) :: cell (:) Return Value real,allocatable,(:,:) Called by proc~~get_cellcenters~~CalledByGraph proc~get_cellcenters get_cellCenters proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->proc~get_cellcenters proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~search_nodeinfo program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_cellcenters.html"},{"title":"TimeKeeper_ – Droplets Simulation","text":"public function TimeKeeper_() Arguments None Return Value type( TimeKeeper ) Called by proc~~timekeeper_~~CalledByGraph proc~timekeeper_ TimeKeeper_ proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->proc~timekeeper_ proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~search_nodeinfo program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/timekeeper_.html"},{"title":"nowDateAndTime – Droplets Simulation","text":"public function nowDateAndTime() result(str) Arguments None Return Value character,allocatable Called by proc~~nowdateandtime~~CalledByGraph proc~nowdateandtime nowDateAndTime proc~output_resultsummary output_ResultSummary proc~output_resultsummary->proc~nowdateandtime program~main MAIN program~main->proc~output_resultsummary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/nowdateandtime.html"},{"title":"second2HMS – Droplets Simulation","text":"public function second2HMS(seconds) result(str) Arguments Type Intent Optional Attributes Name real, intent(in) :: seconds Return Value character(len=9) Contents None","tags":"","loc":"proc/second2hms.html"},{"title":"FlowFieldUnstructuredGrid_ – Droplets Simulation","text":"public function FlowFieldUnstructuredGrid_(FlowFieldFile, meshFile) Uses path_operator_m proc~~flowfieldunstructuredgrid_~~UsesGraph proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ module~path_operator_m path_operator_m proc~flowfieldunstructuredgrid_->module~path_operator_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character, intent(in) :: FlowFieldFile character, intent(in), optional :: meshFile Return Value type( FlowFieldUnstructuredGrid ) Calls proc~~flowfieldunstructuredgrid_~~CallsGraph proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ proc~get_dirfrompath get_DirFromPath proc~flowfieldunstructuredgrid_->proc~get_dirfrompath Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~flowfieldunstructuredgrid_~~CalledByGraph proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ proc~flowfield_ FlowField_ proc~flowfield_->proc~flowfieldunstructuredgrid_ program~boxflowfield boxFlowField program~boxflowfield->proc~flowfieldunstructuredgrid_ proc~simulationsetup simulationSetUp proc~simulationsetup->proc~flowfield_ program~main MAIN program~main->proc~simulationsetup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/flowfieldunstructuredgrid_.html"},{"title":"simulationSetUp – Droplets Simulation","text":"public subroutine simulationSetUp(case_name) Uses virusDroplet_m conditionValue_m proc~~simulationsetup~~UsesGraph proc~simulationsetup simulationSetUp module~virusdroplet_m virusDroplet_m proc~simulationsetup->module~virusdroplet_m module~conditionvalue_m conditionValue_m proc~simulationsetup->module~conditionvalue_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character, intent(in) :: case_name Calls proc~~simulationsetup~~CallsGraph proc~simulationsetup simulationSetUp proc~read_condition read_condition proc~simulationsetup->proc~read_condition proc~read_backup read_backup proc~simulationsetup->proc~read_backup proc~dropletequationsolver_ DropletEquationSolver_ proc~simulationsetup->proc~dropletequationsolver_ proc~dropletgenerator_ DropletGenerator_ proc~simulationsetup->proc~dropletgenerator_ proc~flowfield_ FlowField_ proc~simulationsetup->proc~flowfield_ proc~basicparameter_ BasicParameter_ proc~dropletequationsolver_->proc~basicparameter_ proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ proc~flowfield_->proc~flowfieldunstructuredgrid_ proc~get_dirfrompath get_DirFromPath proc~flowfieldunstructuredgrid_->proc~get_dirfrompath Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~simulationsetup~~CalledByGraph proc~simulationsetup simulationSetUp program~main MAIN program~main->proc~simulationsetup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/simulationsetup.html"},{"title":"read_basicSettingOnSimulation – Droplets Simulation","text":"public subroutine read_basicSettingOnSimulation() Arguments None Called by proc~~read_basicsettingonsimulation~~CalledByGraph proc~read_basicsettingonsimulation read_basicSettingOnSimulation program~main MAIN program~main->proc~read_basicsettingonsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_basicsettingonsimulation.html"},{"title":"mainDropletLoop – Droplets Simulation","text":"public subroutine mainDropletLoop() Arguments None Called by proc~~maindropletloop~~CalledByGraph proc~maindropletloop mainDropletLoop program~main MAIN program~main->proc~maindropletloop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/maindropletloop.html"},{"title":"output_ResultSummary – Droplets Simulation","text":"public subroutine output_ResultSummary() Uses dropletEquation_m proc~~output_resultsummary~~UsesGraph proc~output_resultsummary output_ResultSummary module~dropletequation_m dropletEquation_m proc~output_resultsummary->module~dropletequation_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~output_resultsummary~~CallsGraph proc~output_resultsummary output_ResultSummary proc~nowdateandtime nowDateAndTime proc~output_resultsummary->proc~nowdateandtime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~output_resultsummary~~CalledByGraph proc~output_resultsummary output_ResultSummary program~main MAIN program~main->proc~output_resultsummary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/output_resultsummary.html"},{"title":"kdTree_ – Droplets Simulation","text":"public function kdTree_(xyz_origin) Uses terminalControler_m proc~~kdtree_~~UsesGraph proc~kdtree_ kdTree_ module~terminalcontroler_m terminalControler_m proc~kdtree_->module~terminalcontroler_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real, intent(in) :: xyz_origin (:,:) Return Value type( kdTree ) Calls proc~~kdtree_~~CallsGraph proc~kdtree_ kdTree_ proc~real2content real2content proc~kdtree_->proc~real2content proc~set_formattc set_formatTC proc~kdtree_->proc~set_formattc proc~heap_sort heap_sort proc~kdtree_->proc~heap_sort interface~print_progress print_progress proc~kdtree_->interface~print_progress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~kdtree_~~CalledByGraph proc~kdtree_ kdTree_ program~kdtree_test kdTree_test program~kdtree_test->proc~kdtree_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/kdtree_.html"},{"title":"read_textRecord – Droplets Simulation","text":"public subroutine read_textRecord(filename, array) TXTファイルを、全行読み込む。\n1行あたりの文字数は引数に依存。 Arguments Type Intent Optional Attributes Name character, intent(in) :: filename ファイル名（パス） character, intent(out), allocatable :: array (:) 文字列配列\n要素数はallocatableだが、1要素あたりの文字数は予め指定 Called by proc~~read_textrecord~~CalledByGraph proc~read_textrecord read_textRecord proc~case_check case_check proc~case_check->proc~read_textrecord program~cube2usg CUBE2USG program~cube2usg->proc~read_textrecord program~main MAIN program~main->proc~case_check program~dropletcount dropletCount program~dropletcount->proc~case_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_textrecord.html"},{"title":"read_CSV – Droplets Simulation","text":"public interface read_CSV CSV読込手続き Called by interface~~read_csv~~CalledByGraph interface~read_csv read_CSV proc~get_box_array get_box_array proc~get_box_array->interface~read_csv program~boxflowfield boxFlowField program~boxflowfield->proc~get_box_array program~dropletcount dropletCount program~dropletcount->proc~get_box_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures read_csv_dble read_csv_int read_csv_char Module Procedures private subroutine read_csv_dble(filename, matrix, column, header) Arguments Type Intent Optional Attributes Name character, intent(in) :: filename double precision, intent(inout), allocatable :: matrix (:,:) integer, intent(in), optional :: column logical, optional :: header private subroutine read_csv_int(filename, matrix, column, header) Arguments Type Intent Optional Attributes Name character, intent(in) :: filename integer, intent(inout), allocatable :: matrix (:,:) integer, intent(in), optional :: column logical, optional :: header private subroutine read_csv_char(filename, matrix, column, header) Arguments Type Intent Optional Attributes Name character, intent(in) :: filename character, intent(inout), allocatable :: matrix (:,:) integer, intent(in), optional :: column logical, optional :: header","tags":"","loc":"interface/read_csv.html"},{"title":"FlowField_ – Droplets Simulation","text":"public function FlowField_(time, PATH2FlowFile, DeltaT, OFFSET, outputINTERVAL, LoopHead, LoopTail, meshFile) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: time character, intent(in) :: PATH2FlowFile double precision, intent(in) :: DeltaT integer, intent(in) :: OFFSET integer, intent(in) :: outputINTERVAL integer, intent(in) :: LoopHead integer, intent(in) :: LoopTail character, intent(in), optional :: meshFile Return Value type( FlowField ) Calls proc~~flowfield_~~CallsGraph proc~flowfield_ FlowField_ proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ proc~flowfield_->proc~flowfieldunstructuredgrid_ proc~get_dirfrompath get_DirFromPath proc~flowfieldunstructuredgrid_->proc~get_dirfrompath Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~flowfield_~~CalledByGraph proc~flowfield_ FlowField_ proc~simulationsetup simulationSetUp proc~simulationsetup->proc~flowfield_ program~main MAIN program~main->proc~simulationsetup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/flowfield_.html"},{"title":"solve_BoundaryAndAdjacency – Droplets Simulation","text":"public subroutine solve_BoundaryAndAdjacency(cellVertices, cellBoundFaces, boundFaceVertices, adjacentCellArray) 境界面と隣接関係を、それぞれ配列に格納 Arguments Type Intent Optional Attributes Name integer, intent(in) :: cellVertices (:,:) integer :: cellBoundFaces (:,:) integer, intent(out), allocatable :: boundFaceVertices (:,:) integer :: adjacentCellArray (:,:) Contents None","tags":"","loc":"proc/solve_boundaryandadjacency.html"},{"title":"read_condition – Droplets Simulation","text":"public function read_condition(dir) result(self) Uses filename_m proc~~read_condition~~UsesGraph proc~read_condition read_condition module~filename_m filename_m proc~read_condition->module~filename_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. 条件ファイルを読み込み、結果を構造体で返す。\nこのサブルーチン実装当時、構造体をそのままnamelistにできることを知らず、わざわざ変数ひとつひとつ定義した。\n現在ここを変えると進行中のプロジェクト（オフィス飛沫計算など）に影響が出るおそれがあり、触れない。\nいつか修正したい。 Arguments Type Intent Optional Attributes Name character, intent(in) :: dir Return Value type( conditionValue_t ) Called by proc~~read_condition~~CalledByGraph proc~read_condition read_condition proc~simulationsetup simulationSetUp proc~simulationsetup->proc~read_condition program~droplet2csv droplet2CSV program~droplet2csv->proc~read_condition program~dropletcount dropletCount program~dropletcount->proc~read_condition program~main MAIN program~main->proc~simulationsetup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_condition.html"},{"title":"case_check – Droplets Simulation","text":"public subroutine case_check(caseName_array) Uses filename_m simpleFile_reader proc~~case_check~~UsesGraph proc~case_check case_check module~filename_m filename_m proc~case_check->module~filename_m module~simplefile_reader simpleFile_reader proc~case_check->module~simplefile_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. case名をキーボードから取得する。\nTXTファイルを指定すると、それを全行読み込んで配列に格納。 Arguments Type Intent Optional Attributes Name character, intent(out), allocatable :: caseName_array (:) Calls proc~~case_check~~CallsGraph proc~case_check case_check proc~read_textrecord read_textRecord proc~case_check->proc~read_textrecord Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~case_check~~CalledByGraph proc~case_check case_check program~main MAIN program~main->proc~case_check program~dropletcount dropletCount program~dropletcount->proc~case_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/case_check.html"},{"title":"UnstructuredGrid_inVTK_ – Droplets Simulation","text":"public function UnstructuredGrid_inVTK_(cdn, vertices, types) Arguments Type Intent Optional Attributes Name real, intent(in) :: cdn (:,:) integer, intent(in) :: vertices (:,:) integer, intent(in) :: types (:) Return Value type( UnstructuredGrid_inVTK ) Called by proc~~unstructuredgrid_invtk_~~CalledByGraph proc~unstructuredgrid_invtk_ UnstructuredGrid_inVTK_ proc~output_boxvtk output_boxVTK proc~output_boxvtk->proc~unstructuredgrid_invtk_ proc~output_boxvtk~2 output_boxVTK proc~output_boxvtk~2->proc~unstructuredgrid_invtk_ program~boxflowfield boxFlowField program~boxflowfield->proc~output_boxvtk program~dropletcount dropletCount program~dropletcount->proc~output_boxvtk~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/unstructuredgrid_invtk_.html"},{"title":"cross_product_dble – Droplets Simulation","text":"public function cross_product_dble(a, b) result(cross) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (3) double precision, intent(in) :: b (3) Return Value double precision(3) Called by proc~~cross_product_dble~~CalledByGraph proc~cross_product_dble cross_product_dble interface~cross_product cross_product interface~cross_product->proc~cross_product_dble proc~volume_tetra volume_tetra proc~volume_tetra->interface~cross_product proc~insidejudgment_tetra insideJudgment_tetra proc~insidejudgment_tetra->proc~volume_tetra proc~insidejudgment_tetra_check insideJudgment_tetra_check proc~insidejudgment_tetra_check->proc~volume_tetra program~geometry_test geometry_test program~geometry_test->proc~insidejudgment_tetra program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->proc~insidejudgment_tetra program~cellcentercalc_test->proc~insidejudgment_tetra_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cross_product_dble.html"},{"title":"cross_product_real – Droplets Simulation","text":"public function cross_product_real(a, b) result(cross) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) real, intent(in) :: b (3) Return Value real(3) Called by proc~~cross_product_real~~CalledByGraph proc~cross_product_real cross_product_real interface~cross_product cross_product interface~cross_product->proc~cross_product_real proc~volume_tetra volume_tetra proc~volume_tetra->interface~cross_product proc~insidejudgment_tetra insideJudgment_tetra proc~insidejudgment_tetra->proc~volume_tetra proc~insidejudgment_tetra_check insideJudgment_tetra_check proc~insidejudgment_tetra_check->proc~volume_tetra program~geometry_test geometry_test program~geometry_test->proc~insidejudgment_tetra program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->proc~insidejudgment_tetra program~cellcentercalc_test->proc~insidejudgment_tetra_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cross_product_real.html"},{"title":"normalize_vector_dble – Droplets Simulation","text":"public function normalize_vector_dble(a) result(normalized) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (3) Return Value double precision(3) Called by proc~~normalize_vector_dble~~CalledByGraph proc~normalize_vector_dble normalize_vector_dble interface~normalize_vector normalize_vector interface~normalize_vector->proc~normalize_vector_dble Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/normalize_vector_dble.html"},{"title":"normalize_vector_real – Droplets Simulation","text":"public function normalize_vector_real(a) result(normalized) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) Return Value real(3) Called by proc~~normalize_vector_real~~CalledByGraph proc~normalize_vector_real normalize_vector_real interface~normalize_vector normalize_vector interface~normalize_vector->proc~normalize_vector_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/normalize_vector_real.html"},{"title":"cross_product – Droplets Simulation","text":"public interface cross_product Calls interface~~cross_product~~CallsGraph interface~cross_product cross_product proc~cross_product_dble cross_product_dble interface~cross_product->proc~cross_product_dble proc~cross_product_real cross_product_real interface~cross_product->proc~cross_product_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~cross_product~~CalledByGraph interface~cross_product cross_product proc~volume_tetra volume_tetra proc~volume_tetra->interface~cross_product proc~insidejudgment_tetra insideJudgment_tetra proc~insidejudgment_tetra->proc~volume_tetra proc~insidejudgment_tetra_check insideJudgment_tetra_check proc~insidejudgment_tetra_check->proc~volume_tetra program~geometry_test geometry_test program~geometry_test->proc~insidejudgment_tetra program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->proc~insidejudgment_tetra program~cellcentercalc_test->proc~insidejudgment_tetra_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures cross_product_dble cross_product_real Module Procedures public function cross_product_dble (a, b) result(cross) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (3) double precision, intent(in) :: b (3) Return Value double precision(3) public function cross_product_real (a, b) result(cross) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) real, intent(in) :: b (3) Return Value real(3)","tags":"","loc":"interface/cross_product.html"},{"title":"normalize_vector – Droplets Simulation","text":"public interface normalize_vector Calls interface~~normalize_vector~~CallsGraph interface~normalize_vector normalize_vector proc~normalize_vector_dble normalize_vector_dble interface~normalize_vector->proc~normalize_vector_dble proc~normalize_vector_real normalize_vector_real interface~normalize_vector->proc~normalize_vector_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures normalize_vector_dble normalize_vector_real Module Procedures public function normalize_vector_dble (a) result(normalized) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (3) Return Value double precision(3) public function normalize_vector_real (a) result(normalized) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) Return Value real(3)","tags":"","loc":"interface/normalize_vector.html"},{"title":"volume_tetra – Droplets Simulation","text":"public function volume_tetra(vertices) result(volume) テトラの体積計算。 Arguments Type Intent Optional Attributes Name real, intent(in) :: vertices (3,4) Return Value real Calls proc~~volume_tetra~~CallsGraph proc~volume_tetra volume_tetra interface~cross_product cross_product proc~volume_tetra->interface~cross_product proc~cross_product_dble cross_product_dble interface~cross_product->proc~cross_product_dble proc~cross_product_real cross_product_real interface~cross_product->proc~cross_product_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~volume_tetra~~CalledByGraph proc~volume_tetra volume_tetra proc~insidejudgment_tetra insideJudgment_tetra proc~insidejudgment_tetra->proc~volume_tetra proc~insidejudgment_tetra_check insideJudgment_tetra_check proc~insidejudgment_tetra_check->proc~volume_tetra program~geometry_test geometry_test program~geometry_test->proc~insidejudgment_tetra program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->proc~insidejudgment_tetra program~cellcentercalc_test->proc~insidejudgment_tetra_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/volume_tetra.html"},{"title":"insideJudgment_tetra – Droplets Simulation","text":"public function insideJudgment_tetra(vertices, point) result(isInside) 任意の点がテトラの内部にあるかどうかを判定する。\n点でテトラを分割したそれぞれの体積の和が、元々のテトラの体積を上回れば、点はテトラ外部にある。\nhttps://matcha-choco010.net/2018/03/14/point-in-tetrahedron/ Arguments Type Intent Optional Attributes Name real, intent(in) :: vertices (3,4) real, intent(in) :: point (3) Return Value logical Calls proc~~insidejudgment_tetra~~CallsGraph proc~insidejudgment_tetra insideJudgment_tetra proc~volume_tetra volume_tetra proc~insidejudgment_tetra->proc~volume_tetra interface~cross_product cross_product proc~volume_tetra->interface~cross_product proc~cross_product_dble cross_product_dble interface~cross_product->proc~cross_product_dble proc~cross_product_real cross_product_real interface~cross_product->proc~cross_product_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~insidejudgment_tetra~~CalledByGraph proc~insidejudgment_tetra insideJudgment_tetra program~geometry_test geometry_test program~geometry_test->proc~insidejudgment_tetra program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->proc~insidejudgment_tetra Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/insidejudgment_tetra.html"},{"title":"insideJudgment_tetra_check – Droplets Simulation","text":"public subroutine insideJudgment_tetra_check(vertices, point, vol_sum, volume) Arguments Type Intent Optional Attributes Name real, intent(in) :: vertices (3,4) real, intent(in) :: point (3) real, intent(out) :: vol_sum real, intent(out) :: volume Calls proc~~insidejudgment_tetra_check~~CallsGraph proc~insidejudgment_tetra_check insideJudgment_tetra_check proc~volume_tetra volume_tetra proc~insidejudgment_tetra_check->proc~volume_tetra interface~cross_product cross_product proc~volume_tetra->interface~cross_product proc~cross_product_dble cross_product_dble interface~cross_product->proc~cross_product_dble proc~cross_product_real cross_product_real interface~cross_product->proc~cross_product_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~insidejudgment_tetra_check~~CalledByGraph proc~insidejudgment_tetra_check insideJudgment_tetra_check program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->proc~insidejudgment_tetra_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/insidejudgment_tetra_check.html"},{"title":"get_box_array – Droplets Simulation","text":"public function get_box_array(dir, num_Flag) result(new_box_array) Uses simpleFile_reader proc~~get_box_array~~UsesGraph proc~get_box_array get_box_array module~simplefile_reader simpleFile_reader proc~get_box_array->module~simplefile_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character, intent(in) :: dir integer, intent(in) :: num_Flag Return Value type( boxCounter ),allocatable,(:) Calls proc~~get_box_array~~CallsGraph proc~get_box_array get_box_array interface~read_csv read_CSV proc~get_box_array->interface~read_csv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_box_array~~CalledByGraph proc~get_box_array get_box_array program~boxflowfield boxFlowField program~boxflowfield->proc~get_box_array program~dropletcount dropletCount program~dropletcount->proc~get_box_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_box_array.html"},{"title":"get_FlagID – Droplets Simulation","text":"public function get_FlagID(self) result(id_array) Arguments Type Intent Optional Attributes Name class( boxCounter ) :: self Return Value integer,allocatable,(:) Contents None","tags":"","loc":"proc/get_flagid.html"},{"title":"add_Flag – Droplets Simulation","text":"public subroutine add_Flag(self, id_array) Arguments Type Intent Optional Attributes Name class( boxCounter ) :: self integer, intent(in) :: id_array (:) Contents None","tags":"","loc":"proc/add_flag.html"},{"title":"DropletGenerator_ – Droplets Simulation","text":"public function DropletGenerator_(equation, radiusDistributionFile, positionDir, generationRate) Arguments Type Intent Optional Attributes Name type( DropletEquationSolver ), target :: equation character, intent(in) :: radiusDistributionFile character, intent(in) :: positionDir integer, intent(in) :: generationRate Return Value type( DropletGenerator ) Called by proc~~dropletgenerator_~~CalledByGraph proc~dropletgenerator_ DropletGenerator_ proc~simulationsetup simulationSetUp proc~simulationsetup->proc~dropletgenerator_ program~main MAIN program~main->proc~simulationsetup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dropletgenerator_.html"},{"title":"read_backup – Droplets Simulation","text":"public function read_backup(fname) result(dGroup_read) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname Return Value type( DropletGroup ) Called by proc~~read_backup~~CalledByGraph proc~read_backup read_backup proc~simulationsetup simulationSetUp proc~simulationsetup->proc~read_backup program~droplet2csv droplet2CSV program~droplet2csv->proc~read_backup program~dropletcount dropletCount program~dropletcount->proc~read_backup program~translate translate program~translate->proc~read_backup program~main MAIN program~main->proc~simulationsetup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_backup.html"},{"title":"real2content – Droplets Simulation","text":"public function real2content(real_array) result(content_array) 実数型配列をコンテンツ配列に変換する Arguments Type Intent Optional Attributes Name real, intent(in) :: real_array (:) Return Value type( content_t ),allocatable,(:) Called by proc~~real2content~~CalledByGraph proc~real2content real2content proc~kdtree_ kdTree_ proc~kdtree_->proc~real2content proc~testing testing proc~testing->proc~real2content program~kdtree_test kdTree_test program~kdtree_test->proc~kdtree_ program~sort_test sort_test program~sort_test->proc~testing Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/real2content.html"},{"title":"heap_sort – Droplets Simulation","text":"public subroutine heap_sort(array_origin, array_sorted) ヒープソート Arguments Type Intent Optional Attributes Name type( content_t ), intent(in) :: array_origin (:) type( content_t ), intent(out) :: array_sorted (:) Called by proc~~heap_sort~~CalledByGraph proc~heap_sort heap_sort proc~kdtree_ kdTree_ proc~kdtree_->proc~heap_sort proc~testing testing proc~testing->proc~heap_sort program~kdtree_test kdTree_test program~kdtree_test->proc~kdtree_ program~sort_test sort_test program~sort_test->proc~testing Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/heap_sort.html"},{"title":"read_plot3d_multigrid – Droplets Simulation","text":"public function read_plot3d_multigrid(fName) result(mesh) メッシュファイル（.g）を読み込んでメッシュクラスを返す関数 Arguments Type Intent Optional Attributes Name character, intent(in) :: fName Return Value type( Plot3dMesh ) Called by proc~~read_plot3d_multigrid~~CalledByGraph proc~read_plot3d_multigrid read_plot3d_multigrid program~cube2usg CUBE2USG program~cube2usg->proc~read_plot3d_multigrid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_plot3d_multigrid.html"},{"title":"get_cell_data_from_cellvertices – Droplets Simulation","text":"public subroutine get_cell_data_from_cellvertices(cell_data, cell2vertices, point_data) 各セル毎の頂点配列に関連する節点中心データからセル中心データを構築する. \n値はセルを構成する節点データの算術平均として計算する. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: cell_data (:) 出力されるセル中心データ. integer, intent(in) :: cell2vertices (:,:) 頂点配列. integer, intent(in) :: point_data (:) 任意の節点データ. Contents None","tags":"","loc":"proc/get_cell_data_from_cellvertices.html"},{"title":"plane_equation – Droplets Simulation","text":"function plane_equation(x, y) result(z) テスト用テトラの斜面の方程式 Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y Return Value real Called by proc~~plane_equation~~CalledByGraph proc~plane_equation plane_equation program~geometry_test geometry_test program~geometry_test->proc~plane_equation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/plane_equation.html"},{"title":"test – Droplets Simulation","text":"subroutine test() 乱数で発生させた点に対して、kdTreeによる探索結果と、厳密なnearest探索結果が一致するかどうかをテスト Arguments None Called by proc~~test~~CalledByGraph proc~test test program~kdtree_test kdTree_test program~kdtree_test->proc~test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test.html"},{"title":"testing – Droplets Simulation","text":"subroutine testing(array_correct) Arguments Type Intent Optional Attributes Name real, intent(in) :: array_correct (:) Calls proc~~testing~~CallsGraph proc~testing testing proc~fisheryates_shuffle FisherYates_shuffle proc~testing->proc~fisheryates_shuffle proc~heap_sort heap_sort proc~testing->proc~heap_sort proc~real2content real2content proc~testing->proc~real2content Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~testing~~CalledByGraph proc~testing testing program~sort_test sort_test program~sort_test->proc~testing Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/testing.html"},{"title":"array_m – Droplets Simulation","text":"Used by module~~array_m~~UsedByGraph module~array_m array_m proc~read_nodeinfo read_nodeInfo proc~read_nodeinfo->module~array_m program~sort_test sort_test program~sort_test->module~array_m program~cube2usg CUBE2USG program~cube2usg->module~array_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions mean_2dArray FisherYates_shuffle Subroutines output_2dArray_asBinary read_2dArray_asBinary read_1dArray_real Functions public function mean_2dArray (array) result(mean) Arguments Type Intent Optional Attributes Name real, intent(in) :: array (:,:) Return Value real(size(array,dim=2)) public function FisherYates_shuffle (a) result(b) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (:) Return Value real(size(a)) Subroutines public subroutine output_2dArray_asBinary (fname, array) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname real, intent(in) :: array (:,:) public subroutine read_2dArray_asBinary (fname, array) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname real, intent(out), allocatable :: array (:,:) public subroutine read_1dArray_real (fname, array) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname real, intent(out), allocatable :: array (:)","tags":"","loc":"module/array_m.html"},{"title":"dropletEquation_m – Droplets Simulation","text":"Used by module~~dropletequation_m~~UsedByGraph module~dropletequation_m dropletEquation_m proc~output_resultsummary output_ResultSummary proc~output_resultsummary->module~dropletequation_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~dropletequation_m module~dropletgenerator_m dropletGenerator_m module~dropletmotionsimulation->module~dropletgenerator_m program~droplet2csv droplet2CSV program~droplet2csv->module~dropletequation_m module~dropletgenerator_m->module~dropletequation_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types BasicParameter DropletEquationSolver Functions BasicParameter_ DropletEquationSolver_ Derived Types type, public :: BasicParameter 基礎変数クラス\n時間間隔や代表値を格納 Components Type Visibility Attributes Name Initial double precision, public :: dt double precision, public :: L double precision, public :: U double precision, public :: Re procedure, public :: TimeStep2RealTime Type-Bound Procedures procedure, public :: repValue => representativeValue type, public, extends( BasicParameter ) :: DropletEquationSolver 飛沫方程式ソルバクラス\n蒸発方程式や運動方程式を解くメソッドを保持 Components Type Visibility Attributes Name Initial double precision, public :: dt double precision, public :: L double precision, public :: U double precision, public :: Re procedure, public :: TimeStep2RealTime double precision, public :: coeff_drdt double precision, public :: G (3) real, public :: T real, public :: RH double precision, public :: minimumRadiusRatio double precision, public, allocatable :: minimumRadiusMatrix (:,:) procedure, public :: set_gravity_acceleration procedure, public :: set_dropletEnvironment procedure, public :: dropletEnvironment procedure, public :: set_coeff_drdt procedure, public :: set_minimumRadiusRatio procedure, public :: next_position procedure, public :: next_velocity procedure, public :: get_radiusLowerLimitRatio procedure, public :: solve_motionEquation Type-Bound Procedures procedure, public :: repValue => representativeValue procedure, public :: evaporationEq => evaporationEquation Functions public function BasicParameter_ (delta_t, L_represent, U_represent) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: delta_t double precision, intent(in) :: L_represent double precision, intent(in) :: U_represent Return Value type( BasicParameter ) public function DropletEquationSolver_ (delta_t, L_represent, U_represent, direction_g, Temperature, RelativeHumidity) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: delta_t double precision, intent(in) :: L_represent double precision, intent(in) :: U_represent double precision, intent(in) :: direction_g (3) real, intent(in) :: Temperature real, intent(in) :: RelativeHumidity Return Value type( DropletEquationSolver )","tags":"","loc":"module/dropletequation_m.html"},{"title":"path_operator_m – Droplets Simulation","text":"Used by module~~path_operator_m~~UsedByGraph module~path_operator_m path_operator_m proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ proc~flowfieldunstructuredgrid_->module~path_operator_m program~kdtree_test kdTree_test program~kdtree_test->module~path_operator_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions replace_str Subroutines make_directory get_DirFromPath Functions public function replace_str (str, from, to) Arguments Type Intent Optional Attributes Name character, intent(in) :: str character(len=1), intent(in) :: from character(len=1), intent(in) :: to Return Value character Subroutines public subroutine make_directory (path) Arguments Type Intent Optional Attributes Name character, intent(in) :: path public subroutine get_DirFromPath (path, directory, filename) Arguments Type Intent Optional Attributes Name character, intent(in) :: path character, intent(out), allocatable :: directory character, intent(out), optional allocatable :: filename","tags":"","loc":"module/path_operator_m.html"},{"title":"terminalControler_m – Droplets Simulation","text":"Example program main use terminalControler_m call set_formatTC ( '(\"CHECK halfFace [ #group : \",i6,\" / \",i6,\" ]\")' ) do groupID = 1 , num_group call print_progress ([ groupID , num_group ]) end do end program main Used by module~~terminalcontroler_m~~UsedByGraph module~terminalcontroler_m terminalControler_m proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->module~terminalcontroler_m proc~kdtree_ kdTree_ proc~kdtree_->module~terminalcontroler_m program~boxflowfield boxFlowField program~boxflowfield->module~terminalcontroler_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces print_progress Subroutines reset_formatTC set_formatTC print_sameLine Interfaces public interface print_progress private subroutine print_progress_int(array) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) private subroutine print_progress_real(array) Arguments Type Intent Optional Attributes Name real, intent(in) :: array (:) Subroutines public subroutine reset_formatTC () Arguments None public subroutine set_formatTC (fmt_str) Arguments Type Intent Optional Attributes Name character, intent(in) :: fmt_str public subroutine print_sameLine (str) Arguments Type Intent Optional Attributes Name character, intent(in) :: str","tags":"","loc":"module/terminalcontroler_m.html"},{"title":"unstructuredElement_m – Droplets Simulation","text":"非構造要素モジュール\n非構造格子のベースとなる構造体を定義している Used by module~~unstructuredelement_m~~UsedByGraph module~unstructuredelement_m unstructuredElement_m module~vtk_operator_m VTK_operator_m module~vtk_operator_m->module~unstructuredelement_m proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->module~unstructuredelement_m module~unstructuredgrid_m unstructuredGrid_m module~unstructuredgrid_m->module~unstructuredelement_m proc~output_boxvtk output_boxVTK proc~output_boxvtk->module~vtk_operator_m module~flow_field_m flow_field_m module~flow_field_m->module~unstructuredgrid_m program~kdtree_test kdTree_test program~kdtree_test->module~unstructuredgrid_m proc~output_boxvtk~2 output_boxVTK proc~output_boxvtk~2->module~vtk_operator_m program~cube2usg CUBE2USG program~cube2usg->module~vtk_operator_m program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->module~unstructuredgrid_m program~boxflowfield boxFlowField program~boxflowfield->module~unstructuredgrid_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~flow_field_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types node_t cell_t Functions get_MinMaxCDN get_cellCenters Derived Types type, public :: node_t 節点構造体（ただの座標配列） Components Type Visibility Attributes Name Initial real, public :: coordinate (3) type, public :: cell_t セル構造体（節点のID配列） Components Type Visibility Attributes Name Initial integer, public, allocatable :: nodeID (:) Functions public function get_MinMaxCDN (node) result(MinMax) 節点群の座標の最大最小を返す Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: node (:) Return Value real(3,2) public function get_cellCenters (node, cell) result(centers) すべてのセル重心を計算し、配列で返す Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: node (:) class( cell_t ), intent(in) :: cell (:) Return Value real,allocatable, (:,:)","tags":"","loc":"module/unstructuredelement_m.html"},{"title":"timeKeeper_m – Droplets Simulation","text":"Used by module~~timekeeper_m~~UsedByGraph module~timekeeper_m timeKeeper_m proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->module~timekeeper_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~timekeeper_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types DateAndTime TimeKeeper Functions TimeKeeper_ nowDateAndTime second2HMS Derived Types type, public :: DateAndTime Type-Bound Procedures procedure, public :: string => DateAndTime2string type, public :: TimeKeeper Components Type Visibility Attributes Name Initial real, public :: startCPUtime real, public :: lastLapCPUtime type( DateAndTime ), public :: startDAT procedure, public :: startDateAndTime procedure, public :: erapsedTime procedure, public :: lapTime Functions public function TimeKeeper_ () Arguments None Return Value type( TimeKeeper ) public function nowDateAndTime () result(str) Arguments None Return Value character,allocatable public function second2HMS (seconds) result(str) Arguments Type Intent Optional Attributes Name real, intent(in) :: seconds Return Value character(len=9)","tags":"","loc":"module/timekeeper_m.html"},{"title":"unstructuredGrid_m – Droplets Simulation","text":"Uses unstructuredElement_m kdTree_m module~~unstructuredgrid_m~~UsesGraph module~unstructuredgrid_m unstructuredGrid_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~kdtree_m kdTree_m module~unstructuredgrid_m->module~kdtree_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~unstructuredgrid_m~~UsedByGraph module~unstructuredgrid_m unstructuredGrid_m module~flow_field_m flow_field_m module~flow_field_m->module~unstructuredgrid_m program~kdtree_test kdTree_test program~kdtree_test->module~unstructuredgrid_m program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->module~unstructuredgrid_m program~boxflowfield boxFlowField program~boxflowfield->module~unstructuredgrid_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~flow_field_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types FlowFieldUnstructuredGrid Functions FlowFieldUnstructuredGrid_ Derived Types type, public :: FlowFieldUnstructuredGrid Components Type Visibility Attributes Name Initial type( node_t ), public, allocatable :: NODEs (:) type(cell_inFlow_t), public, allocatable :: CELLs (:) type(boundaryTriangle_t), public, allocatable :: BoundFACEs (:) type( kdTree ), public :: kd_tree real, public :: MIN_CDN (3) real, public :: MAX_CDN (3) integer, public :: num_refCellSearchFalse = 0 integer, public :: num_refCellSearch = 0 procedure, public :: set_cellCenter procedure, public :: set_cellThreshold procedure, public :: set_MinMaxCDN procedure, public :: point2cellVelocity procedure, public :: nearer_cell procedure, public :: AdjacencySolvingProcess procedure, public :: read_adjacency procedure, public :: read_boundaries procedure, public :: solve_adacencyOnFlowFieldUnstructuredGrid procedure, public :: output_boundaries procedure, public :: output_adjacency procedure, public :: boundary_setting procedure, public :: output_STL procedure, public :: setup_kdTree Type-Bound Procedures procedure, public :: nearcell_check procedure, public :: nearest_cell procedure, public :: nearest_search_kdTree procedure, public :: nearest_search_exact procedure, public :: get_movementVectorOfBoundarySurface procedure, public :: get_flowVelocityInCELL procedure, public :: get_allOfCellCenters procedure, public :: get_cellCenterOf procedure, public :: get_MinMaxOfGrid procedure, public :: get_cellVerticesOf procedure, public :: get_info => get_gridInformation procedure, public :: read_FLD procedure, public :: read_INP procedure, public :: read_array => read_Array procedure, public :: read_VTK procedure, public :: updateWithFlowFieldFile procedure, public :: setupWithFlowFieldFile procedure, public :: search_refCELL procedure, public :: adhesionCheckOnBound procedure, public :: get_nearerSearchFalseRate procedure, public :: get_num_nearerSearchFalse Functions public function FlowFieldUnstructuredGrid_ (FlowFieldFile, meshFile) Arguments Type Intent Optional Attributes Name character, intent(in) :: FlowFieldFile character, intent(in), optional :: meshFile Return Value type( FlowFieldUnstructuredGrid )","tags":"","loc":"module/unstructuredgrid_m.html"},{"title":"dropletMotionSimulation – Droplets Simulation","text":"Uses timeKeeper_m flow_field_m dropletGenerator_m dropletEquation_m module~~dropletmotionsimulation~~UsesGraph module~dropletmotionsimulation dropletMotionSimulation module~timekeeper_m timeKeeper_m module~dropletmotionsimulation->module~timekeeper_m module~flow_field_m flow_field_m module~dropletmotionsimulation->module~flow_field_m module~dropletequation_m dropletEquation_m module~dropletmotionsimulation->module~dropletequation_m module~dropletgenerator_m dropletGenerator_m module~dropletmotionsimulation->module~dropletgenerator_m module~unstructuredgrid_m unstructuredGrid_m module~flow_field_m->module~unstructuredgrid_m module~dropletgenerator_m->module~dropletequation_m module~virusdroplet_m virusDroplet_m module~dropletgenerator_m->module~virusdroplet_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~kdtree_m kdTree_m module~unstructuredgrid_m->module~kdtree_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~dropletmotionsimulation~~UsedByGraph module~dropletmotionsimulation dropletMotionSimulation program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines simulationSetUp read_basicSettingOnSimulation mainDropletLoop output_ResultSummary Subroutines public subroutine simulationSetUp (case_name) Arguments Type Intent Optional Attributes Name character, intent(in) :: case_name public subroutine read_basicSettingOnSimulation () Arguments None public subroutine mainDropletLoop () Arguments None public subroutine output_ResultSummary () Arguments None","tags":"","loc":"module/dropletmotionsimulation.html"},{"title":"kdTree_m – Droplets Simulation","text":"kd-treeモジュール\nby Shohei Kishi, Hikaru Konishi, Tatsuya Miyoshi, Yuta Ida Uses sort_m module~~kdtree_m~~UsesGraph module~kdtree_m kdTree_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~kdtree_m~~UsedByGraph module~kdtree_m kdTree_m module~unstructuredgrid_m unstructuredGrid_m module~unstructuredgrid_m->module~kdtree_m program~kdtree_test kdTree_test program~kdtree_test->module~kdtree_m program~kdtree_test->module~unstructuredgrid_m module~flow_field_m flow_field_m module~flow_field_m->module~unstructuredgrid_m program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->module~unstructuredgrid_m program~boxflowfield boxFlowField program~boxflowfield->module~unstructuredgrid_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~flow_field_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types kdTree Functions kdTree_ Derived Types type, public :: kdTree Components Type Visibility Attributes Name Initial type(node_in_kdTree_t), public, allocatable :: node (:) procedure, public :: set_relation procedure, public :: saveAsDOT procedure, public :: saveAsTXT procedure, public :: read_kdTree Type-Bound Procedures procedure, public :: search => search_kdTree Functions public function kdTree_ (xyz_origin) Arguments Type Intent Optional Attributes Name real, intent(in) :: xyz_origin (:,:) Return Value type( kdTree )","tags":"","loc":"module/kdtree_m.html"},{"title":"simpleFile_reader – Droplets Simulation","text":"簡単なファイル（CSV、TXTなど）の読込手続き集モジュール Used by module~~simplefile_reader~~UsedByGraph module~simplefile_reader simpleFile_reader proc~case_check case_check proc~case_check->module~simplefile_reader proc~get_box_array get_box_array proc~get_box_array->module~simplefile_reader program~cube2usg CUBE2USG program~cube2usg->module~simplefile_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces read_CSV Subroutines read_textRecord Interfaces public interface read_CSV CSV読込手続き private subroutine read_csv_dble(filename, matrix, column, header) Arguments Type Intent Optional Attributes Name character, intent(in) :: filename double precision, intent(inout), allocatable :: matrix (:,:) integer, intent(in), optional :: column logical, optional :: header private subroutine read_csv_int(filename, matrix, column, header) Arguments Type Intent Optional Attributes Name character, intent(in) :: filename integer, intent(inout), allocatable :: matrix (:,:) integer, intent(in), optional :: column logical, optional :: header private subroutine read_csv_char(filename, matrix, column, header) Arguments Type Intent Optional Attributes Name character, intent(in) :: filename character, intent(inout), allocatable :: matrix (:,:) integer, intent(in), optional :: column logical, optional :: header Subroutines public subroutine read_textRecord (filename, array) TXTファイルを、全行読み込む。\n1行あたりの文字数は引数に依存。 Arguments Type Intent Optional Attributes Name character, intent(in) :: filename ファイル名（パス） character, intent(out), allocatable :: array (:) 文字列配列\n要素数はallocatableだが、1要素あたりの文字数は予め指定","tags":"","loc":"module/simplefile_reader.html"},{"title":"flow_field_m – Droplets Simulation","text":"Uses unstructuredGrid_m module~~flow_field_m~~UsesGraph module~flow_field_m flow_field_m module~unstructuredgrid_m unstructuredGrid_m module~flow_field_m->module~unstructuredgrid_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~kdtree_m kdTree_m module~unstructuredgrid_m->module~kdtree_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~flow_field_m~~UsedByGraph module~flow_field_m flow_field_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~flow_field_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types FlowField Functions FlowField_ Derived Types type, public, extends( FlowFieldUnstructuredGrid ) :: FlowField Components Type Visibility Attributes Name Initial type( node_t ), public, allocatable :: NODEs (:) type(cell_inFlow_t), public, allocatable :: CELLs (:) type(boundaryTriangle_t), public, allocatable :: BoundFACEs (:) type( kdTree ), public :: kd_tree real, public :: MIN_CDN (3) real, public :: MAX_CDN (3) integer, public :: num_refCellSearchFalse = 0 integer, public :: num_refCellSearch = 0 procedure, public :: set_cellCenter procedure, public :: set_cellThreshold procedure, public :: set_MinMaxCDN procedure, public :: point2cellVelocity procedure, public :: nearer_cell procedure, public :: AdjacencySolvingProcess procedure, public :: read_adjacency procedure, public :: read_boundaries procedure, public :: solve_adacencyOnFlowFieldUnstructuredGrid procedure, public :: output_boundaries procedure, public :: output_adjacency procedure, public :: boundary_setting procedure, public :: output_STL procedure, public :: setup_kdTree integer, public :: INTERVAL integer, public :: LoopHead integer, public :: LoopTail integer, public :: OFFSET double precision, public :: DT integer, public :: STEP integer, public :: NextUpdate character, public, allocatable :: FullFileName character, public, allocatable :: FileNameFormat procedure, public :: set_FileNameFormat procedure, public :: calc_NextUpdate procedure, public :: get_FileNumber procedure, public :: clamp_STEP Type-Bound Procedures procedure, public :: nearcell_check procedure, public :: nearest_cell procedure, public :: nearest_search_kdTree procedure, public :: nearest_search_exact procedure, public :: get_movementVectorOfBoundarySurface procedure, public :: get_flowVelocityInCELL procedure, public :: get_allOfCellCenters procedure, public :: get_cellCenterOf procedure, public :: get_MinMaxOfGrid procedure, public :: get_cellVerticesOf procedure, public :: get_info => get_gridInformation procedure, public :: read_FLD procedure, public :: read_INP procedure, public :: read_array => read_Array procedure, public :: read_VTK procedure, public :: updateWithFlowFieldFile procedure, public :: setupWithFlowFieldFile procedure, public :: search_refCELL procedure, public :: adhesionCheckOnBound procedure, public :: get_nearerSearchFalseRate procedure, public :: get_num_nearerSearchFalse procedure, public :: update => update_FlowField procedure, public :: isUpdateTiming procedure, public :: get_defaultFlowFileName procedure, public :: set_time => set_timeSTEPinFLOW procedure, public :: get_requiredFileName => get_requiredFlowFieldFileName Functions public function FlowField_ (time, PATH2FlowFile, DeltaT, OFFSET, outputINTERVAL, LoopHead, LoopTail, meshFile) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: time character, intent(in) :: PATH2FlowFile double precision, intent(in) :: DeltaT integer, intent(in) :: OFFSET integer, intent(in) :: outputINTERVAL integer, intent(in) :: LoopHead integer, intent(in) :: LoopTail character, intent(in), optional :: meshFile Return Value type( FlowField )","tags":"","loc":"module/flow_field_m.html"},{"title":"adjacencySolver_m – Droplets Simulation","text":"セルの隣接関係解決モジュール Contents Derived Types AdjacencySolver Subroutines solve_BoundaryAndAdjacency Derived Types type, public :: AdjacencySolver 隣接関係ソルバークラス Components Type Visibility Attributes Name Initial procedure, public :: set_halfFaceArray procedure, public :: check_halfFace procedure, public :: find_boundFaceInformation procedure, public :: find_adjacentCellID Subroutines public subroutine solve_BoundaryAndAdjacency (cellVertices, cellBoundFaces, boundFaceVertices, adjacentCellArray) 境界面と隣接関係を、それぞれ配列に格納 Arguments Type Intent Optional Attributes Name integer, intent(in) :: cellVertices (:,:) integer :: cellBoundFaces (:,:) integer, intent(out), allocatable :: boundFaceVertices (:,:) integer :: adjacentCellArray (:,:)","tags":"","loc":"module/adjacencysolver_m.html"},{"title":"conditionValue_m – Droplets Simulation","text":"飛沫計算用の諸条件を取り扱う Used by module~~conditionvalue_m~~UsedByGraph module~conditionvalue_m conditionValue_m proc~simulationsetup simulationSetUp proc~simulationsetup->module~conditionvalue_m program~droplet2csv droplet2CSV program~droplet2csv->module~conditionvalue_m program~dropletcount dropletCount program~dropletcount->module~conditionvalue_m program~boxflowfield boxFlowField program~boxflowfield->module~conditionvalue_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types conditionValue_t Functions read_condition Derived Types type, public :: conditionValue_t 条件値クラス\n条件指定ファイル（namelist）を読み込んだ結果を格納する\n飛沫計算用の諸条件をまとめた構造体 Components Type Visibility Attributes Name Initial double precision, public :: dt double precision, public :: L double precision, public :: U double precision, public :: direction_g (3) character, public, allocatable :: initialDistributionFName integer, public :: restart integer, public :: stepEnd integer, public :: outputInterval integer, public :: num_drop integer, public :: periodicGeneration real, public :: T real, public :: RH character, public, allocatable :: path2FlowFile character, public, allocatable :: meshFile double precision, public :: DT_FLOW integer, public :: OFFSET integer, public :: INTERVAL_FLOW integer, public :: LoopHead integer, public :: LoopTail procedure, public :: isInitialDistributionSpecified 飛沫初期分布ファイルが指定されたか否かを返す procedure, public :: isMeshFileSpecified メッシュファイルが別途指定されたか否かを返す Functions public function read_condition (dir) result(self) 条件ファイルを読み込み、結果を構造体で返す。\nこのサブルーチン実装当時、構造体をそのままnamelistにできることを知らず、わざわざ変数ひとつひとつ定義した。\n現在ここを変えると進行中のプロジェクト（オフィス飛沫計算など）に影響が出るおそれがあり、触れない。\nいつか修正したい。 Arguments Type Intent Optional Attributes Name character, intent(in) :: dir Return Value type( conditionValue_t )","tags":"","loc":"module/conditionvalue_m.html"},{"title":"caseName_m – Droplets Simulation","text":"Used by module~~casename_m~~UsedByGraph module~casename_m caseName_m program~main MAIN program~main->module~casename_m program~dropletcount dropletCount program~dropletcount->module~casename_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines case_check Subroutines public subroutine case_check (caseName_array) case名をキーボードから取得する。\nTXTファイルを指定すると、それを全行読み込んで配列に格納。 Arguments Type Intent Optional Attributes Name character, intent(out), allocatable :: caseName_array (:)","tags":"","loc":"module/casename_m.html"},{"title":"filename_m – Droplets Simulation","text":"Used by module~~filename_m~~UsedByGraph module~filename_m filename_m proc~read_condition read_condition proc~read_condition->module~filename_m proc~case_check case_check proc~case_check->module~filename_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables adjacencyFileName boundaryFileName conditionFileName InitialPositionFileName InitialDistributionFileName kdTreeFName Variables Type Visibility Attributes Name Initial character(len=13), public, parameter :: adjacencyFileName = 'adjacency.txt' character(len=12), public, parameter :: boundaryFileName = 'boundary.txt' character(len=21), public, parameter :: conditionFileName = 'condition.nml' character(len=20), public, parameter :: InitialPositionFileName = 'initial_position.csv' character(len=22), public, parameter :: InitialDistributionFileName = 'InitialDistribution.bu' character(len=20), public, parameter :: kdTreeFName = 'kdTree.txt'","tags":"","loc":"module/filename_m.html"},{"title":"VTK_operator_m – Droplets Simulation","text":"Uses unstructuredElement_m module~~vtk_operator_m~~UsesGraph module~vtk_operator_m VTK_operator_m module~unstructuredelement_m unstructuredElement_m module~vtk_operator_m->module~unstructuredelement_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~vtk_operator_m~~UsedByGraph module~vtk_operator_m VTK_operator_m proc~output_boxvtk output_boxVTK proc~output_boxvtk->module~vtk_operator_m proc~output_boxvtk~2 output_boxVTK proc~output_boxvtk~2->module~vtk_operator_m program~cube2usg CUBE2USG program~cube2usg->module~vtk_operator_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types UnstructuredGrid_inVTK Functions UnstructuredGrid_inVTK_ Derived Types type, public :: UnstructuredGrid_inVTK Components Type Visibility Attributes Name Initial type( node_t ), public, allocatable :: node_array (:) type(cell_inVTK_t), public, allocatable :: cell_array (:) procedure, public :: get_numCell procedure, public :: get_numNode procedure, public :: get_nodeCoordinate procedure, public :: get_cellVertices procedure, public :: set_nodeCoordinate procedure, public :: set_cellVertices Type-Bound Procedures procedure, public :: read => read_UnstructuredGrid_inVTK procedure, public :: output => output_UnstructuredGrid_inVTK Functions public function UnstructuredGrid_inVTK_ (cdn, vertices, types) Arguments Type Intent Optional Attributes Name real, intent(in) :: cdn (:,:) integer, intent(in) :: vertices (:,:) integer, intent(in) :: types (:) Return Value type( UnstructuredGrid_inVTK )","tags":"","loc":"module/vtk_operator_m.html"},{"title":"vector_m – Droplets Simulation","text":"Used by module~~vector_m~~UsedByGraph module~vector_m vector_m module~geometry_m geometry_m module~geometry_m->module~vector_m program~geometry_test geometry_test program~geometry_test->module~geometry_m program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->module~geometry_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces cross_product normalize_vector Functions cross_product_dble cross_product_real normalize_vector_dble normalize_vector_real Interfaces public interface cross_product public function cross_product_dble (a, b) result(cross) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (3) double precision, intent(in) :: b (3) Return Value double precision(3) public function cross_product_real (a, b) result(cross) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) real, intent(in) :: b (3) Return Value real(3) public interface normalize_vector public function normalize_vector_dble (a) result(normalized) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (3) Return Value double precision(3) public function normalize_vector_real (a) result(normalized) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) Return Value real(3) Functions public function cross_product_dble (a, b) result(cross) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (3) double precision, intent(in) :: b (3) Return Value double precision(3) public function cross_product_real (a, b) result(cross) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) real, intent(in) :: b (3) Return Value real(3) public function normalize_vector_dble (a) result(normalized) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (3) Return Value double precision(3) public function normalize_vector_real (a) result(normalized) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) Return Value real(3)","tags":"","loc":"module/vector_m.html"},{"title":"geometry_m – Droplets Simulation","text":"Uses vector_m module~~geometry_m~~UsesGraph module~geometry_m geometry_m module~vector_m vector_m module~geometry_m->module~vector_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~geometry_m~~UsedByGraph module~geometry_m geometry_m program~geometry_test geometry_test program~geometry_test->module~geometry_m program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->module~geometry_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions volume_tetra insideJudgment_tetra Subroutines insideJudgment_tetra_check Functions public function volume_tetra (vertices) result(volume) テトラの体積計算。 Arguments Type Intent Optional Attributes Name real, intent(in) :: vertices (3,4) Return Value real public function insideJudgment_tetra (vertices, point) result(isInside) 任意の点がテトラの内部にあるかどうかを判定する。\n点でテトラを分割したそれぞれの体積の和が、元々のテトラの体積を上回れば、点はテトラ外部にある。\nhttps://matcha-choco010.net/2018/03/14/point-in-tetrahedron/ Arguments Type Intent Optional Attributes Name real, intent(in) :: vertices (3,4) real, intent(in) :: point (3) Return Value logical Subroutines public subroutine insideJudgment_tetra_check (vertices, point, vol_sum, volume) Arguments Type Intent Optional Attributes Name real, intent(in) :: vertices (3,4) real, intent(in) :: point (3) real, intent(out) :: vol_sum real, intent(out) :: volume","tags":"","loc":"module/geometry_m.html"},{"title":"boxCounter_m – Droplets Simulation","text":"Used by module~~boxcounter_m~~UsedByGraph module~boxcounter_m boxCounter_m program~boxflowfield boxFlowField program~boxflowfield->module~boxcounter_m program~dropletcount dropletCount program~dropletcount->module~boxcounter_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types boxCounter Functions get_box_array get_FlagID Subroutines add_Flag Derived Types type, public :: boxCounter Components Type Visibility Attributes Name Initial real, public :: center (3) real, public :: width (3) real, public :: min_cdn (3) real, public :: max_cdn (3) logical, public, allocatable :: Flag (:) procedure, public :: add_Flag procedure, public :: get_FlagID Functions public function get_box_array (dir, num_Flag) result(new_box_array) Arguments Type Intent Optional Attributes Name character, intent(in) :: dir integer, intent(in) :: num_Flag Return Value type( boxCounter ),allocatable, (:) public function get_FlagID (self) result(id_array) Arguments Type Intent Optional Attributes Name class( boxCounter ) :: self Return Value integer,allocatable, (:) Subroutines public subroutine add_Flag (self, id_array) Arguments Type Intent Optional Attributes Name class( boxCounter ) :: self integer, intent(in) :: id_array (:)","tags":"","loc":"module/boxcounter_m.html"},{"title":"dropletGenerator_m – Droplets Simulation","text":"Uses virusDroplet_m dropletEquation_m module~~dropletgenerator_m~~UsesGraph module~dropletgenerator_m dropletGenerator_m module~virusdroplet_m virusDroplet_m module~dropletgenerator_m->module~virusdroplet_m module~dropletequation_m dropletEquation_m module~dropletgenerator_m->module~dropletequation_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~dropletgenerator_m~~UsedByGraph module~dropletgenerator_m dropletGenerator_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~dropletgenerator_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types SequentialArray DropletGenerator Functions DropletGenerator_ Derived Types type, public :: SequentialArray Components Type Visibility Attributes Name Initial procedure, public :: set_SequentialArray Type-Bound Procedures procedure, public :: get_value => get_valueFromSequentialArray procedure, public :: get_valueArray => get_valueArrayFromSequentialArray type, public :: DropletGenerator Components Type Visibility Attributes Name Initial type( DropletEquationSolver ), public, pointer :: equation type(placementBox), public, allocatable :: pBox_array (:) type( SequentialArray ), public :: initialRadiusArray type( SequentialArray ), public :: deadlineArray integer, public :: generateRate = 0 procedure, public :: set_dropletPlacementBox procedure, public :: calc_initialPosition Type-Bound Procedures procedure, public :: generateDroplet procedure, public :: periodicGeneration => dropletPeriodicGeneration Functions public function DropletGenerator_ (equation, radiusDistributionFile, positionDir, generationRate) Arguments Type Intent Optional Attributes Name type( DropletEquationSolver ), target :: equation character, intent(in) :: radiusDistributionFile character, intent(in) :: positionDir integer, intent(in) :: generationRate Return Value type( DropletGenerator )","tags":"","loc":"module/dropletgenerator_m.html"},{"title":"virusDroplet_m – Droplets Simulation","text":"Used by module~~virusdroplet_m~~UsedByGraph module~virusdroplet_m virusDroplet_m proc~simulationsetup simulationSetUp proc~simulationsetup->module~virusdroplet_m program~droplet2csv droplet2CSV program~droplet2csv->module~virusdroplet_m module~dropletgenerator_m dropletGenerator_m module~dropletgenerator_m->module~virusdroplet_m program~dropletcount dropletCount program~dropletcount->module~virusdroplet_m program~translate translate program~translate->module~virusdroplet_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~dropletgenerator_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types virusDroplet_t DropletGroup Functions read_backup Derived Types type, public :: virusDroplet_t Components Type Visibility Attributes Name Initial double precision, public :: position (3) double precision, public :: velocity (3) = 0.d0 integer, public :: coalesID = 0 integer, public :: refCellID = 0 integer, public :: adhesBoundID = 0 procedure, public :: stop_droplet procedure, public :: isEvaporating procedure, public :: evaporation procedure, public :: get_radius Type-Bound Procedures procedure, public :: isFloating => isDropletFloating procedure, public :: coalescenceID => dropletCoalescneceID type, public :: DropletGroup Components Type Visibility Attributes Name Initial type( virusDroplet_t ), public, allocatable :: droplet (:) integer, public, allocatable :: statusCSV (:) procedure, public :: output_backup procedure, public :: set_initialRadius procedure, public :: set_radiusLowerLimit procedure, public :: survival_check procedure, public :: coalescence_check Type-Bound Procedures procedure, public :: output_VTK => output_droplet_VTK procedure, public :: output_CSV => output_droplet_CSV procedure, public :: counter => dropletCounter procedure, public :: IDinBox => dropletIDinBox procedure, public :: inBox => dropletInBox procedure, public :: totalVolume => dropletTotalVolume procedure, public :: IDinState => dropletIDinState procedure, public :: getArea => get_dropletGroupArea procedure, public :: set_status => set_dropletGroupStatus procedure, public :: set_deadline => set_virusDeadline Functions public function read_backup (fname) result(dGroup_read) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname Return Value type( DropletGroup )","tags":"","loc":"module/virusdroplet_m.html"},{"title":"sort_m – Droplets Simulation","text":"Used by module~~sort_m~~UsedByGraph module~sort_m sort_m module~kdtree_m kdTree_m module~kdtree_m->module~sort_m program~sort_test sort_test program~sort_test->module~sort_m module~unstructuredgrid_m unstructuredGrid_m module~unstructuredgrid_m->module~kdtree_m program~kdtree_test kdTree_test program~kdtree_test->module~kdtree_m program~kdtree_test->module~unstructuredgrid_m module~flow_field_m flow_field_m module~flow_field_m->module~unstructuredgrid_m program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->module~unstructuredgrid_m program~boxflowfield boxFlowField program~boxflowfield->module~unstructuredgrid_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~flow_field_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types content_t HeapTree Functions real2content Subroutines heap_sort Derived Types type, public :: content_t コンテンツ構造体\n実数とIDをメンバに持つ Components Type Visibility Attributes Name Initial integer, public :: originID real, public :: value type, public :: HeapTree ヒープ木クラス\n実体は単なる配列だがツリー構造を表現している\n要素 i に注目すると、親ノードは要素 i/2(小数切り捨て) であり、子ノードは要素 2i, 2i + 1 である Components Type Visibility Attributes Name Initial procedure, public :: totalHeaplification procedure, public :: get_featuredChildID procedure, public :: rebuild_tree Functions public function real2content (real_array) result(content_array) 実数型配列をコンテンツ配列に変換する Arguments Type Intent Optional Attributes Name real, intent(in) :: real_array (:) Return Value type( content_t ),allocatable, (:) Subroutines public subroutine heap_sort (array_origin, array_sorted) ヒープソート Arguments Type Intent Optional Attributes Name type( content_t ), intent(in) :: array_origin (:) type( content_t ), intent(out) :: array_sorted (:)","tags":"","loc":"module/sort_m.html"},{"title":"plot3d_operator – Droplets Simulation","text":"CUBE出力ファイル形式：Plot3Dを取り扱うためのモジュール Used by module~~plot3d_operator~~UsedByGraph module~plot3d_operator plot3d_operator program~cube2usg CUBE2USG program~cube2usg->module~plot3d_operator Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types cube_inP3D plot3dNodeInfo Plot3dMesh Functions read_plot3d_multigrid Derived Types type, public :: cube_inP3D cube（Plot3D形式における立方体）構造体 Components Type Visibility Attributes Name Initial procedure, public :: areaOfCube procedure, public :: nearest_nodeID Type-Bound Procedures procedure, public :: isIncluded type, public :: plot3dNodeInfo 節点情報構造体 Components Type Visibility Attributes Name Initial integer, public :: cubeID integer, public :: nodeID (3) type, public :: Plot3dMesh Plot3Dメッシュクラス Components Type Visibility Attributes Name Initial type( cube_inP3D ), public, allocatable :: cubes (:) cube配列 procedure, public :: areaOfMesh Type-Bound Procedures procedure, public :: get_cubeShape procedure, public :: get_velocity procedure, public :: get_numCube procedure, public :: read_plot3d_function procedure, public :: nearestNodeInfo procedure, public :: get_cubeID_contains Functions public function read_plot3d_multigrid (fName) result(mesh) メッシュファイル（.g）を読み込んでメッシュクラスを返す関数 Arguments Type Intent Optional Attributes Name character, intent(in) :: fName Return Value type( Plot3dMesh )","tags":"","loc":"module/plot3d_operator.html"},{"title":"SCT_file_reader_m – Droplets Simulation","text":"SC/TETRA 出力のファイルを読み取り，データを取り出す. 今までのconverterと異なり, 本モジュールで独立して扱えるようになっている. 並列化には対応していない. Note セルの節点の並び順はwedge以外はvtkのものと同じ. SC/TETRAでは，セル番号および節点番号は0スタートなので, fortran運用のためインデックス+1. 頂点配列(NDNO)はセルタイプ毎に並んでいない. cell2verticesのrank 1には最大で8つ(hexahedron), face2verticesには4つの値が入るが, \n  値が入っていない箇所は全て-1に統一されている. Contents Variables MissingValueSize Derived Types sctregion_t sct_data_name_list_t sct_grid_t Subroutines get_cell_data_from_cellvertices Variables Type Visibility Attributes Name Initial real(kind=8), public, parameter :: MissingValueSize = 1.0d20 SC/TETRAで規定された欠測値の大きさ. Derived Types type, public :: sctregion_t type, public :: sct_data_name_list_t スカラーorベクトルデータの名前だけを取り出す. 構造体の配列にして使用する.\nregion用に使うことも出来る. その場合abbreviatedは使わない.\n異なる文字長の配列が実装できなかったのでこれで代用する. type, public :: sct_grid_t SC/TETRA メッシュクラス. \n必要最低限の変数のみ保持. 変数名はフォーマットに準拠. メッシュそのものを取り扱うのでメモリ圧迫する可能性大. \nソルバ内で使う場合はサブルーチンのローカル変数として扱う方が無難(自動開放されるはず) Type-Bound Procedures procedure, public :: includes_topology procedure, public :: is_fld_file procedure, public :: print_self procedure, public :: read_SCT_file procedure, public :: extract_original_cell_vertices procedure, public :: extract_cell_vertices procedure, public :: extract_ordered_cell_vertices procedure, public :: get_2d_array_of_point_coords procedure, public :: get_cell_types procedure, public :: get_element_count procedure, public :: get_vertex_count procedure, public :: get_tetrahedron_count procedure, public :: get_wedge_count procedure, public :: get_pyramid_count procedure, public :: get_hexahedron_count procedure, public :: get_region_count procedure, public :: get_region_namelist procedure, public :: extract_face2vertices_on_region procedure, public :: search_scalar_data procedure, public :: search_vector_data procedure, public :: get_data_titles Subroutines public subroutine get_cell_data_from_cellvertices (cell_data, cell2vertices, point_data) 各セル毎の頂点配列に関連する節点中心データからセル中心データを構築する. \n値はセルを構成する節点データの算術平均として計算する. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: cell_data (:) 出力されるセル中心データ. integer, intent(in) :: cell2vertices (:,:) 頂点配列. integer, intent(in) :: point_data (:) 任意の節点データ.","tags":"","loc":"module/sct_file_reader_m.html"},{"title":"boxFlowField – Droplets Simulation","text":"Uses conditionValue_m boxCounter_m unstructuredGrid_m terminalControler_m program~~boxflowfield~~UsesGraph program~boxflowfield boxFlowField module~conditionvalue_m conditionValue_m program~boxflowfield->module~conditionvalue_m module~boxcounter_m boxCounter_m program~boxflowfield->module~boxcounter_m module~terminalcontroler_m terminalControler_m program~boxflowfield->module~terminalcontroler_m module~unstructuredgrid_m unstructuredGrid_m program~boxflowfield->module~unstructuredgrid_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~kdtree_m kdTree_m module~unstructuredgrid_m->module~kdtree_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~boxflowfield~~CallsGraph program~boxflowfield boxFlowField proc~get_box_array get_box_array program~boxflowfield->proc~get_box_array proc~set_formattc set_formatTC program~boxflowfield->proc~set_formattc proc~output_countcsv output_countCSV program~boxflowfield->proc~output_countcsv proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ program~boxflowfield->proc~flowfieldunstructuredgrid_ interface~print_progress print_progress program~boxflowfield->interface~print_progress proc~output_boxvtk output_boxVTK program~boxflowfield->proc~output_boxvtk interface~read_csv read_CSV proc~get_box_array->interface~read_csv proc~get_dirfrompath get_DirFromPath proc~flowfieldunstructuredgrid_->proc~get_dirfrompath proc~unstructuredgrid_invtk_ UnstructuredGrid_inVTK_ proc~output_boxvtk->proc~unstructuredgrid_invtk_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i_box num_box nc caseName box_array bResult mesh Derived Types boxResult_t Subroutines output_countCSV output_boxVTK Variables Type Attributes Name Initial integer :: i_box integer :: num_box integer :: nc character(len=255) :: caseName type( boxCounter ), allocatable :: box_array (:) type( boxResult_t ), allocatable :: bResult (:) type( FlowFieldUnstructuredGrid ) :: mesh Derived Types type :: boxResult_t Components Type Visibility Attributes Name Initial real, public :: flowVelocity (3) Subroutines subroutine output_countCSV () Arguments None subroutine output_boxVTK () Arguments None","tags":"","loc":"program/boxflowfield.html"},{"title":"MAIN – Droplets Simulation","text":"Uses dropletMotionSimulation caseName_m program~~main~~UsesGraph program~main MAIN module~dropletmotionsimulation dropletMotionSimulation program~main->module~dropletmotionsimulation module~casename_m caseName_m program~main->module~casename_m module~timekeeper_m timeKeeper_m module~dropletmotionsimulation->module~timekeeper_m module~flow_field_m flow_field_m module~dropletmotionsimulation->module~flow_field_m module~dropletequation_m dropletEquation_m module~dropletmotionsimulation->module~dropletequation_m module~dropletgenerator_m dropletGenerator_m module~dropletmotionsimulation->module~dropletgenerator_m module~unstructuredgrid_m unstructuredGrid_m module~flow_field_m->module~unstructuredgrid_m module~dropletgenerator_m->module~dropletequation_m module~virusdroplet_m virusDroplet_m module~dropletgenerator_m->module~virusdroplet_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~kdtree_m kdTree_m module~unstructuredgrid_m->module~kdtree_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Simulation of Virus-Laden Droplets Behavior in AFDET\nby KIYOTA OGURA(2021/1/10)\nupdated by YUTA IDA Calls program~~main~~CallsGraph program~main MAIN proc~read_basicsettingonsimulation read_basicSettingOnSimulation program~main->proc~read_basicsettingonsimulation proc~maindropletloop mainDropletLoop program~main->proc~maindropletloop proc~case_check case_check program~main->proc~case_check proc~output_resultsummary output_ResultSummary program~main->proc~output_resultsummary proc~simulationsetup simulationSetUp program~main->proc~simulationsetup proc~read_textrecord read_textRecord proc~case_check->proc~read_textrecord proc~nowdateandtime nowDateAndTime proc~output_resultsummary->proc~nowdateandtime proc~dropletequationsolver_ DropletEquationSolver_ proc~simulationsetup->proc~dropletequationsolver_ proc~read_backup read_backup proc~simulationsetup->proc~read_backup proc~read_condition read_condition proc~simulationsetup->proc~read_condition proc~dropletgenerator_ DropletGenerator_ proc~simulationsetup->proc~dropletgenerator_ proc~flowfield_ FlowField_ proc~simulationsetup->proc~flowfield_ proc~basicparameter_ BasicParameter_ proc~dropletequationsolver_->proc~basicparameter_ proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ proc~flowfield_->proc~flowfieldunstructuredgrid_ proc~get_dirfrompath get_DirFromPath proc~flowfieldunstructuredgrid_->proc~get_dirfrompath Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables caseName caseID Variables Type Attributes Name Initial character(len=50), allocatable :: caseName (:) integer :: caseID","tags":"","loc":"program/main.html"},{"title":"translate – Droplets Simulation","text":"Uses virusDroplet_m program~~translate~~UsesGraph program~translate translate module~virusdroplet_m virusDroplet_m program~translate->module~virusdroplet_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. 全飛沫を、center(x,y)中心にphi[rad]だけ回転させ(z方向には回転しない),全飛沫の中心center(x,y,z)をcenter_translated(X,Y,Z)に移動させるサンプルコード\n by Hikaru Konishi Calls program~~translate~~CallsGraph program~translate translate proc~read_backup read_backup program~translate->proc~read_backup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables infected_person i dGroup vec center PI phi center_displacement center_translated Variables Type Attributes Name Initial character(len=15) :: infected_person integer :: i type( DropletGroup ) :: dGroup double precision :: vec (2) double precision, parameter :: center (3) = [4.73d0, 2.18d0, 1.255d0] double precision, parameter :: PI = acos(-1.d0) double precision, parameter :: phi = PI*0.d0 double precision :: center_displacement (3) double precision, parameter :: center_translated (3) = [0.955d0, 0.54d0, 1.255d0]","tags":"","loc":"program/translate.html"},{"title":"droplet2CSV – Droplets Simulation","text":"Uses virusDroplet_m conditionValue_m dropletEquation_m program~~droplet2csv~~UsesGraph program~droplet2csv droplet2CSV module~virusdroplet_m virusDroplet_m program~droplet2csv->module~virusdroplet_m module~conditionvalue_m conditionValue_m program~droplet2csv->module~conditionvalue_m module~dropletequation_m dropletEquation_m program~droplet2csv->module~dropletequation_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~droplet2csv~~CallsGraph program~droplet2csv droplet2CSV proc~read_condition read_condition program~droplet2csv->proc~read_condition proc~read_backup read_backup program~droplet2csv->proc~read_backup proc~basicparameter_ BasicParameter_ program~droplet2csv->proc~basicparameter_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables n stepEnd stepInterval caseName fname time condVal baseParam dGroup Variables Type Attributes Name Initial integer :: n integer :: stepEnd integer :: stepInterval character(len=255) :: caseName character(len=255) :: fname double precision :: time type( conditionValue_t ) :: condVal type( BasicParameter ) :: baseParam type( DropletGroup ) :: dGroup","tags":"","loc":"program/droplet2csv.html"},{"title":"dropletCount – Droplets Simulation","text":"Uses virusDroplet_m boxCounter_m conditionValue_m caseName_m program~~dropletcount~~UsesGraph program~dropletcount dropletCount module~virusdroplet_m virusDroplet_m program~dropletcount->module~virusdroplet_m module~casename_m caseName_m program~dropletcount->module~casename_m module~boxcounter_m boxCounter_m program~dropletcount->module~boxcounter_m module~conditionvalue_m conditionValue_m program~dropletcount->module~conditionvalue_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. ボックスを通過した飛沫をカウントする。\n飛沫計算の出力ファイルを順に読み込み、各ボックスに対して内外判定を行う。\nボックス側では、通過した飛沫のIDしか見ておらず、同じIDの飛沫のダブルカウントなどは起こらない。 Calls program~~dropletcount~~CallsGraph program~dropletcount dropletCount proc~case_check case_check program~dropletcount->proc~case_check proc~read_backup read_backup program~dropletcount->proc~read_backup proc~rateofinfection RateOfInfection program~dropletcount->proc~rateofinfection proc~get_box_array get_box_array program~dropletcount->proc~get_box_array proc~read_condition read_condition program~dropletcount->proc~read_condition proc~output_countcsv~2 output_countCSV program~dropletcount->proc~output_countcsv~2 proc~output_boxvtk~2 output_boxVTK program~dropletcount->proc~output_boxvtk~2 proc~read_textrecord read_textRecord proc~case_check->proc~read_textrecord interface~read_csv read_CSV proc~get_box_array->interface~read_csv proc~unstructuredgrid_invtk_ UnstructuredGrid_inVTK_ proc~output_boxvtk~2->proc~unstructuredgrid_invtk_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables n i_box num_box caseID caseName_array caseName fname id_array mainDroplet dGroup condVal box_array bResult Derived Types boxResult_t Functions RateOfInfection Subroutines output_countCSV output_boxVTK Variables Type Attributes Name Initial integer :: n integer :: i_box integer :: num_box integer :: caseID character(len=50), allocatable :: caseName_array (:) character, allocatable :: caseName character, allocatable :: fname integer, allocatable :: id_array (:) type( DropletGroup ) :: mainDroplet type( DropletGroup ) :: dGroup type( conditionValue_t ) :: condVal type( boxCounter ), allocatable :: box_array (:) type( boxResult_t ), allocatable :: bResult (:) Derived Types type :: boxResult_t Components Type Visibility Attributes Name Initial integer, public :: num_droplet real, public :: volume real, public :: RoI Functions elemental function RateOfInfection (volume) 1分間あたりの感染確率を計算（もとの資料では1時間あたりの感染確率だが、1分間あたりに換算） Arguments Type Intent Optional Attributes Name real, intent(in) :: volume Return Value real Subroutines subroutine output_countCSV () Arguments None subroutine output_boxVTK () Arguments None","tags":"","loc":"program/dropletcount.html"},{"title":"CUBE2USG – Droplets Simulation","text":"Uses array_m VTK_operator_m simpleFile_reader plot3d_operator program~~cube2usg~~UsesGraph program~cube2usg CUBE2USG module~array_m array_m program~cube2usg->module~array_m module~vtk_operator_m VTK_operator_m program~cube2usg->module~vtk_operator_m module~plot3d_operator plot3d_operator program~cube2usg->module~plot3d_operator module~simplefile_reader simpleFile_reader program~cube2usg->module~simplefile_reader module~unstructuredelement_m unstructuredElement_m module~vtk_operator_m->module~unstructuredelement_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. CUBE格子上の流速場をVTK非構造格子に載せるプログラム。\n非構造格子上の各格子に対して、CUBE格子上の最近傍節点を探し、対応付けを行う。\n対応する各節点における流速を配列にして、そのままバイナリファイル出力を行う。 Calls program~~cube2usg~~CallsGraph program~cube2usg CUBE2USG proc~read_textrecord read_textRecord program~cube2usg->proc~read_textrecord proc~read_plot3d_multigrid read_plot3d_multigrid program~cube2usg->proc~read_plot3d_multigrid proc~solve_correspondence solve_correspondence program~cube2usg->proc~solve_correspondence proc~output_2darray_asbinary output_2dArray_asBinary program~cube2usg->proc~output_2darray_asbinary proc~read_nodeinfo read_nodeInfo proc~solve_correspondence->proc~read_nodeinfo proc~search_nodeinfo search_nodeInfo proc~solve_correspondence->proc~search_nodeinfo proc~output_nodeinfo output_nodeInfo proc~solve_correspondence->proc~output_nodeinfo proc~timekeeper_ TimeKeeper_ proc~search_nodeinfo->proc~timekeeper_ proc~set_formattc set_formatTC proc~search_nodeinfo->proc~set_formattc proc~get_cellcenters get_cellCenters proc~search_nodeinfo->proc~get_cellcenters interface~print_progress print_progress proc~search_nodeinfo->interface~print_progress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables F_fname USG_fname casefname filename field_name caseName CorrespondenceFName fileID num_record num_cell nc nc_max velocity USG cubeMesh vtkCell2cubeNode Subroutines output_nodeInfo search_nodeInfo read_nodeInfo solve_correspondence Variables Type Attributes Name Initial character(len=100) :: F_fname character(len=100) :: USG_fname character(len=100) :: casefname character(len=50), parameter :: filename = 'name.txt' character(len=50), allocatable :: field_name (:) character(len=50), allocatable :: caseName (:) character(len=20), parameter :: CorrespondenceFName = 'vtkCell2cubeNode.txt' integer :: fileID integer :: num_record integer :: num_cell integer :: nc integer :: nc_max real, allocatable :: velocity (:,:) type( UnstructuredGrid_inVTK ) :: USG type( Plot3dMesh ) :: cubeMesh type( plot3dNodeInfo ), allocatable :: vtkCell2cubeNode (:) Subroutines subroutine output_nodeInfo () 対応する節点情報をアスキーファイルで出力するサブルーチン Arguments None subroutine search_nodeInfo () 非構造格子に対応する節点情報を探すサブルーチン Arguments None subroutine read_nodeInfo (success) 節点情報対応付けファイルを読み込むサブルーチン Arguments Type Intent Optional Attributes Name logical, intent(out) :: success subroutine solve_correspondence () 格子と節点の対応付けを解決するサブルーチン Arguments None","tags":"","loc":"program/cube2usg.html"},{"title":"geometry_test – Droplets Simulation","text":"Uses geometry_m program~~geometry_test~~UsesGraph program~geometry_test geometry_test module~geometry_m geometry_m program~geometry_test->module~geometry_m module~vector_m vector_m module~geometry_m->module~vector_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. テトラ内外判定をテストする。\n乱数で発生させた点群に対して判定を行う。\nテスト用のテトラは単純な形状で、平面の方程式から即座に内外判定が行えるので、これと比較してテストする。 Calls program~~geometry_test~~CallsGraph program~geometry_test geometry_test proc~plane_equation plane_equation program~geometry_test->proc~plane_equation proc~insidejudgment_tetra insideJudgment_tetra program~geometry_test->proc~insidejudgment_tetra proc~volume_tetra volume_tetra proc~insidejudgment_tetra->proc~volume_tetra interface~cross_product cross_product proc~volume_tetra->interface~cross_product proc~cross_product_dble cross_product_dble interface~cross_product->proc~cross_product_dble proc~cross_product_real cross_product_real interface~cross_product->proc~cross_product_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables tetra imax rand point plane_judge tetra_judge i Functions plane_equation Variables Type Attributes Name Initial real, parameter :: tetra (3,4) = reshape([0., 0., 0., 1., 0., 0., 0., 1., 0., 0., 0., 1.], shape(tetra)) integer, parameter :: imax = 10000 real :: rand (3,imax) real :: point (3) logical :: plane_judge logical :: tetra_judge integer :: i Functions function plane_equation (x, y) result(z) テスト用テトラの斜面の方程式 Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y Return Value real","tags":"","loc":"program/geometry_test.html"},{"title":"kdTree_test – Droplets Simulation","text":"Uses path_operator_m unstructuredGrid_m kdTree_m program~~kdtree_test~~UsesGraph program~kdtree_test kdTree_test module~path_operator_m path_operator_m program~kdtree_test->module~path_operator_m module~kdtree_m kdTree_m program~kdtree_test->module~kdtree_m module~unstructuredgrid_m unstructuredGrid_m program~kdtree_test->module~unstructuredgrid_m module~sort_m sort_m module~kdtree_m->module~sort_m module~unstructuredgrid_m->module~kdtree_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. kdTreeによる探索結果と、厳密なnearest探索結果が一致するかどうかをテスト Calls program~~kdtree_test~~CallsGraph program~kdtree_test kdTree_test proc~make_directory make_directory program~kdtree_test->proc~make_directory proc~test test program~kdtree_test->proc~test proc~kdtree_ kdTree_ program~kdtree_test->proc~kdtree_ proc~replace_str replace_str proc~make_directory->proc~replace_str proc~set_formattc set_formatTC proc~kdtree_->proc~set_formattc proc~heap_sort heap_sort proc~kdtree_->proc~heap_sort proc~real2content real2content proc~kdtree_->proc~real2content interface~print_progress print_progress proc~kdtree_->interface~print_progress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables grid xyz kd_tree iimx vtkFName kd_treeFName output_dir existance Subroutines test Variables Type Attributes Name Initial type( FlowFieldUnstructuredGrid ) :: grid real, allocatable :: xyz (:,:) type( kdTree ) :: kd_tree integer :: iimx character, allocatable :: vtkFName character, allocatable :: kd_treeFName character(len=10), parameter :: output_dir = 'test_check' logical :: existance Subroutines subroutine test () 乱数で発生させた点に対して、kdTreeによる探索結果と、厳密なnearest探索結果が一致するかどうかをテスト Arguments None","tags":"","loc":"program/kdtree_test.html"},{"title":"cellCenterCalc_test – Droplets Simulation","text":"Uses unstructuredGrid_m geometry_m program~~cellcentercalc_test~~UsesGraph program~cellcentercalc_test cellCenterCalc_test module~unstructuredgrid_m unstructuredGrid_m program~cellcentercalc_test->module~unstructuredgrid_m module~geometry_m geometry_m program~cellcentercalc_test->module~geometry_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~kdtree_m kdTree_m module~unstructuredgrid_m->module~kdtree_m module~vector_m vector_m module~geometry_m->module~vector_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. セル重心計算がうまく行っているかをテストする。\n具体的には、重心をテトラの内外判定にかけている。 Calls program~~cellcentercalc_test~~CallsGraph program~cellcentercalc_test cellCenterCalc_test proc~insidejudgment_tetra insideJudgment_tetra program~cellcentercalc_test->proc~insidejudgment_tetra proc~insidejudgment_tetra_check insideJudgment_tetra_check program~cellcentercalc_test->proc~insidejudgment_tetra_check proc~volume_tetra volume_tetra proc~insidejudgment_tetra->proc~volume_tetra proc~insidejudgment_tetra_check->proc~volume_tetra interface~cross_product cross_product proc~volume_tetra->interface~cross_product proc~cross_product_dble cross_product_dble interface~cross_product->proc~cross_product_dble proc~cross_product_real cross_product_real interface~cross_product->proc~cross_product_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables grid centers vertices center i imax n Variables Type Attributes Name Initial type( FlowFieldUnstructuredGrid ) :: grid real, allocatable :: centers (:,:) real, allocatable :: vertices (:,:) real :: center (3) integer :: i integer :: imax integer :: n","tags":"","loc":"program/cellcentercalc_test.html"},{"title":"sort_test – Droplets Simulation","text":"Uses array_m sort_m program~~sort_test~~UsesGraph program~sort_test sort_test module~array_m array_m program~sort_test->module~array_m module~sort_m sort_m program~sort_test->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. ヒープソートの機能テスト Calls program~~sort_test~~CallsGraph program~sort_test sort_test proc~testing testing program~sort_test->proc~testing proc~fisheryates_shuffle FisherYates_shuffle proc~testing->proc~fisheryates_shuffle proc~heap_sort heap_sort proc~testing->proc~heap_sort proc~real2content real2content proc~testing->proc~real2content Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables test1 test2 test3 Subroutines testing Variables Type Attributes Name Initial real, parameter :: test1 (10) = [-9.0, -1.0, 0.0, 3.0, 5.0, 7.2, 14.4, 99.9, 122.5, 255.0] real, parameter :: test2 (11) = [-99.0, -9.0, -1.0, 0.0, 3.0, 5.0, 7.2, 14.4, 99.9, 122.5, 255.0] real :: test3 (10000) Subroutines subroutine testing (array_correct) Arguments Type Intent Optional Attributes Name real, intent(in) :: array_correct (:)","tags":"","loc":"program/sort_test.html"},{"title":"boxFlowField.f90 – Droplets Simulation","text":"This file depends on sourcefile~~boxflowfield.f90~~EfferentGraph sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~boxflowfield.f90->sourcefile~conditionvalue.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~boxcounter.f90 boxCounter.f90 sourcefile~boxflowfield.f90->sourcefile~boxcounter.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~boxflowfield.f90->sourcefile~terminalcontroler.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~boxflowfield.f90->sourcefile~vtkmesh_operator.f90 sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~conditionvalue.f90->sourcefile~filename_mod.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~filename_mod.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~array.f90 array.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~vector.f90 vector.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~boxcounter.f90->sourcefile~simplefile_reader.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs boxFlowField Source Code boxFlowField.f90 Source Code program boxFlowField use conditionValue_m use boxCounter_m use unstructuredGrid_m use terminalControler_m implicit none integer i_box , num_box , nc character ( 255 ) caseName type ( boxCounter ), allocatable :: box_array (:) type boxResult_t real flowVelocity ( 3 ) end type type ( boxResult_t ), allocatable :: bResult (:) type ( FlowFieldUnstructuredGrid ) mesh box_array = get_box_array ( '.' , 0 ) num_box = size ( box_array ) do nc = 1 , iargc () ! コマンドライン引数を取得 call getarg ( nc , caseName ) print * , trim ( caseName ) ! mesh = FlowFieldUnstructuredGrid_(condVal%path2FlowFile, condVal%meshFile) if ( nc == 1 ) then mesh = FlowFieldUnstructuredGrid_ ( trim ( caseName ) // '/field_0000005125.array' , './case1.vtk' ) else call mesh % updateWithFlowFieldFile ( trim ( caseName ) // '/field_0000005125.array' ) end if allocate ( bResult ( num_box )) call set_formatTC ( '(\"BoxCellSerch [ #box : \",i6,\" / \",i6,\" ]\")' ) block integer i_cell i_cell = 1 do i_box = 1 , num_box call print_progress ([ i_box , num_box ]) ! i_cell = mesh%nearest_cell(box_array(i_box)%center) call mesh % search_refCELL ( box_array ( i_box )% center , i_cell ) bResult ( i_box )% flowVelocity = mesh % get_flowVelocityInCELL ( i_cell ) end do end block call output_countCSV call output_boxVTK deallocate ( bResult ) end do contains subroutine output_countCSV integer n_unit , i character (:), allocatable :: csvFName csvFName = trim ( caseName ) // '/BoxFlow.csv' print * , 'output: ' , csvFName open ( newunit = n_unit , file = csvFName , status = 'replace' ) write ( n_unit , '(\"x,y,z,u,v,w\")' ) do i = 1 , size ( box_array ) write ( n_unit , '(*(g0:,\",\"))' ) box_array ( i )% center , bResult ( i )% flowVelocity end do close ( n_unit ) end subroutine subroutine output_boxVTK use VTK_operator_m type ( UnstructuredGrid_inVTK ) boxMesh integer i , j , k real , parameter :: trans ( 3 , 8 ) = reshape ([ & 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 1.0 , 1.0 , 0.0 , & 0.0 , 0.0 , 1.0 , 1.0 , 0.0 , 1.0 , 0.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 ], shape ( trans )) real velArray ( 3 , size ( box_array )) real , allocatable :: xyz (:,:) integer , allocatable :: vertices (:,:), types (:) allocate ( xyz ( 3 , num_box * 8 )) allocate ( vertices ( 8 , num_box ), types ( num_box )) do i = 1 , num_box do j = 1 , 8 k = j + 8 * ( i - 1 ) xyz (:, k ) = box_array ( i )% min_cdn (:) + box_array ( i )% width (:) * trans (:, j ) vertices ( j , i ) = k end do types ( i ) = 11 end do do i = 1 , num_box velArray (:, i ) = bResult ( i )% flowVelocity end do boxMesh = UnstructuredGrid_inVTK_ ( xyz , vertices , types ) call boxMesh % output ( trim ( caseName ) // '/BoxFlow.vtk' , cellVector = velArray , vectorName = 'VEL' ) end subroutine end program boxFlowField","tags":"","loc":"sourcefile/boxflowfield.f90.html"},{"title":"MAIN.f90 – Droplets Simulation","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 MAIN.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 sourcefile~casename.f90 caseName.f90 sourcefile~main.f90->sourcefile~casename.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~timekeeper.f90 timeKeeper.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~timekeeper.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletequation.f90 sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~virusdroplet.f90 sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~conditionvalue.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~filename_mod.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~terminalcontroler.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~path_operator.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~casename.f90->sourcefile~simplefile_reader.f90 sourcefile~casename.f90->sourcefile~filename_mod.f90 sourcefile~dropletgenerator.f90->sourcefile~simplefile_reader.f90 sourcefile~dropletgenerator.f90->sourcefile~dropletequation.f90 sourcefile~dropletgenerator.f90->sourcefile~virusdroplet.f90 sourcefile~dropletgenerator.f90->sourcefile~filename_mod.f90 sourcefile~array.f90 array.f90 sourcefile~dropletgenerator.f90->sourcefile~array.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~path_operator.f90 sourcefile~dropletequation.f90->sourcefile~simplefile_reader.f90 sourcefile~vector.f90 vector.f90 sourcefile~dropletequation.f90->sourcefile~vector.f90 sourcefile~conditionvalue.f90->sourcefile~filename_mod.f90 sourcefile~unstructuredgrid.f90->sourcefile~filename_mod.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs MAIN Source Code MAIN.f90 Source Code !--------------------------------------------------------------------------------- !> Simulation of Virus-Laden Droplets Behavior in AFDET !> by KIYOTA OGURA(2021/1/10) !> updated by YUTA IDA !--------------------------------------------------------------------------------- PROGRAM MAIN !$ use omp_lib use dropletMotionSimulation use caseName_m implicit none character ( 50 ), allocatable :: caseName (:) integer caseID !$OMP parallel !$OMP single !$ print *, \"Num threads:\", omp_get_num_threads() !$OMP end single !$OMP end parallel call read_basicSettingOnSimulation call case_check ( caseName ) DO caseID = 1 , size ( caseName ) !実行数だけループ（通常1回） call simulationSetUp ( trim ( caseName ( caseID ))) !SetUp call mainDropletLoop !mainLoop call output_ResultSummary !最終結果出力 END DO END PROGRAM MAIN","tags":"","loc":"sourcefile/main.f90.html"},{"title":"initial_translate.f90 – Droplets Simulation","text":"This file depends on sourcefile~~initial_translate.f90~~EfferentGraph sourcefile~initial_translate.f90 initial_translate.f90 sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~initial_translate.f90->sourcefile~virusdroplet.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs translate Source Code initial_translate.f90 Source Code !>全飛沫を、center(x,y)中心にphi[rad]だけ回転させ(z方向には回転しない),全飛沫の中心center(x,y,z)をcenter_translated(X,Y,Z)に移動させるサンプルコード !> by Hikaru Konishi program translate use virusDroplet_m implicit none character ( 15 ) infected_person integer i type ( dropletGroup ) dGroup double precision vec ( 2 ) double precision , parameter :: center ( 3 ) = [ 4.73d0 , 2.18d0 , 1.255d0 ], PI = acos ( - 1.d0 ), phi = PI * 0.d0 double precision center_displacement ( 3 ) double precision , parameter :: center_translated ( 3 ) = [ 0.955d0 , 0.54d0 , 1.255d0 ] print * , 'Who is infected ?' read ( 5 , '(A)' ) infected_person vec = 0.0d0 center_displacement = 0.0d0 center_displacement = center_translated - center dGroup = read_backup ( 'InitialDistribution.bu' ) !読み込むBUファイル名 print * , 'phi:' , phi print * , 'PI:' , PI do i = 1 , size ( dGroup % droplet ) !回転を行うループ vec = dGroup % droplet ( i )% position ( 1 : 2 ) - center ( 1 : 2 ) dGroup % droplet ( i )% position ( 1 ) = cos ( phi ) * vec ( 1 ) - sin ( phi ) * vec ( 2 ) + center ( 1 ) dGroup % droplet ( i )% position ( 2 ) = sin ( phi ) * vec ( 1 ) + cos ( phi ) * vec ( 2 ) + center ( 2 ) end do do i = 1 , size ( dGroup % droplet ) !平行移動を行うループ dGroup % droplet ( i )% position ( 1 ) = dGroup % droplet ( i )% position ( 1 ) + center_displacement ( 1 ) dGroup % droplet ( i )% position ( 2 ) = dGroup % droplet ( i )% position ( 2 ) + center_displacement ( 2 ) dGroup % droplet ( i )% position ( 3 ) = dGroup % droplet ( i )% position ( 3 ) + center_displacement ( 3 ) end do call dGroup % output_backup ( 'InitialDistribution_' // trim ( infected_person ) // '.bu' ) !BUファイル出力 call dGroup % output_VTK ( 'InitialDistribution_' // trim ( infected_person ) // '.vtk' ) !確認VTKファイル出力 end program translate","tags":"","loc":"sourcefile/initial_translate.f90.html"},{"title":"droplet2CSV.f90 – Droplets Simulation","text":"This file depends on sourcefile~~droplet2csv.f90~~EfferentGraph sourcefile~droplet2csv.f90 droplet2CSV.f90 sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~droplet2csv.f90->sourcefile~virusdroplet.f90 sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~droplet2csv.f90->sourcefile~dropletequation.f90 sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~droplet2csv.f90->sourcefile~conditionvalue.f90 sourcefile~vector.f90 vector.f90 sourcefile~dropletequation.f90->sourcefile~vector.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~dropletequation.f90->sourcefile~simplefile_reader.f90 sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~conditionvalue.f90->sourcefile~filename_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs droplet2CSV Source Code droplet2CSV.f90 Source Code program droplet2CSV use virusDroplet_m use conditionValue_m use dropletEquation_m implicit none integer n , stepEnd , stepInterval character ( 255 ) caseName , fname double precision time type ( conditionValue_t ) condVal type ( BasicParameter ) baseParam type ( DropletGroup ) dGroup print * , 'caseName = ?' read ( 5 , * ) caseName condVal = read_condition ( caseName ) baseParam = BasicParameter_ ( condVal % dt , condVal % L , condVal % U ) print * , 'End = ?' read ( 5 , * ) stepEnd print * , 'interval = ?' read ( 5 , * ) stepInterval dGroup % statusCSV = [ 0 , 1 , - 1 , - 2 ] do n = 0 , stepEnd , stepInterval write ( fname , '(\"' // trim ( caseName ) // '/backup/backup_\", i0 , \".bu\")' ) n dGroup = read_backup ( fname ) time = baseParam % TimeStep2RealTime ( step = n , dimension = . true .) if ( n == 0 ) then call dGroup % output_CSV ( trim ( caseName ) // '/particle.csv' , time , initial = . true .) else call dGroup % output_CSV ( trim ( caseName ) // '/particle.csv' , time , initial = . false .) end if end do end program droplet2CSV","tags":"","loc":"sourcefile/droplet2csv.f90.html"},{"title":"dropletCount.f90 – Droplets Simulation","text":"This file depends on sourcefile~~dropletcount.f90~~EfferentGraph sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~boxcounter.f90 boxCounter.f90 sourcefile~dropletcount.f90->sourcefile~boxcounter.f90 sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~dropletcount.f90->sourcefile~virusdroplet.f90 sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~dropletcount.f90->sourcefile~conditionvalue.f90 sourcefile~casename.f90 caseName.f90 sourcefile~dropletcount.f90->sourcefile~casename.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~dropletcount.f90->sourcefile~vtkmesh_operator.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~boxcounter.f90->sourcefile~simplefile_reader.f90 sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~conditionvalue.f90->sourcefile~filename_mod.f90 sourcefile~casename.f90->sourcefile~simplefile_reader.f90 sourcefile~casename.f90->sourcefile~filename_mod.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs dropletCount Source Code dropletCount.f90 Source Code program dropletCount !!ボックスを通過した飛沫をカウントする。 !!飛沫計算の出力ファイルを順に読み込み、各ボックスに対して内外判定を行う。 !!ボックス側では、通過した飛沫のIDしか見ておらず、同じIDの飛沫のダブルカウントなどは起こらない。 use virusDroplet_m use conditionValue_m ! use dropletEquation_m use boxCounter_m use caseName_m implicit none integer n , i_box , num_box , caseID character ( 50 ), allocatable :: caseName_array (:) character (:), allocatable :: caseName , fname integer , allocatable :: id_array (:) type ( DropletGroup ) mainDroplet , dGroup type ( conditionValue_t ) condVal ! type(BasicParameter) baseParam type ( boxCounter ), allocatable :: box_array (:) type boxResult_t integer num_droplet real volume , RoI end type type ( boxResult_t ), allocatable :: bResult (:) call case_check ( caseName_array ) !print*, 'caseName = ?' !read(5, *) caseName do caseID = 1 , size ( caseName_array ) caseName = trim ( caseName_array ( caseID )) condVal = read_condition ( caseName ) ! baseParam = BasicParameter_(condVal%dt, condVal%L, condVal%U) box_array = get_box_array ( caseName , condVal % num_drop ) num_box = size ( box_array ) do n = 0 , condVal % stepEnd , condVal % outputInterval if ( n == 0 ) then fname = caseName // '/backup/InitialDistribution.bu' else block character ( 255 ) str write ( str , '(\"' // caseName // '/backup/backup_\", i0 , \".bu\")' ) n fname = trim ( str ) end block end if mainDroplet = read_backup ( fname ) do i_box = 1 , num_box id_array = mainDroplet % IDinBox ( dble ( box_array ( i_box )% min_cdn ), dble ( box_array ( i_box )% max_cdn )) call box_array ( i_box )% add_Flag ( id_array ) end do end do allocate ( bResult ( num_box )) do i_box = 1 , num_box id_array = box_array ( i_box )% get_FlagID () dGroup % droplet = mainDroplet % droplet ( id_array ) bResult ( i_box )% num_droplet = size ( dGroup % droplet ) bResult ( i_box )% volume = real ( dGroup % totalVolume () * condVal % L ** 3 * 1.d6 ) !有次元化[m&#94;3]したのち、[ml]に換算 end do bResult (:)% RoI = RateOfInfection ( bResult (:)% volume ) !1分間あたりの感染確率を計算 call output_countCSV call output_boxVTK deallocate ( bResult ) end do contains subroutine output_countCSV integer n_unit , i character (:), allocatable :: csvFName csvFName = caseName // '/BoxCount.csv' print * , 'output: ' , csvFName open ( newunit = n_unit , file = csvFName , status = 'replace' ) write ( n_unit , '(\"x,y,z,num_drop,volume[ml],RoI\")' ) do i = 1 , size ( box_array ) write ( n_unit , '(*(g0:,\",\"))' ) box_array ( i )% center , bResult ( i )% num_droplet , bResult ( i )% volume , bResult ( i )% RoI end do close ( n_unit ) end subroutine subroutine output_boxVTK use VTK_operator_m type ( UnstructuredGrid_inVTK ) mesh integer i , j , k real , parameter :: trans ( 3 , 8 ) = reshape ([ & 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 1.0 , 1.0 , 0.0 , & 0.0 , 0.0 , 1.0 , 1.0 , 0.0 , 1.0 , 0.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 ], shape ( trans )) real , allocatable :: xyz (:,:) integer , allocatable :: vertices (:,:), types (:) allocate ( xyz ( 3 , num_box * 8 )) allocate ( vertices ( 8 , num_box ), types ( num_box )) do i = 1 , num_box do j = 1 , 8 k = j + 8 * ( i - 1 ) xyz (:, k ) = box_array ( i )% min_cdn (:) + box_array ( i )% width (:) * trans (:, j ) vertices ( j , i ) = k end do types ( i ) = 11 end do mesh = UnstructuredGrid_inVTK_ ( xyz , vertices , types ) call mesh % output ( caseName // '/Box.vtk' , cellScalar = bResult (:)% RoI , scalarName = 'RoI' ) end subroutine !>1分間あたりの感染確率を計算（もとの資料では1時間あたりの感染確率だが、1分間あたりに換算） elemental real function RateOfInfection ( volume ) real , intent ( in ) :: volume RateOfInfection = 1. - exp ( - volume * 1.e7 / ( 90 0. / 6 0. )) end function end program dropletCount","tags":"","loc":"sourcefile/dropletcount.f90.html"},{"title":"CUBE2USG.f90 – Droplets Simulation","text":"This file depends on sourcefile~~cube2usg.f90~~EfferentGraph sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~timekeeper.f90 timeKeeper.f90 sourcefile~cube2usg.f90->sourcefile~timekeeper.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~cube2usg.f90->sourcefile~unstructuredelement.f90 sourcefile~plot3d_operator.f90 plot3d_operator.f90 sourcefile~cube2usg.f90->sourcefile~plot3d_operator.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~cube2usg.f90->sourcefile~terminalcontroler.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~cube2usg.f90->sourcefile~simplefile_reader.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~cube2usg.f90->sourcefile~vtkmesh_operator.f90 sourcefile~array.f90 array.f90 sourcefile~cube2usg.f90->sourcefile~array.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs CUBE2USG Source Code CUBE2USG.f90 Source Code !>CUBE格子上の流速場をVTK非構造格子に載せるプログラム。 !>非構造格子上の各格子に対して、CUBE格子上の最近傍節点を探し、対応付けを行う。 !>対応する各節点における流速を配列にして、そのままバイナリファイル出力を行う。 program CUBE2USG use plot3d_operator use VTK_operator_m use simpleFile_reader use array_m implicit none character ( 100 ) F_fname , USG_fname , casefname character ( 50 ), parameter :: filename = 'name.txt' character ( 50 ), allocatable :: field_name (:), caseName (:) character ( 20 ), parameter :: CorrespondenceFName = 'vtkCell2cubeNode.txt' integer fileID , num_record , num_cell , nc , nc_max real , allocatable :: velocity (:,:) type ( UnstructuredGrid_inVTK ) USG type ( Plot3dMesh ) cubeMesh type ( plot3dNodeInfo ), allocatable :: vtkCell2cubeNode (:) call read_textRecord ( filename , field_name ) num_record = size ( field_name ) print * , 'Case Name ?' read ( 5 , '(A)' ) casefname call read_textRecord ( casefname , caseName ) nc_max = size ( caseName ) print * , 'UnstructuredGRID_FileName ?' read ( 5 , * ) USG_fname call USG % read ( USG_fname ) num_cell = USG % get_numCell () cubeMesh = read_plot3d_multigrid ( 'mesh.g' ) !Gファイル読み込み do nc = 1 , nc_max do fileID = 1 , num_record F_fname = trim ( caseName ( nc )) // '/output/' // trim ( field_name ( fileID )) call cubeMesh % read_plot3d_function ( F_fname ) !Fファイル読み込み if (. not . allocated ( vtkCell2cubeNode )) call solve_correspondence if (. not . allocated ( velocity )) allocate ( velocity ( 3 , num_cell )) block integer cellID character (:), allocatable :: fname_base do cellID = 1 , num_cell velocity (:, cellID ) = cubeMesh % get_velocity ( vtkCell2cubeNode ( cellID )) end do fname_base = F_fname (: len_trim ( F_fname ) - 2 ) !流速場配列をバイナリ出力 call output_2dArray_asBinary ( fname = fname_base // '.array' , array = velocity ) !確認用に、ひとつだけVTKファイル出力 if ( fileID == 1 ) call USG % output ( fname_base // '.vtk' , cellVector = velocity , vectorName = 'Velocity' ) end block end do end do contains !>対応する節点情報をアスキーファイルで出力するサブルーチン subroutine output_nodeInfo integer n_unit , i print * , 'output: ' , CorrespondenceFName open ( newunit = n_unit , file = CorrespondenceFName , status = 'replace' , action = 'write' ) write ( n_unit , '(\"#cube \", i0)' ) cubeMesh % get_numCube () write ( n_unit , '(\"cubeshape\", 3(x, i0))' ) cubeMesh % get_cubeShape () write ( n_unit , '(\"#usgcell \", i0)' ) num_cell do i = 1 , num_cell write ( n_unit , '(i0, x, 3(x, i0))' ) vtkCell2cubeNode ( i )% cubeID , vtkCell2cubeNode ( i )% nodeID (:) end do close ( n_unit ) end subroutine !>非構造格子に対応する節点情報を探すサブルーチン subroutine search_nodeInfo use timeKeeper_m use terminalControler_m use unstructuredElement_m integer i real progress_percent , estimation , speed type ( TimeKeeper ) tk real , allocatable :: cellCenter (:,:) tk = TimeKeeper_ () print * , \"START : CUBENODE SEARCH\" call set_formatTC ( '(\"SEARCH vtkcell2cubenode [ \",f6.2,\" % ] \", f8.1, \" sec is left.\")' ) allocate ( vtkCell2cubeNode ( num_cell )) cellCenter = get_cellCenters ( USG % node_array , USG % cell_array ) do i = 1 , num_cell progress_percent = real ( i * 100 ) / real ( num_cell ) speed = real ( i ) / tk % erapsedTime () estimation = real ( num_cell - i ) / ( speed + 1.e-9 ) call print_progress ([ progress_percent , estimation ]) vtkCell2cubeNode ( i ) = cubeMesh % nearestNodeInfo ( cellCenter (:, i )) end do end subroutine !>節点情報対応付けファイルを読み込むサブルーチン subroutine read_nodeInfo ( success ) use array_m logical , intent ( out ) :: success integer n_unit , i , num_cell_ , num_cube , cubeShape ( 3 ) character dummy * 10 print * , 'read: ' , CorrespondenceFName open ( newunit = n_unit , file = CorrespondenceFName , status = 'old' , action = 'read' ) read ( n_unit , * ) dummy , num_cube read ( n_unit , * ) dummy , cubeShape read ( n_unit , * ) dummy , num_cell_ if (( num_cell_ /= num_cell ). or .( num_cube /= cubeMesh % get_numCube ()). or .& . not . all ( cubeShape == cubeMesh % get_cubeShape ())) then print * , 'SizeERROR:' , num_cell_ , num_cell , num_cube , cubeMesh % get_numCube () success = . false . return end if allocate ( vtkCell2cubeNode ( num_cell_ )) do i = 1 , num_cell_ read ( n_unit , * ) vtkCell2cubeNode ( i )% cubeID , vtkCell2cubeNode ( i )% nodeID (:) end do close ( n_unit ) success = . true . end subroutine !>格子と節点の対応付けを解決するサブルーチン subroutine solve_correspondence logical existance , success inquire ( file = CorrespondenceFName , exist = existance ) if ( existance ) then !対応付けファイルが存在すれば読み込む call read_nodeInfo ( success ) else success = . false . !なければ失敗 end if if (. not . success ) then !対応付けに失敗すれば改めて最近傍節点の探索を行う call search_nodeInfo call output_nodeInfo end if end subroutine end program CUBE2USG","tags":"","loc":"sourcefile/cube2usg.f90.html"},{"title":"array.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~array.f90~~AfferentGraph sourcefile~array.f90 array.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletgenerator.f90->sourcefile~array.f90 sourcefile~sort_test.f90 sort_test.f90 sourcefile~sort_test.f90->sourcefile~array.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~array.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules array_m Source Code array.f90 Source Code module array_m implicit none contains subroutine output_2dArray_asBinary ( fname , array ) character ( * ), intent ( in ) :: fname real , intent ( in ) :: array (:,:) integer n_unit print * , 'output_bin2dArray : ' , fname open ( newunit = n_unit , file = fname , form = 'unformatted' , status = 'replace' ) write ( n_unit ) shape ( array ) write ( n_unit ) array close ( n_unit ) end subroutine subroutine read_2dArray_asBinary ( fname , array ) character ( * ), intent ( in ) :: fname real , allocatable , intent ( out ) :: array (:,:) integer n_unit , arrayShape ( 2 ) print * , 'read_bin2dArray : ' , fname open ( newunit = n_unit , file = fname , form = 'unformatted' , status = 'old' , action = 'read' ) read ( n_unit ) arrayShape (:) allocate ( array ( arrayShape ( 1 ), arrayShape ( 2 ))) read ( n_unit ) array close ( n_unit ) end subroutine subroutine read_1dArray_real ( fname , array ) character ( * ), intent ( in ) :: fname real , allocatable , intent ( out ) :: array (:) integer n_unit , size print * , 'read_1darray : ' , fname open ( newunit = n_unit , file = fname , status = 'old' , action = 'read' ) read ( n_unit , * ) size allocate ( array ( size )) read ( n_unit , * ) array close ( n_unit ) end subroutine function mean_2dArray ( array ) result ( mean ) real , intent ( in ) :: array (:,:) real mean ( size ( array , dim = 2 )) integer i do i = 1 , size ( array , dim = 1 ) mean ( i ) = sum ( array ( i , :)) / size ( array , dim = 2 ) end do end function function FisherYates_shuffle ( a ) result ( b ) real , intent ( in ) :: a (:) real b ( size ( a )), rand , tmp integer i , index b = a do i = size ( b ), 2 , - 1 call random_number ( rand ) index = int ( rand * ( i - 1 )) + 1 ! print *, index, i !SWAP tmp = b ( index ) b ( index ) = b ( i ) b ( i ) = tmp end do end function end module array_m","tags":"","loc":"sourcefile/array.f90.html"},{"title":"dropletEquation.f90 – Droplets Simulation","text":"This file depends on sourcefile~~dropletequation.f90~~EfferentGraph sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~vector.f90 vector.f90 sourcefile~dropletequation.f90->sourcefile~vector.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~dropletequation.f90->sourcefile~simplefile_reader.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~dropletequation.f90~~AfferentGraph sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletgenerator.f90->sourcefile~dropletequation.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletequation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~droplet2csv.f90 droplet2CSV.f90 sourcefile~droplet2csv.f90->sourcefile~dropletequation.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dropletEquation_m Source Code dropletEquation.f90 Source Code module dropletEquation_m implicit none private !>基礎変数クラス !>時間間隔や代表値を格納 type , public :: BasicParameter private double precision dt !無次元時間間隔 double precision L , U , Re ! integer, public, target :: timeStep = 0   !構造体の要素はtarget属性にできないぽい contains procedure :: repValue => representativeValue procedure TimeStep2RealTime end type double precision , parameter :: Rho = 1.205d0 ! 空気の密度[kg/m3] double precision , parameter :: Mu = 1.822d-5 ! 空気の粘性係数[Pa・sec] double precision , parameter :: Rho_d = 0.99822d3 ! 飛沫（水）の密度[kg/m3] double precision , parameter :: gamma = Rho / Rho_d !密度比（空気密度 / 飛沫(水)密度） !>飛沫方程式ソルバクラス !>蒸発方程式や運動方程式を解くメソッドを保持 type , public , extends ( BasicParameter ) :: DropletEquationSolver private double precision coeff_drdt !半径変化率の無次元係数 double precision G ( 3 ) !無次元重力加速度 real T , RH double precision minimumRadiusRatio double precision , allocatable :: minimumRadiusMatrix (:,:) contains procedure set_gravity_acceleration , set_dropletEnvironment , dropletEnvironment procedure set_coeff_drdt , set_minimumRadiusRatio procedure next_position , next_velocity procedure get_radiusLowerLimitRatio procedure :: evaporationEq => evaporationEquation procedure solve_motionEquation end type public BasicParameter_ , DropletEquationSolver_ contains type ( BasicParameter ) function BasicParameter_ ( delta_t , L_represent , U_represent ) double precision , intent ( in ) :: delta_t , L_represent , U_represent BasicParameter_ % dt = delta_t BasicParameter_ % L = L_represent BasicParameter_ % U = U_represent print * , 'Delta_Time =' , BasicParameter_ % dt BasicParameter_ % Re = BasicParameter_ % U * BasicParameter_ % L * Rho / Mu end function type ( DropletEquationSolver ) function DropletEquationSolver_ ( delta_t , L_represent , U_represent , & direction_g , Temperature , RelativeHumidity ) double precision , intent ( in ) :: delta_t , L_represent , U_represent double precision , intent ( in ) :: direction_g ( 3 ) real , intent ( in ) :: Temperature , RelativeHumidity DropletEquationSolver_ % BasicParameter = BasicParameter_ ( delta_t , L_represent , U_represent ) call DropletEquationSolver_ % set_gravity_acceleration ( direction_g ) call DropletEquationSolver_ % set_dropletEnvironment ( Temperature , RelativeHumidity ) end function subroutine set_gravity_acceleration ( self , direction_g ) use vector_m class ( DropletEquationSolver ) self double precision , intent ( in ) :: direction_g ( 3 ) double precision , parameter :: G_dim = 9.806650d0 ! 重力加速度[m/s2] double precision norm norm = G_dim * self % L / ( self % U * self % U ) self % G (:) = norm * normalize_vector ( direction_g (:)) !無次元重力加速度 print * , 'Dimensionless Acceleration of Gravity :' print * , self % G (:) end subroutine subroutine set_dropletEnvironment ( self , Temperature , RelativeHumidity ) class ( DropletEquationSolver ) self real , intent ( in ) :: Temperature , RelativeHumidity self % T = Temperature self % RH = RelativeHumidity call self % set_coeff_drdt () !温湿度依存の係数の設定 call self % set_minimumRadiusRatio () end subroutine real function dropletEnvironment ( self , name ) class ( DropletEquationSolver ) self character ( * ), intent ( in ) :: name select case ( name ) case ( 'Temperature' ) dropletEnvironment = self % T case ( 'RelativeHumidity' ) dropletEnvironment = self % RH case default dropletEnvironment = - 1.e20 end select end function subroutine set_coeff_drdt ( self ) class ( DropletEquationSolver ) self !===================================================================================== double precision Es , TK double precision , parameter :: Rv = 46 1.51d0 ! 水蒸気の気体定数[J/(kg.K)] double precision , parameter :: T0 = 27 3.15d0 ! [K] double precision , parameter :: D = 0.2564d-4 ! 水蒸気の拡散定数[m2/s] double precision , parameter :: Lv = 2.451d6 ! 水の蒸発潜熱[J/kg] double precision , parameter :: Es0 = 6.11d2 ! 基準温度における飽和蒸気圧[Pa] !===================================================================================== TK = dble ( self % T ) + T0 ! 室温を絶対温度[K]に変換 Es = Es0 * exp (( Lv / Rv ) * ( 1.0d0 / T0 - 1.0d0 / TK )) ! 室温における飽和蒸気圧 self % coeff_drdt = - D / ( self % U * self % L ) * ( 1.0d0 - dble ( self % RH ) / 10 0.d0 ) * Es / ( Rho_d * Rv * TK ) ! dr/dt の無次元係数 print * , 'coeff_drdt=' , self % coeff_drdt end subroutine subroutine set_minimumRadiusRatio ( self ) use simpleFile_reader class ( DropletEquationSolver ) self integer i , i_max call read_CSV ( 'data/minimum_radius.csv' , self % minimumRadiusMatrix ) i_max = size ( self % minimumRadiusMatrix , dim = 2 ) i = 1 do while ( self % minimumRadiusMatrix ( 1 , i ) < self % RH ) i = i + 1 if ( i == i_max ) exit end do self % minimumRadiusRatio = self % minimumRadiusMatrix ( 2 , i ) print * , 'Dmin/D0 =' , self % minimumRadiusRatio , self % RH end subroutine double precision function get_radiusLowerLimitRatio ( self ) class ( DropletEquationSolver ), intent ( in ) :: self ! if(RH < 64) then !     minimum_radius(:) = initial_radius(:)*0.19d0 ! else if(RH < 90) then !     minimum_radius(:) = initial_radius(:)*(0.073*exp(0.014*dble(RH))) ! else if(RH == 90) then !     minimum_radius(:) = initial_radius(:)*0.28d0 ! else if(RH < 100) then !     minimum_radius(:) = initial_radius(:)*(0.0001*exp(0.0869*dble(RH))) ! else !     minimum_radius(:) = initial_radius(:) ! end if get_radiusLowerLimitRatio = self % minimumRadiusRatio end function !蒸発方程式。半径変化量を返す。 function evaporationEquation ( self , radius ) result ( dr ) class ( DropletEquationSolver ) self double precision , intent ( in ) :: radius double precision drdt1 , dr1 , drdt2 , dr2 , r_approxi , dr !========= 飛沫半径の変化の計算　(2次精度ルンゲクッタ（ホイン）) =========================== drdt1 = self % coeff_drdt / radius dr1 = drdt1 * self % dt r_approxi = radius + dr1 drdt2 = self % coeff_drdt / r_approxi dr2 = drdt2 * self % dt dr = ( dr1 + dr2 ) * 0.5d0 end function subroutine solve_motionEquation ( self , X , V , Va , R ) class ( DropletEquationSolver ) self double precision , intent ( inout ) :: X ( 3 ), V ( 3 ) double precision , intent ( in ) :: Va ( 3 ), R double precision V_now ( 3 ) V_now (:) = V (:) V (:) = self % next_velocity ( V_now (:), Va (:), R ) X (:) = self % next_position ( X (:), V_now (:), V (:)) end subroutine function next_velocity ( self , vel_d , vel_a , radius_d ) result ( vel_d_next ) class ( DropletEquationSolver ) self double precision , intent ( in ) :: vel_d ( 3 ), vel_a ( 3 ), radius_d double precision speed_r , Re_d , CD , C , vel_d_next ( 3 ) if ( radius_d <= 0.d0 ) then print * , '**ZeroRadius ERROR**' , radius_d error stop end if speed_r = norm2 ( vel_a (:) - vel_d (:)) !相対速度の大きさ Re_d = ( speed_r * 2.0d0 * radius_d ) * self % Re CD = DragCoefficient ( Re_d ) !抗力係数 C = ( 3.0d0 * CD * gamma * speed_r ) / ( 8.0d0 * radius_d ) vel_d_next (:) = ( vel_d (:) + ( self % G (:) + C * vel_a (:) ) * self % dt ) / ( 1.0d0 + C * self % dt ) end function function next_position ( self , x1 , v1 , v2 ) result ( x2 ) class ( DropletEquationSolver ) self double precision , intent ( in ) :: x1 ( 3 ), v1 ( 3 ), v2 ( 3 ) double precision x2 ( 3 ) x2 (:) = x1 (:) + ( v1 (:) + v2 (:)) * 0.5d0 * self % dt end function double precision function DragCoefficient ( Re_d ) double precision , intent ( in ) :: Re_d double precision Re_d_ Re_d_ = Re_d + 1.d-9 !ゼロ割回避のため、小さな値を足す DragCoefficient = ( 2 4.0d0 / Re_d_ ) * ( 1.0d0 + 0.15d0 * ( Re_d_ ** 0.687d0 )) end function ! double precision function survival_rate(step) !     integer, intent(in) :: step !     double precision time !     !このへんはインフルエンザのデータ（現在不使用） !     ! if(RH == 80)then  !　相対湿度80%の時使用 !     !     survival_rate = 0.67d0*0.5102d0**(((L/U)*dt*dble(step-1))/3600.0d0) !     ! else if(RH == 50)then  !　相対湿度50%の時使用 !     !     survival_rate = 0.84d0*0.5735d0**(((L/U)*dt*dble(step-1))/3600.0d0) !     ! else if(RH == 35)then  !　相対湿度35%の時使用 !     !     survival_rate = 0.86d0*0.9240d0**(((L/U)*dt*dble(step-1))/3600.0d0) !     ! end if !     time = TimeOnSimu(step, dimension=.true.) !     !新型コロナウイルス（1.1時間で半減） !     survival_rate = 0.999825d0**(time) ! end function ! elemental double precision function virusDeadline(self, deathParameter) !     class(DropletEquationSolver), intent(in) :: self !     double precision, intent(in) :: deathParameter !     double precision, parameter :: halfLife = 3960.d0   !半減期 1.1 h ( = 3960 sec) !     double precision, parameter :: alpha = log(2.d0) / halfLife !     virusDeadline = - log(deathParameter) / alpha !     virusDeadline = virusDeadline * self%U/self%L !無次元化 ! end function double precision function representativeValue ( self , name ) class ( BasicParameter ) self character ( * ), intent ( in ) :: name ! if(L*U <= 0.d0) print*, '**WARNING** ZeroRepresentativeValue :', L, U   !代表値がゼロなら警告 select case ( name ) case ( 'length' ) representativeValue = self % L case ( 'speed' ) representativeValue = self % U case ( 'time' ) representativeValue = self % L / self % U case default print * , 'RepresentativeValueERROR : ' , name error stop end select end function double precision function TimeStep2RealTime ( self , step , dimension ) class ( BasicParameter ) self integer , intent ( in ) :: step logical , intent ( in ) :: dimension TimeStep2RealTime = step * self % dt if ( dimension ) TimeStep2RealTime = TimeStep2RealTime * self % repValue ( 'time' ) end function ! double precision function deltaTime() !     deltaTime = dt ! end function end module dropletEquation_m","tags":"","loc":"sourcefile/dropletequation.f90.html"},{"title":"path_operator.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~path_operator.f90~~AfferentGraph sourcefile~path_operator.f90 path_operator.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~flow_field.f90->sourcefile~path_operator.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~path_operator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~path_operator.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules path_operator_m Source Code path_operator.f90 Source Code module path_operator_m implicit none character ( 7 ), parameter , private :: OS = 'Linux' contains subroutine make_directory ( path ) character ( * ), intent ( in ) :: path character (:), allocatable :: directory select case ( trim ( OS )) case ( 'Linux' ) !for_Linux directory = replace_str ( path , from = '\\', to=' / ' ) call system(' mkdir - p - v '//directory) case (' Windows ')  !for_Windows directory =  replace_str(path, from=' / ', to=' \\ ' ) call system(' md '//directory) case default print*, ' OS ERROR : ', OS error stop end select end subroutine make_directory subroutine get_DirFromPath(path, directory, filename) character(*), intent(in) :: path character(:), intent(out), allocatable :: directory character(:), intent(out), allocatable , optional :: filename character(1) delimiter integer i if(index(path, ' / ') > 0) then delimiter = ' / ' else if(index(path, ' \\ ') > 0) then delimiter = ' \\ ' else print*, ' Delimiter was not found . ' if(present(filename)) filename = path directory = '' return end if i = index(path, delimiter, back=.true.) if(present(filename)) filename = trim(path(i+1:)) directory = path(:i) print*, ' Path = ', trim(path) print*, ' Directory = ', directory if(present(filename)) print*, ' Filename = ' , filename end subroutine function replace_str ( str , from , to ) character ( * ), intent ( in ) :: str character ( 1 ), intent ( in ) :: from , to character ( len_trim ( str )) :: replace_str integer :: i , l replace_str = str l = len_trim ( str ) do i = 1 , l if ( str ( i : i ) == from ) replace_str ( i : i ) = to end do end function end module path_operator_m","tags":"","loc":"sourcefile/path_operator.f90.html"},{"title":"terminalControler.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~terminalcontroler.f90~~AfferentGraph sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~terminalcontroler.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~terminalcontroler.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~terminalcontroler.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~kdtree.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules terminalControler_m Source Code terminalControler.f90 Source Code module terminalControler_m implicit none private character ( 1 ), parameter :: esc = achar ( 27 ) integer , parameter :: stdOut = 6 character (:), allocatable :: format_str public reset_formatTC , set_formatTC , print_progress , print_sameLine interface print_progress module procedure print_progress_int , print_progress_real end interface !|##Example !```Fortran !program main !   use terminalControler_m ! !   call set_formatTC('(\"CHECK halfFace [ #group : \",i6,\" / \",i6,\" ]\")') !   do groupID = 1, num_group !       call print_progress([groupID, num_group]) !   end do ! !end program main !``` contains subroutine reset_formatTC format_str = '' end subroutine subroutine set_formatTC ( fmt_str ) character ( * ), intent ( in ) :: fmt_str if ( allocated ( format_str )) then if ( fmt_str == format_str ) return end if format_str = fmt_str write ( stdOut , '()' ) !改行（あとで戻ってくるため） end subroutine subroutine print_progress_int ( array ) integer , intent ( in ) :: array (:) write ( stdOut , \"(a)\" , advance = 'no' ) esc // 'M' !カーソルが1行戻る write ( stdOut , format_str ) array (:) end subroutine subroutine print_progress_real ( array ) real , intent ( in ) :: array (:) write ( stdOut , \"(a)\" , advance = 'no' ) esc // 'M' !カーソルが1行戻る write ( stdOut , format_str ) array (:) end subroutine subroutine print_sameLine ( str ) character ( * ), intent ( in ) :: str write ( stdOut , \"(a)\" , advance = 'no' ) esc // 'M' !カーソルが1行戻る write ( stdOut , \"(a)\" ) str end subroutine end module","tags":"","loc":"sourcefile/terminalcontroler.f90.html"},{"title":"unstructuredElement.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~unstructuredelement.f90~~AfferentGraph sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~unstructuredelement.f90 sourcefile~cube2usg.f90->sourcefile~vtkmesh_operator.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~boxflowfield.f90->sourcefile~vtkmesh_operator.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~vtkmesh_operator.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules unstructuredElement_m Source Code unstructuredElement.f90 Source Code module unstructuredElement_m !!非構造要素モジュール !!非構造格子のベースとなる構造体を定義している implicit none private !>節点構造体（ただの座標配列） type , public :: node_t real coordinate ( 3 ) end type !>セル構造体（節点のID配列） type , public :: cell_t integer , allocatable :: nodeID (:) end type public get_MinMaxCDN , get_cellCenters contains ! function points2nodeArray(points) result(node_array) !     real, intent(in) :: points(:,:) !     type(node_t), allocatable :: node_array(:) !     integer i, num_points !     num_points = size(points, dim=2) !     allocate(node_array(num_points)) !     do i = 1, num_points !         node_array(i)%coordinate = points(:,i) !     end do ! end function function get_MinMaxCDN ( node ) result ( MinMax ) !!節点群の座標の最大最小を返す class ( node_t ), intent ( in ) :: node (:) real MinMax ( 3 , 2 ) MinMax ( 1 , 1 ) = minval ( node (:)% coordinate ( 1 )) MinMax ( 2 , 1 ) = minval ( node (:)% coordinate ( 2 )) MinMax ( 3 , 1 ) = minval ( node (:)% coordinate ( 3 )) print * , 'MIN_coordinates=' , MinMax (:, 1 ) MinMax ( 1 , 2 ) = maxval ( node (:)% coordinate ( 1 )) MinMax ( 2 , 2 ) = maxval ( node (:)% coordinate ( 2 )) MinMax ( 3 , 2 ) = maxval ( node (:)% coordinate ( 3 )) print * , 'MAX_coordinates=' , MinMax (:, 2 ) end function function get_cellCenters ( node , cell ) result ( centers ) !!すべてのセル重心を計算し、配列で返す class ( node_t ), intent ( in ) :: node (:) class ( cell_t ), intent ( in ) :: cell (:) real , allocatable :: centers (:,:) real x ( 3 ) integer i , k , num_node , num_cell , nodeID num_cell = size ( cell ) allocate ( centers ( 3 , num_cell )) do i = 1 , num_cell x (:) = 0.0 num_node = size ( cell ( i )% nodeID ) do k = 1 , num_node nodeID = cell ( i )% nodeID ( k ) x (:) = x (:) + node ( nodeID )% coordinate (:) end do centers (:, i ) = x (:) / real ( num_node ) end do end function end module unstructuredElement_m","tags":"","loc":"sourcefile/unstructuredelement.f90.html"},{"title":"timeKeeper.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~timekeeper.f90~~AfferentGraph sourcefile~timekeeper.f90 timeKeeper.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~timekeeper.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~timekeeper.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules timeKeeper_m Source Code timeKeeper.f90 Source Code module timeKeeper_m implicit none private type DateAndTime character ( 8 ) date character ( 10 ) time contains procedure :: string => DateAndTime2string end type type , public :: TimeKeeper private real startCPUtime , lastLapCPUtime type ( DateAndTime ) startDAT contains procedure startDateAndTime , erapsedTime , lapTime end type public TimeKeeper_ public nowDateAndTime , second2HMS contains type ( TimeKeeper ) function TimeKeeper_ () call cpu_time ( TimeKeeper_ % startCPUtime ) TimeKeeper_ % lastLapCPUtime = TimeKeeper_ % startCPUtime call date_and_time ( TimeKeeper_ % startDAT % date , TimeKeeper_ % startDAT % time ) end function real function lapTime ( self ) class ( TimeKeeper ) self real nowCPUtime call cpu_time ( nowCPUtime ) lapTime = nowCPUtime - self % lastLapCPUtime self % lastLapCPUtime = nowCPUtime end function function startDateAndTime ( self ) result ( str ) class ( TimeKeeper ), intent ( in ) :: self character (:), allocatable :: str str = self % startDAT % string () end function real function erapsedTime ( self ) class ( TimeKeeper ), intent ( in ) :: self real nowCPUtime call cpu_time ( nowCPUtime ) erapsedTime = nowCPUtime - self % startCPUtime end function function nowDateAndTime () result ( str ) type ( DateAndTime ) dat character (:), allocatable :: str call date_and_time ( dat % date , dat % time ) str = dat % string () end function function DateAndTime2string ( self ) result ( str ) class ( DateAndTime ), intent ( in ) :: self character (:), allocatable :: str str = self % date ( 1 : 4 ) // '/' // self % date ( 5 : 6 ) // '/' // self % date ( 7 : 8 ) // ' ' & // self % time ( 1 : 2 ) // ':' // self % time ( 3 : 4 ) // ':' // self % time ( 5 : 6 ) end function function second2HMS ( seconds ) result ( str ) real , intent ( in ) :: seconds integer h , m , s character ( 9 ) str s = int ( seconds ) h = s / 3600 s = s - h * 3600 m = s / 60 s = s - m * 60 write ( str , '(i3,\":\",i2,\":\",i2)' ) h , m , s end function end module timeKeeper_m","tags":"","loc":"sourcefile/timekeeper.f90.html"},{"title":"unstructuredGrid.f90 – Droplets Simulation","text":"This file depends on sourcefile~~unstructuredgrid.f90~~EfferentGraph sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~array.f90 array.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~unstructuredgrid.f90->sourcefile~filename_mod.f90 sourcefile~vector.f90 vector.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~unstructuredgrid.f90~~AfferentGraph sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules unstructuredGrid_m Source Code unstructuredGrid.f90 Source Code module unstructuredGrid_m use unstructuredElement_m use kdTree_m implicit none private type , extends ( cell_t ) :: cell_inFlow_t integer , allocatable :: boundFaceID (:), adjacentCellID (:) real center ( 3 ), flowVelocity ( 3 ), threshold end type type boundaryTriangle_t integer nodeID ( 3 ) real center ( 3 ), normalVector ( 3 ), moveVector ( 3 ) end type type , public :: FlowFieldUnstructuredGrid private type ( node_t ), allocatable :: NODEs (:) type ( cell_inFlow_t ), allocatable :: CELLs (:) type ( boundaryTriangle_t ), allocatable :: BoundFACEs (:) type ( kdTree ) kd_tree real MIN_CDN ( 3 ), MAX_CDN ( 3 ) integer :: num_refCellSearchFalse = 0 , num_refCellSearch = 0 contains private procedure , public :: nearest_cell , nearcell_check procedure , public :: nearest_search_exact , nearest_search_kdTree procedure , public :: get_flowVelocityInCELL , get_movementVectorOfBoundarySurface procedure , public :: get_cellCenterOf , get_allOfCellCenters procedure , public :: get_cellVerticesOf , get_MinMaxOfGrid procedure , public :: get_info => get_gridInformation procedure set_cellCenter , set_cellThreshold , set_MinMaxCDN , point2cellVelocity procedure , public :: read_VTK , read_array , read_INP , read_FLD !===================================================================== procedure , public :: setupWithFlowFieldFile , updateWithFlowFieldFile procedure nearer_cell procedure , public :: search_refCELL procedure , public :: adhesionCheckOnBound procedure , public :: get_num_nearerSearchFalse , get_nearerSearchFalseRate procedure AdjacencySolvingProcess procedure read_adjacency , read_boundaries , solve_adacencyOnFlowFieldUnstructuredGrid procedure output_boundaries , output_adjacency , boundary_setting , output_STL procedure setup_kdTree end type public FlowFieldUnstructuredGrid_ contains type ( FlowFieldUnstructuredGrid ) function FlowFieldUnstructuredGrid_ ( FlowFieldFile , meshFile ) use path_operator_m character ( * ), intent ( in ) :: FlowFieldFile character ( * ), intent ( in ), optional :: meshFile character (:), allocatable :: Dir if ( present ( meshFile )) then call FlowFieldUnstructuredGrid_ % setupWithFlowFieldFile ( FlowFieldFile , meshFile ) call get_DirFromPath ( meshFile , Dir ) else call FlowFieldUnstructuredGrid_ % setupWithFlowFieldFile ( FlowFieldFile ) call get_DirFromPath ( FlowFieldFile , Dir ) end if call FlowFieldUnstructuredGrid_ % AdjacencySolvingProcess ( Dir ) !流れ場の前処理 call FlowFieldUnstructuredGrid_ % setup_kdTree ( Dir ) end function subroutine setupWithFlowFieldFile ( self , FNAME , meshFile ) class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: FNAME character ( * ), intent ( in ), optional :: meshFile select case ( extensionOf ( FNAME )) case ( 'vtk' ) call self % read_VTK ( FNAME , meshOnly = . false .) case ( 'inp' ) call self % read_INP ( FNAME ) !INPを読み込む(SHARP用) case ( 'fld' ) call self % read_FLD ( FNAME , findTopology = . true ., findVelocity = . true .) if (. not . allocated ( self % CELLs )) then !まだ未割り当てのとき block character (:), allocatable :: topologyFNAME topologyFNAME = FNAME ( : index ( FNAME , '_' , back = . true .)) // '0' // '.fld' !ゼロ番にアクセス call self % read_FLD ( topologyFNAME , findTopology = . true ., findVelocity = . false .) end block call self % read_FLD ( FNAME , findTopology = . false ., findVelocity = . true .) end if case ( 'array' ) call self % read_VTK ( meshFile , meshOnly = . true .) call self % read_Array ( FNAME ) case default print * , 'FILE_EXTENSION NG : ' , FNAME error stop end select call self % set_MinMaxCDN () call self % set_cellCenter () call self % set_cellThreshold () end subroutine subroutine updateWithFlowFieldFile ( self , FNAME ) class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: FNAME select case ( extensionOf ( FNAME )) case ( 'vtk' ) call self % read_VTK ( FNAME , meshOnly = . false .) case ( 'inp' ) call self % read_INP ( FNAME ) !INPを読み込む(SHARP用) case ( 'fld' ) call self % read_FLD ( FNAME , findTopology = . false ., findVelocity = . true .) case ( 'array' ) call self % read_Array ( FNAME ) case default print * , 'FILE_EXTENSION NG : ' , FNAME error stop end select call self % set_MinMaxCDN () call self % set_cellCenter () call self % set_cellThreshold () call self % boundary_setting ( first = . false .) end subroutine subroutine AdjacencySolvingProcess ( self , dir ) class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: dir logical success call self % read_adjacency ( dir , success ) if ( success ) then call self % read_boundaries ( dir ) else call self % solve_adacencyOnFlowFieldUnstructuredGrid () call self % output_boundaries ( dir ) call self % output_adjacency ( dir ) end if call self % boundary_setting ( first = . true .) call self % output_STL ( dir // 'shape.stl' ) end subroutine subroutine set_MinMaxCDN ( self ) !節点群の座標最大最小の算出 class ( FlowFieldUnstructuredGrid ) self real MinMax ( 3 , 2 ) MinMax = get_MinMaxCDN ( self % NODEs ) self % MIN_CDN = MinMax (:, 1 ) self % MAX_CDN = MinMax (:, 2 ) end subroutine subroutine get_MinMaxOfGrid ( self , MIN_CDN , MAX_CDN ) !節点群の座標最大最小を返す class ( FlowFieldUnstructuredGrid ) self real , intent ( out ) :: MIN_CDN ( 3 ), MAX_CDN ( 3 ) MIN_CDN = self % MIN_CDN MAX_CDN = self % MAX_CDN end subroutine subroutine set_cellCenter ( self ) !セル重心の算出 class ( FlowFieldUnstructuredGrid ) self integer II , IIMX , n , num_node , nodeID real vector ( 3 ) IIMX = size ( self % CELLs ) DO II = 1 , IIMX num_node = size ( self % CELLs ( II )% nodeID ) vector (:) = 0.0 do n = 1 , num_node nodeID = self % CELLs ( II )% nodeID ( n ) vector (:) = vector (:) + self % NODEs ( nodeID )% coordinate (:) end do self % CELLs ( II )% center (:) = vector (:) / real ( num_node ) END DO end subroutine subroutine set_cellThreshold ( self ) !セル閾値の算出 class ( FlowFieldUnstructuredGrid ) self integer II , IIMX , n , num_node , nodeID real x , vector ( 3 ) IIMX = size ( self % CELLs ) DO II = 1 , IIMX num_node = size ( self % CELLs ( II )% nodeID ) x = 0.0 do n = 1 , num_node nodeID = self % CELLs ( II )% nodeID ( n ) vector (:) = self % NODEs ( nodeID )% coordinate (:) - self % CELLs ( II )% center (:) x = max ( x , norm2 ( vector )) end do self % CELLs ( II )% threshold = x ! print*, self%CELLs(II)%threshold END DO end subroutine subroutine read_VTK ( self , FNAME , meshOnly ) use VTK_operator_m class ( FlowFieldUnstructuredGrid ) self type ( UnstructuredGrid_inVTK ) vtk_mesh character ( * ), intent ( in ) :: FNAME logical , intent ( in ) :: meshOnly real , allocatable :: velocity (:,:) integer II , IIMX if ( meshOnly ) then call vtk_mesh % read ( FNAME ) else call vtk_mesh % read ( FNAME , cellVector = velocity ) end if self % NODEs = vtk_mesh % node_array IIMX = size ( vtk_mesh % cell_array ) if (. not . allocated ( self % CELLs )) allocate ( self % CELLs ( IIMX )) do II = 1 , IIMX self % CELLs ( II )% nodeID = vtk_mesh % cell_array ( II )% nodeID end do if (. not . meshOnly ) then do II = 1 , IIMX self % CELLs ( II )% flowVelocity (:) = velocity (:, II ) end do endif ! print*, NODEs(KKMX)%coordinate(:) ! print*, CELLs(IIMX)%flowVelocity(:) end subroutine subroutine read_Array ( self , FNAME ) use array_m class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: FNAME real , allocatable :: velocity (:,:) integer II call read_2dArray_asBinary ( FNAME , velocity ) if ( size ( self % CELLS ) /= size ( velocity , dim = 2 )) then print * , 'SIZE ERROR:' , size ( self % CELLS ), size ( velocity , dim = 2 ) error stop end if do II = 1 , size ( self % CELLS ) self % CELLs ( II )% flowVelocity (:) = velocity (:, II ) ! print*, velocity(:,II) end do ! print*, NODEs(KKMX)%coordinate(:) ! print*, CELLs(IIMX)%flowVelocity(:) end subroutine subroutine read_INP ( self , FNAME ) !  INPファイルを読み込み、節点データを要素データに変換する class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: FNAME INTEGER II , II2 , KK , AAmax , IIMX2 , AA , n_unit integer KKMX , IIMX character ( 6 ) cellshape real , allocatable :: UVWK (:,:) integer , allocatable :: ICN2 (:,:) integer , allocatable :: CELL_TYPE2 (:) print * , 'READ_INP:' , trim ( FNAME ) open ( newunit = n_unit , FILE = FNAME , status = 'old' , action = 'read' ) read ( n_unit , * ) KKMX , IIMX2 print * , 'KKMX,IIMX2=' , KKMX , IIMX2 if (. not . allocated ( self % NODEs )) allocate ( self % NODEs ( KKMX )) allocate ( ICN2 ( 6 , IIMX2 ), source = 0 ) allocate ( CELL_TYPE2 ( IIMX2 ), source = 0 ) DO KK = 1 , KKMX read ( n_unit , * ) AA , self % NODEs ( KK )% coordinate (:) END DO II = 0 DO II2 = 1 , IIMX2 read ( n_unit , fmt = '(I10)' , advance = 'no' ) AA !ここはセル番号なので無視 read ( n_unit , fmt = '(I6)' , advance = 'no' ) AA !ここはなんかしらん（だいたいゼロ） read ( n_unit , fmt = '(A6)' , advance = 'no' ) cellshape cellshape = adjustl ( cellshape ) !左詰め IF (( cellshape == 'tet' ). or .( cellshape == 'prism' ). or .( cellshape == 'pyr' )) THEN II = II + 1 if ( cellshape == 'tet' ) then CELL_TYPE2 ( II ) = 0 read ( n_unit , * ) ICN2 ( 1 , II ), ICN2 ( 2 , II ), ICN2 ( 3 , II ), ICN2 ( 4 , II ) if ( ICN2 ( 1 , II ) == 0. or . ICN2 ( 4 , II ) == 0 ) print * , 'ICN2_WARNING_tet:' , ICN2 (:, II ) ELSE IF ( cellshape == 'prism' ) THEN CELL_TYPE2 ( II ) = 1 read ( n_unit , * ) ICN2 ( 1 , II ), ICN2 ( 2 , II ), ICN2 ( 3 , II ), ICN2 ( 4 , II ), ICN2 ( 5 , II ), ICN2 ( 6 , II ) if ( ICN2 ( 1 , II ) == 0. or . ICN2 ( 6 , II ) == 0 ) print * , 'ICN2_WARNING_prism:' , ICN2 (:, II ) ELSE IF ( cellshape == 'pyr' ) THEN CELL_TYPE2 ( II ) = 2 read ( n_unit , * ) ICN2 ( 5 , II ), ICN2 ( 1 , II ), ICN2 ( 2 , II ), ICN2 ( 3 , II ), ICN2 ( 4 , II ) !INPは最初が山頂点であり、VTKでは最後が山頂点のため、読み込む順がこうなる。 if ( ICN2 ( 1 , II ) == 0. or . ICN2 ( 5 , II ) == 0 ) print * , 'ICN2_WARNING_pyr:' , ICN2 (:, II ) end if ELSE read ( n_unit , '()' ) !テトラでもプリズムでもピラミッドでもないならスルー ENDIF END DO IIMX = II allocate ( UVWK ( 3 , KKMX )) read ( n_unit , * ) AAmax read ( n_unit , '()' ) DO II = 1 , AAmax read ( n_unit , '()' ) END DO DO KK = 1 , KKMX read ( n_unit , * ) AA , UVWK (:, KK ) END DO close ( n_unit ) if (. not . allocated ( self % CELLs )) then allocate ( self % CELLs ( IIMX )) do II = 1 , IIMX select case ( CELL_TYPE2 ( II )) case ( 0 ) self % CELLs ( II )% nodeID = ICN2 ( 1 : 4 , II ) case ( 1 ) self % CELLs ( II )% nodeID = ICN2 ( 1 : 6 , II ) case ( 2 ) self % CELLs ( II )% nodeID = ICN2 ( 1 : 5 , II ) end select end do end if call self % point2cellVelocity ( UVWK ) end subroutine subroutine read_FLD ( self , FNAME , findTopology , findVelocity ) use SCT_file_reader_m class ( FlowFieldUnstructuredGrid ) self type ( sct_grid_t ) grid integer ii , iitet , iiwed , iipyr , iihex , iimx , iicnt integer kk , kkmx integer , allocatable :: tetras (:,:), wedges (:,:), pyramids (:,:), hexas (:,:) logical , intent ( in ) :: findTopology , findVelocity real ( 8 ), allocatable :: points (:,:) real ( 8 ), allocatable :: velocity (:,:) !, pressure(:) character ( * ), intent ( in ) :: FNAME print * , 'readFLD : ' , trim ( FNAME ) call grid % read_SCT_file ( FNAME ) if ( findTopology ) then !!ファイルが存在し, かつトポロジー情報が存在する場合以下の処理が行われる. call grid % extract_cell_vertices ( tetras , pyramids , wedges , hexas ) if ( allocated ( tetras )) then call grid % get_2d_array_of_point_coords ( points ) iitet = grid % get_tetrahedron_count () iipyr = grid % get_pyramid_count () iiwed = grid % get_wedge_count () iihex = grid % get_hexahedron_count () iimx = grid % get_element_count () kkmx = grid % get_vertex_count () if ( iihex > 0 ) then print * , 'Hexahedron is not yet supported.' , iihex error stop end if allocate ( self % CELLs ( iimx )) allocate ( self % NODEs ( kkmx )) do kk = 1 , kkmx self % NODEs ( kk )% coordinate (:) = real ( points (:, kk )) end do iicnt = 1 do ii = 1 , iitet self % CELLs ( iicnt )% nodeID = tetras (:, ii ) iicnt = iicnt + 1 end do do ii = 1 , iiwed self % CELLs ( iicnt )% nodeID = wedges (:, ii ) iicnt = iicnt + 1 end do do ii = 1 , iipyr self % CELLs ( iicnt )% nodeID = pyramids (:, ii ) iicnt = iicnt + 1 end do end if end if ! call grid%search_scalar_data(\"PRES\",pressure) if ( findVelocity ) then call grid % search_vector_data ( \"VEL\" , velocity ) call self % point2cellVelocity ( real ( velocity )) end if end subroutine subroutine read_adjacency ( self , path , success ) use filename_m , only : adjacencyFileName class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: path logical , intent ( out ) :: success integer II , NA , n_unit , num_cells , num_adj , num_BF , NCMAX character (:), allocatable :: FNAME character ( 255 ) str FNAME = trim ( path ) // adjacencyFileName inquire ( file = FNAME , exist = success ) if (. not . success ) then print * , 'AdjacencyFile was not found.' return end if print * , 'READ : ' , FNAME open ( newunit = n_unit , FILE = FNAME , status = 'old' , action = 'read' ) read ( n_unit , * ) num_cells if ( num_cells /= size ( self % CELLs )) then print * , '**SIZE MISMATCH** :' , num_cells , size ( self % CELLs ) success = . false . return end if read ( n_unit , * ) NCMAX DO II = 1 , num_cells read ( n_unit , '(A)' ) str read ( str , * ) num_adj allocate ( self % CELLs ( II )% adjacentCellID ( num_adj )) read ( str , * ) NA , self % CELLs ( II )% adjacentCellID (:) END DO DO II = 1 , num_cells read ( n_unit , '(A)' ) str read ( str , * ) num_BF allocate ( self % CELLs ( II )% boundFaceID ( num_BF )) read ( str , * ) NA , self % CELLs ( II )% boundFaceID (:) END DO close ( n_unit ) end subroutine subroutine output_adjacency ( self , path ) use filename_m , only : adjacencyFileName class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: path integer II , n_unit , num_cells , NCMAX character (:), allocatable :: FNAME FNAME = trim ( path ) // adjacencyFileName print * , 'OUTPUT:' , FNAME num_cells = size ( self % CELLs ) NCMAX = 5 !size(NEXT_CELL(:,:), dim=1) open ( newunit = n_unit , FILE = FNAME , STATUS = 'replace' ) write ( n_unit , * ) num_cells write ( n_unit , * ) NCMAX DO II = 1 , num_cells write ( n_unit , '(*(i0:,X))' ) size ( self % CELLs ( II )% adjacentCellID ), self % CELLs ( II )% adjacentCellID (:) END DO DO II = 1 , num_cells write ( n_unit , '(*(i0:,X))' ) size ( self % CELLs ( II )% boundFaceID ), self % CELLs ( II )% boundFaceID (:) END DO close ( n_unit ) end subroutine subroutine read_boundaries ( self , path ) use filename_m , only : boundaryFileName class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: path integer JB , n_unit , JBMX character (:), allocatable :: FNAME FNAME = trim ( path ) // boundaryFileName print * , 'READ : ' , FNAME open ( newunit = n_unit , FILE = FNAME , status = 'old' , action = 'read' ) read ( n_unit , * ) JBMX allocate ( self % BoundFACEs ( JBMX )) do JB = 1 , JBMX read ( n_unit , * ) self % BoundFACEs ( JB )% nodeID (:) end do close ( n_unit ) end subroutine subroutine output_boundaries ( self , path ) use filename_m , only : boundaryFileName class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: path integer JB , n_unit , JBMX character (:), allocatable :: FNAME FNAME = trim ( path ) // boundaryFileName print * , 'OUTPUT:' , FNAME JBMX = size ( self % BoundFACEs ) open ( newunit = n_unit , FILE = FNAME , STATUS = 'replace' ) write ( n_unit , * ) JBMX do JB = 1 , JBMX write ( n_unit , '(*(i0:,X))' ) self % BoundFACEs ( JB )% nodeID (:) end do close ( n_unit ) end subroutine subroutine setup_kdTree ( self , path ) use filename_m , only : kdTreeFName class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: path character (:), allocatable :: FNAME real , allocatable :: xyz (:,:) logical existance FNAME = trim ( path ) // kdTreeFName xyz = self % get_allOfCellCenters () inquire ( file = FNAME , exist = existance ) if (. not . existance ) then self % kd_tree = kdTree_ ( xyz ) call self % kd_tree % saveAsTXT ( FNAME ) print * , 'OUTPUT kdtree:' , FNAME else call self % kd_tree % read_kdTree ( FNAME ) print * , 'READ kdtree:' , FNAME end if end subroutine integer function nearest_cell ( self , X ) !!最近傍セル探索 class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self real , intent ( in ) :: X ( 3 ) !厳密かkdツリーかはここで切り替え ! nearest_cell = self%nearest_search_exact(X) nearest_cell = self % nearest_search_kdTree ( X ) end function integer function nearest_search_exact ( self , X ) !!厳密最近傍セル探索 class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self real , intent ( in ) :: X ( 3 ) integer II , IIMX real , allocatable :: distance (:) IIMX = size ( self % CELLs ) allocate ( distance ( IIMX )) !$omp parallel do DO II = 1 , IIMX distance ( II ) = norm2 ( self % CELLs ( II )% center (:) - X (:)) END DO !$omp end parallel do nearest_search_exact = minloc ( distance , dim = 1 ) !最小値インデックス end function integer function nearest_search_kdTree ( self , X ) !!kdツリーによる最近傍セル探索 class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self real , intent ( in ) :: X ( 3 ) real , allocatable :: xyz (:,:) xyz = self % get_allOfCellCenters () call self % kd_tree % search ( xyz , X , nearest_search_kdTree ) end function integer function nearer_cell ( self , X , NCN ) !近セルの探索（隣接セルから） class ( FlowFieldUnstructuredGrid ) self integer , intent ( in ) :: NCN real , intent ( in ) :: X ( 3 ) integer NA , featuringCellID , adjaCellID integer , allocatable :: adjacentCellIDs (:) real distance , distance_min logical update nearer_cell = NCN distance_min = norm2 ( self % CELLs ( nearer_cell )% center (:) - X (:)) !注目セル重心と粒子との距離 update = . true . do while ( update ) !更新が起こり続ける限り繰り返し update = . false . featuringCellID = nearer_cell !注目セル adjacentCellIDs = self % CELLs ( featuringCellID )% adjacentCellID (:) !注目セルの全隣接セル do NA = 1 , size ( adjacentCellIDs ) !注目セルの全隣接セルに対してループ。 adjaCellID = adjacentCellIDs ( NA ) !注目セルに隣接するセルのひとつ ! if (adjacentCELL <= 0) cycle checkAdjacent distance = norm2 ( self % CELLs ( adjaCellID )% center (:) - X (:)) !隣接セル重心と粒子との距離 if ( distance < distance_min ) then nearer_cell = adjaCellID distance_min = distance update = . true . end if end do end do end function logical function nearcell_check ( self , X , NCN ) class ( FlowFieldUnstructuredGrid ) self real , intent ( in ) :: X ( 3 ) integer , intent ( in ) :: NCN real :: distance distance = norm2 ( X (:) - self % CELLs ( NCN )% center (:)) !遠くのセルを参照していないかどうかのチェック !参照セルとの距離がセル閾値未満であればOK（この条件は経験則でしかない） if ( distance < self % CELLs ( NCN )% threshold ) then nearcell_check = . True . else nearcell_check = . False . ! print*, 'nearcell_check:False', distance, self%CELLs(NCN)%threshold end if end function subroutine search_refCELL ( self , X , reference_cell , stat ) class ( FlowFieldUnstructuredGrid ) self real , intent ( in ) :: X ( 3 ) integer , intent ( inout ) :: reference_cell logical , optional :: stat self % num_refCellSearch = self % num_refCellSearch + 1 reference_cell = self % nearer_cell ( X , reference_cell ) if ( present ( stat )) stat = . True . if (. not . self % nearcell_check ( X (:), reference_cell )) then reference_cell = self % nearest_cell ( X ) if ( present ( stat )) stat = . false . self % num_refCellSearchFalse = self % num_refCellSearchFalse + 1 end if end subroutine integer function get_num_nearerSearchFalse ( self ) class ( FlowFieldUnstructuredGrid ) self get_num_nearerSearchFalse = self % num_refCellSearchFalse end function real function get_nearerSearchFalseRate ( self ) class ( FlowFieldUnstructuredGrid ) self get_nearerSearchFalseRate = 10 0. * real ( self % num_refCellSearchFalse ) / real ( self % num_refCellSearch + 1 ) end function subroutine boundary_setting ( self , first ) !全境界面に対して外向き法線ベクトルと重心を算出 use vector_m class ( FlowFieldUnstructuredGrid ) self logical , intent ( in ) :: first integer II , JJ , JB , IIMX , JBMX , nodeID ( 3 ) real :: a ( 3 ), b ( 3 ), r ( 3 ), normalVector ( 3 ) type ( boundaryTriangle_t ), allocatable :: BoundFACEs_pre (:) IIMX = size ( self % CELLs ) if (. not . first ) BoundFACEs_pre = self % BoundFACEs do II = 1 , IIMX do JJ = 1 , size ( self % CELLs ( II )% boundFaceID ) JB = self % CELLs ( II )% boundFaceID ( JJ ) nodeID (:) = self % BoundFACEs ( JB )% nodeID (:) self % BoundFACEs ( JB )% center (:) = ( self % NODEs ( nodeID ( 1 ))% coordinate (:) & + self % NODEs ( nodeID ( 2 ))% coordinate (:) & + self % NODEs ( nodeID ( 3 ))% coordinate (:) ) / 3.0 a (:) = self % NODEs ( nodeID ( 2 ))% coordinate (:) - self % NODEs ( nodeID ( 1 ))% coordinate (:) b (:) = self % NODEs ( nodeID ( 3 ))% coordinate (:) - self % NODEs ( nodeID ( 1 ))% coordinate (:) normalVector (:) = cross_product ( a , b ) normalVector (:) = normalize_vector ( normalVector (:)) r (:) = self % CELLs ( II )% center (:) - self % BoundFACEs ( JB )% center (:) !面重心からセル重心へのベクトル if ( dot_product ( normalVector (:), r (:)) > 0.0 ) then normalVector (:) = normalVector (:) * ( - 1.0 ) !内積が正なら内向きなので、外に向ける end if self % BoundFACEs ( JB )% normalVector (:) = normalVector (:) ! print*,'center:',BoundFACEs(JB)%center(:) ! print*,'n_vector:',BoundFACEs(JB)%normalVector(:) end do end do JBMX = size ( self % BoundFACEs ) if ( first ) then do JB = 1 , JBMX self % BoundFACEs ( JB )% moveVector (:) = 0.0 end do else do JB = 1 , JBMX self % BoundFACEs ( JB )% moveVector (:) = self % BoundFACEs ( JB )% center (:) - BoundFACEs_pre ( JB )% center (:) end do end if end subroutine subroutine adhesionCheckOnBound ( self , position , radius , cellID , stat ) use vector_m class ( FlowFieldUnstructuredGrid ) self double precision , intent ( in ) :: position ( 3 ), radius integer , intent ( in ) :: cellID integer , intent ( out ) :: stat integer JJ , JB double precision :: r_vector ( 3 ), inner stat = 0 do JJ = 1 , size ( self % CELLs ( CellID )% boundFaceID ) JB = self % CELLs ( CellID )% boundFaceID ( JJ ) r_vector (:) = position (:) - self % BoundFACEs ( JB )% center (:) inner = dot_product ( r_vector (:), self % BoundFACEs ( JB )% normalVector (:)) !外向き法線ベクトルと位置ベクトルの内積は、平面からの飛び出し量に相当 if ( inner + radius > 0.d0 ) then !(飛び出し量+飛沫半径)がゼロ以上なら付着判定 stat = JB !付着した境界面番号 end if end do end subroutine subroutine point2cellVelocity ( self , pointVector ) class ( FlowFieldUnstructuredGrid ) self real , intent ( in ) :: pointVector (:,:) integer II , IIMX , n , ID , num_node if (. not . allocated ( self % CELLs )) then print * , '**MISS point2cellVelocity** CELL_ARRAY is not yet allocated.' return end if IIMX = size ( self % CELLs ) DO II = 1 , IIMX self % CELLs ( II )% flowVelocity (:) = 0.0 num_node = size ( self % CELLs ( II )% nodeID ) do n = 1 , num_node ID = self % CELLs ( II )% nodeID ( n ) self % CELLs ( II )% flowVelocity (:) = self % CELLs ( II )% flowVelocity (:) + pointVector (:, ID ) end do self % CELLs ( II )% flowVelocity (:) = self % CELLs ( II )% flowVelocity (:) / real ( num_node ) END DO end subroutine subroutine output_STL ( self , fname ) class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: fname integer i , n_unit , JB print * , 'output_STL : ' , fname open ( newunit = n_unit , file = fname , status = 'replace' ) write ( n_unit , '(\"solid test\")' ) do JB = 1 , size ( self % BoundFACEs ) write ( n_unit , '(\" facet normal\", 3(X,F7.4))' ) self % BoundFACEs ( JB )% normalVector (:) write ( n_unit , '(\" outer loop\")' ) do i = 1 , 3 write ( n_unit , '(\"  vertex\", 3(X,E11.4))' ) self % NODEs ( self % BoundFACEs ( JB )% nodeID ( i ))% coordinate (:) end do write ( n_unit , '(\" endloop\")' ) write ( n_unit , '(\" endfacet\")' ) end do write ( n_unit , '(\"endsolid test\")' ) close ( n_unit ) end subroutine subroutine solve_adacencyOnFlowFieldUnstructuredGrid ( self ) use adjacencySolver_m class ( FlowFieldUnstructuredGrid ) self integer i , j , num_adjacent , num_boundFace integer , parameter :: max_vertex = 6 , max_adjacent = 4 , max_boundFace = 4 integer , allocatable :: cellVertices (:,:) integer , allocatable :: adjacentCellArray (:,:) integer , allocatable :: cellBoundFaces (:,:) integer , allocatable :: boundFaceVertices (:,:) allocate ( cellVertices ( max_vertex , size ( self % CELLs )), source = 0 ) do i = 1 , size ( self % CELLs ) cellVertices ( 1 : size ( self % CELLs ( i )% nodeID (:)), i ) = self % CELLs ( i )% nodeID (:) end do allocate ( cellBoundFaces ( max_adjacent , size ( self % CELLs )), source = 0 ) allocate ( adjacentCellArray ( max_boundFace , size ( self % CELLs )), source = 0 ) call solve_BoundaryAndAdjacency ( cellVertices , cellBoundFaces , boundFaceVertices , adjacentCellArray ) allocate ( self % BoundFACEs ( size ( boundFaceVertices , dim = 2 ))) do j = 1 , size ( self % BoundFACEs ) self % BoundFACEs ( j )% nodeID = boundFaceVertices (:, j ) end do do i = 1 , size ( self % CELLs ) num_boundFace = max_boundFace - count ( cellBoundFaces (:, i ) == 0 ) self % CELLs ( i )% boundFaceID = cellBoundFaces ( 1 : num_boundFace , i ) num_adjacent = max_adjacent - count ( adjacentCellArray (:, i ) == 0 ) self % CELLs ( i )% adjacentCellID = adjacentCellArray ( 1 : num_adjacent , i ) end do end subroutine function extensionOf ( FileName ) result ( extension ) character ( * ), intent ( in ) :: FileName character (:), allocatable :: extension extension = FileName ( index ( FileName , '.' , back = . true .) + 1 : ) end function function get_flowVelocityInCELL ( self , ID ) result ( velocity ) class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self integer , intent ( in ) :: ID real velocity ( 3 ) velocity = self % CELLs ( ID )% flowVelocity end function function get_movementVectorOfBoundarySurface ( self , ID ) result ( vector ) class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self integer , intent ( in ) :: ID real vector ( 3 ) vector = self % BoundFACEs ( ID )% moveVector (:) end function function get_cellCenterOf ( self , ID ) result ( center ) class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self integer , intent ( in ) :: ID real center ( 3 ) center = self % CELLs ( ID )% center end function function get_allOfCellCenters ( self ) result ( centers ) class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self real , allocatable :: centers (:,:) integer i , num_cell num_cell = size ( self % CELLs ) allocate ( centers ( 3 , num_cell )) do i = 1 , num_cell centers (:, i ) = self % CELLs ( i )% center end do end function function get_cellVerticesOf ( self , ID ) result ( vertices ) class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self integer , intent ( in ) :: ID real , allocatable :: vertices (:,:) integer i , num_node , nodeID num_node = size ( self % CELLs ( ID )% nodeID ) allocate ( vertices ( 3 , num_node )) do i = 1 , num_node nodeID = self % CELLs ( ID )% nodeID ( i ) vertices (:, i ) = self % NODEs ( nodeID )% coordinate end do end function function get_gridInformation ( self , name ) result ( info ) class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self character ( * ), intent ( in ) :: name integer info select case ( name ) case ( 'node' ) info = size ( self % NODEs ) case ( 'cell' ) info = size ( self % CELLs ) end select end function end module unstructuredGrid_m","tags":"","loc":"sourcefile/unstructuredgrid.f90.html"},{"title":"dropletMotionSimulation.f90 – Droplets Simulation","text":"This file depends on sourcefile~~dropletmotionsimulation.f90~~EfferentGraph sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~timekeeper.f90 timeKeeper.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~timekeeper.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletequation.f90 sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~virusdroplet.f90 sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~conditionvalue.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~filename_mod.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~terminalcontroler.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~path_operator.f90 sourcefile~dropletgenerator.f90->sourcefile~dropletequation.f90 sourcefile~dropletgenerator.f90->sourcefile~virusdroplet.f90 sourcefile~dropletgenerator.f90->sourcefile~filename_mod.f90 sourcefile~array.f90 array.f90 sourcefile~dropletgenerator.f90->sourcefile~array.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~dropletgenerator.f90->sourcefile~simplefile_reader.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~path_operator.f90 sourcefile~vector.f90 vector.f90 sourcefile~dropletequation.f90->sourcefile~vector.f90 sourcefile~dropletequation.f90->sourcefile~simplefile_reader.f90 sourcefile~conditionvalue.f90->sourcefile~filename_mod.f90 sourcefile~unstructuredgrid.f90->sourcefile~filename_mod.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~dropletmotionsimulation.f90~~AfferentGraph sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dropletMotionSimulation Source Code dropletMotionSimulation.f90 Source Code module dropletMotionSimulation use dropletGenerator_m use dropletEquation_m use flow_field_m use timeKeeper_m implicit none private integer outputInterval integer num_restart integer , target :: timeStep integer n_start , n_end type ( TimeKeeper ) tK character (:), allocatable :: case_dir logical :: startFlag = . false . integer :: last_coalescenceStep = 0 logical generationFlag logical :: adhesionSwitch = . true . integer :: coalescenceLimit = 10000 , num_divide = 4 character (:), allocatable :: radiusDistributionFilename type ( DropletGroup ) mainDroplet type ( DropletEquationSolver ), target :: dropletSolver type ( DropletGenerator ) dropGenerator type ( FlowField ) flow_field public mainDropletLoop , simulationSetUp , output_ResultSummary , read_basicSettingOnSimulation contains subroutine simulationSetUp ( case_name ) use virusDroplet_m use conditionValue_m character ( * ), intent ( in ) :: case_name type ( conditionValue_t ) condVal case_dir = case_name call create_CaseDirectory condVal = read_condition ( case_dir ) num_restart = condVal % restart n_end = condVal % stepEnd outputInterval = condVal % outputInterval print * , 'n_end =' , n_end print * , 'output interval =' , outputInterval dropletSolver = DropletEquationSolver_ ( & condVal % dt , condVal % L , condVal % U , & condVal % direction_g , condVal % T , condVal % RH & ) n_start = max ( num_restart , 0 ) timeStep = n_start dropGenerator = DropletGenerator_ ( & dropletSolver , radiusDistributionFilename , case_dir , & generationRate = condVal % periodicGeneration & ) if ( num_restart <= 0 ) then if ( condVal % isInitialDistributionSpecified ()) then mainDroplet = read_backup ( case_dir // '/' // condVal % initialDistributionFName ) else mainDroplet = dropGenerator % generateDroplet ( condVal % num_drop , TimeOnSimu ()) end if call output_mainDroplet ( initial = . true .) !この時点では、飛沫の参照セルは見つかっていない else print * , '**RESTART**' block character ( 255 ) fname write ( fname , '(\"' // case_dir // '/backup/backup_\", i0, \".bu\")' ) num_restart mainDroplet = read_backup ( trim ( fname )) !ここで自動割り付け end block end if print * , 'num_droplets =' , size ( mainDroplet % droplet ) last_coalescenceStep = 0 call checkpoint if ( condVal % isMeshFileSpecified ()) then flow_field = FlowField_ ( & !流れ場の取得 dropletSolver % TimeStep2RealTime ( step = n_start , dimension = . false .), & condVal % PATH2FlowFile , condVal % DT_FLOW , condVal % OFFSET , condVal % INTERVAL_FLOW , & condVal % LoopHead , condVal % LoopTail , & condVal % meshFile & ) else flow_field = FlowField_ ( & !流れ場の取得 dropletSolver % TimeStep2RealTime ( step = n_start , dimension = . false .), & condVal % PATH2FlowFile , condVal % DT_FLOW , condVal % OFFSET , condVal % INTERVAL_FLOW , & condVal % LoopHead , condVal % LoopTail & ) end if if ( num_restart <= 0 ) call first_refCellSearch ( mainDroplet ) end subroutine subroutine read_basicSettingOnSimulation integer n_unit character ( 23 ) :: fname = 'option/basicSetting.nml' character ( 255 ) radiusDistributionFNAME namelist / basicSetting / coalescenceLimit , adhesionSwitch , num_divide , radiusDistributionFNAME print * , 'READ : ' , fname open ( newunit = n_unit , file = fname , status = 'old' , action = 'read' ) read ( n_unit , nml = basicSetting ) close ( n_unit ) radiusDistributionFilename = trim ( radiusDistributionFNAME ) end subroutine subroutine mainDropletLoop integer , pointer :: n => timeStep print '(\"*******************************************\")' print '(\"            START step_loop                \")' print '(\"*******************************************\")' do n = n_start + 1 , n_end !ステップ数だけループ call dropGenerator % periodicGeneration ( mainDroplet , TimeOnSimu (), generationFlag ) if ( adhesionSwitch ) call adhesion_check ( mainDroplet ) call mainDroplet % survival_check ( TimeOnSimu ()) !生存率に関する処理 call coalescence_process !飛沫間の合体判定 call Calculation_Droplets !飛沫の運動計算 if ( mod ( n , outputInterval ) == 0 ) call periodicOutput ( n ) !出力 call check_FlowFieldUpdate !流れ場の更新チェック end do print '(\"*******************************************\")' print '(\"             END step_loop                 \")' print '(\"*******************************************\")' end subroutine subroutine check_FlowFieldUpdate if ( timeStep == n_end ) return call flow_field % set_time ( TimeOnSimu ()) if ( flow_field % isUpdateTiming ()) then call flow_field % update () !流れ場の更新 call dropletOnBoundary ( mainDroplet ) end if end subroutine subroutine first_refCellSearch ( dGroup ) type ( DropletGroup ) dGroup integer j , num_drop logical success print * , 'first_refCellSearch occured!' num_drop = size ( dGroup % droplet ) j = 1 dGroup % droplet ( j )% refCellID = flow_field % nearest_cell ( real ( dGroup % droplet ( j )% position (:))) dGroup % droplet ( j + 1 :)% refCellID = dGroup % droplet ( j )% refCellID !時間短縮を図る do j = 2 , num_drop call flow_field % search_refCELL ( real ( dGroup % droplet ( j )% position (:)), dGroup % droplet ( j )% refCellID , stat = success ) if (. not . success ) dGroup % droplet ( j + 1 :)% refCellID = dGroup % droplet ( j )% refCellID end do ! call mainMesh%sort() end subroutine subroutine adhesion_check ( dGroup ) use unstructuredGrid_m type ( DropletGroup ) dGroup integer i do i = 1 , size ( dGroup % droplet ) if ( dGroup % droplet ( i )% isFloating ()) then call flow_field % adhesionCheckOnBound ( & dGroup % droplet ( i )% position , dGroup % droplet ( i )% get_radius (), dGroup % droplet ( i )% refCellID , & stat = dGroup % droplet ( i )% adhesBoundID & ) if ( dGroup % droplet ( i )% adhesBoundID >= 1 ) call dGroup % droplet ( i )% stop_droplet () end if end do call area_check ( dGroup ) end subroutine subroutine area_check ( dGroup ) type ( DropletGroup ) dGroup logical check real areaMin ( 3 ), areaMax ( 3 ) integer i , J call flow_field % get_MinMaxOfGrid ( areaMin , areaMax ) do i = 1 , size ( dGroup % droplet ) check = . false . do J = 1 , 3 if ( dGroup % droplet ( i )% position ( J ) < areaMin ( J )) then dGroup % droplet ( i )% position ( J ) = areaMin ( J ) check = . true . else if ( dGroup % droplet ( i )% position ( J ) > areaMax ( J )) then dGroup % droplet ( i )% position ( J ) = areaMax ( J ) check = . true . end if end do if ( check ) call dGroup % droplet ( i )% stop_droplet () end do end subroutine subroutine dropletOnBoundary ( dGroup ) !境界面の移動に合わせて付着飛沫も移動 use unstructuredGrid_m type ( DropletGroup ) dGroup integer vn , JB ! print*, 'CALL:dropletOnBoundary' do vn = 1 , size ( dGroup % droplet ) if ( dGroup % droplet ( vn )% isFloating ()) cycle !付着していないならスルー JB = dGroup % droplet ( vn )% adhesBoundID if ( JB > 0 ) then dGroup % droplet ( vn )% position (:) & = dGroup % droplet ( vn )% position (:) & + flow_field % get_movementVectorOfBoundarySurface ( JB ) !面重心の移動量と同じだけ移動 end if end do ! call area_check(dGroup) ! print*, 'FIN:dropletOnBoundary' end subroutine subroutine Calculation_Droplets () integer vn , targetID !$omp parallel do do vn = 1 , size ( mainDroplet % droplet ) if ( mainDroplet % droplet ( vn )% isFloating ()) then call evaporationProcess ( mainDroplet % droplet ( vn )) !蒸発方程式関連の処理 call motionCalculation ( mainDroplet % droplet ( vn )) !運動方程式関連の処理 else targetID = mainDroplet % droplet ( vn )% coalescenceID () if ( targetID > 0 ) then !合体飛沫の片割れも移動させる mainDroplet % droplet ( vn )% position = mainDroplet % droplet ( targetID )% position mainDroplet % droplet ( vn )% velocity = mainDroplet % droplet ( targetID )% velocity end if end if end do !$omp end parallel do end subroutine subroutine evaporationProcess ( droplet ) !CALCULATE droplet evaporation use virusDroplet_m type ( virusDroplet_t ) droplet double precision dr if (. not . droplet % isEvaporating ()) return !半径が最小になったものを除く dr = dropletSolver % evaporationEq ( droplet % get_radius ()) !半径変化量 call droplet % evaporation ( dr ) end subroutine subroutine motionCalculation ( droplet ) use virusDroplet_m type ( virusDroplet_t ) droplet double precision velAir ( 3 ) velAir (:) = flow_field % get_flowVelocityInCELL ( droplet % refCellID ) call dropletSolver % solve_motionEquation ( droplet % position (:), droplet % velocity (:), velAir (:), droplet % get_radius ()) call flow_field % search_refCELL ( real ( droplet % position (:)), droplet % refCellID ) end subroutine subroutine output_mainDroplet ( initial ) use filename_m , only : IniDistributionFName => InitialDistributionFileName logical , intent ( in ) :: initial character ( 255 ) fname write ( fname , '(\"' // case_dir // '/VTK/drop_\", i0, \".vtk\")' ) timeStep call mainDroplet % output_VTK ( fname , deadline = initial ) fname = case_dir // '/particle.csv' call mainDroplet % output_CSV ( fname , TimeOnSimu ( dimension = . true .), initial ) if ( initial ) then fname = case_dir // '/backup/' // IniDistributionFName else write ( fname , '(\"' // case_dir // '/backup/backup_\", i0, \".bu\")' ) timeStep end if call mainDroplet % output_backup ( trim ( fname )) end subroutine subroutine coalescence_process use terminalControler_m integer numFloating , num_coalescence numFloating = mainDroplet % counter ( 'floating' ) if ( generationFlag ) last_coalescenceStep = timeStep - 1 !飛沫発生が起こったら前ステップに付着が起こったことにする（付着判定再起動のため） !最後の合体から指定ステップが経過したら、以降は合体が起こらないとみなしてリターン if (( timeStep - last_coalescenceStep ) > coalescenceLimit ) return call set_formatTC ( '(\" Coalescence_check [step:\", i10, \"/\", i10, \"]\")' ) call print_progress ([ timeStep , last_coalescenceStep + coalescenceLimit ]) ! call mainDroplet%coalescence_check(stat = num_coalescence) call divideAreaCoalescence_process ( num_coales = num_coalescence ) if ( num_coalescence >= 1 ) last_coalescenceStep = timeStep end subroutine subroutine divideAreaCoalescence_process ( num_coales ) type ( DropletGroup ) dGroup integer , intent ( out ) :: num_coales integer i , j , k , id , m , stat_coales integer , allocatable :: ID_array (:) double precision AreaMin ( 3 ), AreaMax ( 3 ), width ( 3 ), delta ( 3 ), min_cdn ( 3 ), max_cdn ( 3 ) double precision , parameter :: deltaRatio = 1.d-2 num_coales = 0 if ( num_divide <= 0 ) return call mainDroplet % getArea ( AreaMin , AreaMax ) ! AreaMin(:) = AreaMin(:) - 1.d-9 ;print*, 'AreaMin:',AreaMin ! AreaMax(:) = AreaMax(:) + 1.d-9 ;print*, 'AreaMax:',AreaMax width (:) = ( AreaMax (:) - AreaMin (:)) / dble ( num_divide ) !;print*, 'width:',width delta (:) = ( AreaMax (:) - AreaMin (:)) * deltaRatio do k = 1 , num_divide min_cdn ( 3 ) = AreaMin ( 3 ) + width ( 3 ) * dble ( k - 1 ) - delta ( 3 ) max_cdn ( 3 ) = AreaMin ( 3 ) + width ( 3 ) * dble ( k ) + delta ( 3 ) do j = 1 , num_divide min_cdn ( 2 ) = AreaMin ( 2 ) + width ( 2 ) * dble ( j - 1 ) - delta ( 2 ) max_cdn ( 2 ) = AreaMin ( 2 ) + width ( 2 ) * dble ( j ) + delta ( 2 ) do i = 1 , num_divide min_cdn ( 1 ) = AreaMin ( 1 ) + width ( 1 ) * dble ( i - 1 ) - delta ( 1 ) max_cdn ( 1 ) = AreaMin ( 1 ) + width ( 1 ) * dble ( i ) + delta ( 1 ) ID_array = mainDroplet % IDinBox ( min_cdn , max_cdn , status = 0 ) ! print*, 'divide_stat :', size(ID_array), min_cdn, max_cdn dGroup % droplet = mainDroplet % droplet ( ID_array ) !分割エリア内の飛沫を抽出（ここでIDが変わる） call dGroup % coalescence_check ( stat = stat_coales ) !分割エリア内で合体判定 num_coales = num_coales + stat_coales block integer coalesID do m = 1 , size ( ID_array ) id = ID_array ( m ) mainDroplet % droplet ( id ) = dGroup % droplet ( m ) !飛沫情報をもとのIDに格納 coalesID = dGroup % droplet ( m )% coalescenceID () !合体飛沫については、合体先ID（coalesID）ももとのIDに戻す必要がある if ( coalesID > 0 ) mainDroplet % droplet ( id )% coalesID = ID_array ( coalesID ) end do end block end do end do end do end subroutine subroutine checkpoint character ( 1 ) input if (. not . startFlag ) then do print * , 'Do you want to start the calculation? (y/n)' read ( 5 , * ) input select case ( input ) case ( 'y' ) startFlag = . true . exit case ( 'n' ) stop end select end do end if tk = TimeKeeper_ () end subroutine subroutine create_CaseDirectory use path_operator_m call make_directory ( case_dir // '/VTK' ) call make_directory ( case_dir // '/backup' ) end subroutine subroutine periodicOutput ( nowStep ) use terminalControler_m integer , intent ( in ) :: nowStep real nearerSearchFalseRate print * , '[Start Date] ' // tk % startDateAndTime () print '(\" ** It will take\", f8.2, \" minites **\")' , real ( n_end - nowStep ) / ( 6 0. * real ( nowStep ) / tK % erapsedTime ()) print * , 'Now_Step_Time =' , TimeOnSimu ( dimension = . true .), '[sec]' print * , '# floating :' , mainDroplet % Counter ( 'floating' ), '/' , mainDroplet % Counter ( 'total' ) nearerSearchFalseRate = flow_field % get_nearerSearchFalseRate () if ( nearerSearchFalseRate >= 1. ) print * , '# searchFalseRate :' , nearerSearchFalseRate , '%' call output_mainDroplet ( initial = . false .) print '(\"====================================================\")' call reset_formatTC end subroutine subroutine output_ResultSummary () use dropletEquation_m integer n_unit , cnt real erapsed_time character ( 50 ) fname logical existance double precision TimeStart , TimeEnd character (:), allocatable :: startDAT , endDAT erapsed_time = tk % erapsedTime () startDAT = '[Start Date] ' // tk % startDateAndTime () endDAT = '[ END  Date] ' // nowDateAndTime () print * , startDAT print * , endDAT fname = case_dir // '/ResultSummary.txt' inquire ( file = fname , exist = existance ) cnt = 0 do while ( existance ) cnt = cnt + 1 write ( fname , '(\"' // case_dir // '/ResultSummary_\", i0, \".txt\")' ) cnt inquire ( file = fname , exist = existance ) end do TimeStart = dropletSolver % TimeStep2RealTime ( step = n_start , dimension = . true .) TimeEnd = dropletSolver % TimeStep2RealTime ( step = n_end , dimension = . true .) open ( newunit = n_unit , file = fname , status = 'new' ) write ( n_unit , * ) '*******************************************' write ( n_unit , * ) '*                                         *' write ( n_unit , * ) '*             Result Summary              *' write ( n_unit , * ) '*                                         *' write ( n_unit , * ) '*******************************************' write ( n_unit , '(A)' ) '=======================================================' write ( n_unit , * ) startDAT write ( n_unit , * ) endDAT write ( n_unit , '(A18, F15.3, 2X, A)' ) 'Erapsed Time =' , erapsed_time , '[sec]' write ( n_unit , '(A18, F15.3, 2X, A)' ) 'Cost of Calc =' , & erapsed_time / ( TimeEnd - TimeStart ), '[sec/sec]' write ( n_unit , '(A)' ) '=======================================================' write ( n_unit , '(A18, 2(F15.3,2x,A))' ) 'Time [sec] =' , TimeStart , '-' , TimeEnd write ( n_unit , '(A18, 2(I15,2x,A))' ) 'Step =' , n_start , '-' , n_end !計算回数 write ( n_unit , '(A18, I15)' ) 'OutputInterval =' , outputInterval write ( n_unit , '(A)' ) '=======================================================' write ( n_unit , '(A18, I15)' ) '#Droplets =' , mainDroplet % counter ( 'total' ) write ( n_unit , '(A18, I15)' ) 'floating =' , mainDroplet % counter ( 'floating' ) write ( n_unit , '(A18, I15)' ) 'death =' , mainDroplet % counter ( 'death' ) !生存率で消滅 write ( n_unit , '(A18, I15)' ) 'coalescence =' , mainDroplet % counter ( 'coalescence' ) !生存率で消滅 write ( n_unit , '(A18, I15)' ) 'adhesion =' , mainDroplet % counter ( 'adhesion' ) !付着したすべてのウイルス数 write ( n_unit , '(A)' ) '=======================================================' write ( n_unit , '(A18, F18.2)' ) 'Temp [degC] =' , dropletSolver % dropletEnvironment ( 'Temperature' ) write ( n_unit , '(A18, F18.2)' ) 'RH [%] =' , dropletSolver % dropletEnvironment ( 'RelativeHumidity' ) write ( n_unit , '(A18, 2X, A)' ) 'Used FlowFile :' , flow_field % get_defaultFlowFileName () write ( n_unit , '(A18, I15,2x,A, f8.3,2x,A)' ) 'SearchFalseInfo :' , flow_field % get_num_nearerSearchFalse (), & ' (' , flow_field % get_nearerSearchFalseRate (), '%)' close ( n_unit ) end subroutine double precision function TimeOnSimu ( dimension ) logical , intent ( in ), optional :: dimension if ( present ( dimension )) then TimeOnSimu = dropletSolver % TimeStep2RealTime ( timeStep , dimension ) else TimeOnSimu = dropletSolver % TimeStep2RealTime ( timeStep , . false .) end if end function function DateAndTime_string ( date , time ) result ( string ) character ( * ), intent ( in ) :: date , time character (:), allocatable :: string string = date ( 1 : 4 ) // '/' // date ( 5 : 6 ) // '/' // date ( 7 : 8 ) // ' ' & // time ( 1 : 2 ) // ':' // time ( 3 : 4 ) // ':' // time ( 5 : 6 ) end function ! subroutine random_set    !実行時刻に依存した乱数シードを指定する !     implicit none !     integer :: seedsize, i !     integer, allocatable :: seed(:) !     print*, 'call:random_set' !     call random_seed(size=seedsize) !シードのサイズを取得。（コンパイラごとに異なるらしい） !     allocate(seed(seedsize)) !新シード配列サイズの割り当て !     do i = 1, seedsize !         call system_clock(count=seed(i)) !時間を新シード配列に取得 !     end do !     call random_seed(put=seed(:)) !新シードを指定 ! end subroutine random_set end module dropletMotionSimulation","tags":"","loc":"sourcefile/dropletmotionsimulation.f90.html"},{"title":"kdTree.f90 – Droplets Simulation","text":"This file depends on sourcefile~~kdtree.f90~~EfferentGraph sourcefile~kdtree.f90 kdTree.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~kdtree.f90~~AfferentGraph sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~kdtree.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules kdTree_m Source Code kdTree.f90 Source Code !>kd-treeモジュール !>by Shohei Kishi, Hikaru Konishi, Tatsuya Miyoshi, Yuta Ida module kdTree_m use sort_m implicit none private type :: node_in_kdTree_t private integer :: parent_ID = 0 , child_ID_1 = 0 , child_ID_2 = 0 , cell_ID = 0 integer depth integer , allocatable :: cellID_array (:) end type type , public :: kdTree private type ( node_in_kdTree_t ), allocatable :: node (:) contains procedure set_relation , saveAsDOT , saveAsTXT , read_kdTree procedure :: search => search_kdtree end type public kdTree_ contains type ( kdTree ) function kdTree_ ( xyz_origin ) use terminalControler_m real , intent ( in ) :: xyz_origin (:,:) !セル重心座標配列(3, num_cell) type ( content_t ), allocatable :: x_origin (:), y_origin (:), z_origin (:) type ( content_t ), allocatable :: array_pre (:), array_sorted (:) integer , allocatable :: leftChildIDArray (:), rightChildIDArray (:) integer centerID , i , num_node integer parentID , child1ID , child2ID integer depth , ID_counter ID_counter = 1 num_node = size ( xyz_origin , dim = 2 ) allocate ( kdTree_ % node ( num_node )) !各軸に対してコンテンツ配列に x_origin = real2content ( xyz_origin ( 1 ,:)) y_origin = real2content ( xyz_origin ( 2 ,:)) z_origin = real2content ( xyz_origin ( 3 ,:)) kdTree_ % node ( 1 )% cellID_array = x_origin (:)% originID kdTree_ % node ( 1 )% depth = 0 !最初は深さゼロ call set_formatTC ( '(\"CREATING kd-tree [ #node : \",i7,\" / \",i7,\" ]\")' ) do i = 1 , num_node call print_progress ([ i , num_node ]) parentID = i depth = kdTree_ % node ( i )% depth !各軸を切り替えながら、コンテンツ配列から要素を抽出 select case ( mod ( depth , 3 )) case ( 0 ) ! Officeの場合、ここでSegmentation faultになる array_pre = x_origin ( kdTree_ % node ( i )% cellID_array ) case ( 1 ) array_pre = y_origin ( kdTree_ % node ( i )% cellID_array ) case ( 2 ) array_pre = z_origin ( kdTree_ % node ( i )% cellID_array ) end select array_sorted = array_pre !←配列サイズを揃えるため call heap_sort ( array_pre , array_sorted ) ! print '(*(i0, x))', array_sorted(:)%originID ! print '(*(g0, x))', array_sorted(:)%value centerID = int ( size ( array_sorted ) / 2 ) + 1 kdTree_ % node ( i )% cell_ID = array_sorted ( centerID )% originID !ヒープソート結果の中央値 leftChildIDArray = array_sorted (: centerID - 1 )% originID !左側配列のIDだけ取り出す rightChildIDArray = array_sorted ( centerID + 1 :)% originID !右側配列のIDだけ取り出す if ( size ( leftChildIDArray ) >= 1 ) then ID_counter = ID_counter + 1 child1ID = ID_counter kdTree_ % node ( child1ID )% cellID_array = leftChildIDArray call kdTree_ % set_relation ( parentID , child1ID , 'left' ) end if if ( size ( rightChildIDArray ) >= 1 ) then ID_counter = ID_counter + 1 child2ID = ID_counter kdTree_ % node ( child2ID )% cellID_array = rightChildIDArray call kdTree_ % set_relation ( parentID , child2ID , 'right' ) end if end do ! call print_tree(kdTree, xyz_origin) end function subroutine set_relation ( self , parent_ID , child_ID , lr ) class ( kdTree ) self integer , intent ( in ) :: parent_ID , child_ID character ( * ), intent ( in ) :: lr self % node ( child_ID )% parent_ID = parent_ID self % node ( child_ID )% depth = self % node ( parent_ID )% depth + 1 select case ( lr ) case ( 'left' ) self % node ( parent_ID )% child_ID_1 = child_ID case ( 'right' ) self % node ( parent_ID )% child_ID_2 = child_ID case default print '(\"relation ERROR\")' error stop end select end subroutine !>探索サブルーチン subroutine search_kdTree ( self , xyz , droplet_position , nearest_ID ) class ( kdTree ), intent ( in ) :: self real , intent ( in ) :: xyz (:,:) real , intent ( in ) :: droplet_position ( 3 ) integer depth , switch , parentID , nextChildID , i , leftChildID , rightChildID integer , intent ( out ) :: nearest_ID real mindist logical , allocatable :: NotYetCompared (:) integer , allocatable :: cellIDarray (:) parentID = 1 do depth = self % node ( parentID )% depth switch = mod ( depth , 3 ) + 1 if ( droplet_position ( switch ) <= xyz ( switch , self % node ( parentID )% cell_ID )) then nextChildID = self % node ( parentID )% child_ID_1 else nextChildID = self % node ( parentID )% child_ID_2 end if if ( nextChildID == 0 ) then exit else parentID = nextChildID end if end do ! このnearest_IDは最近傍末端ノードのcellID nearest_ID = self % node ( parentID )% cell_ID ! 比較済みか未比較かを判別するlogical配列を用意 ! 最初はすべて比較していないのでtrueで初期化 allocate ( NotYetCompared ( size ( self % node ))) NotYetCompared (:) = . true . mindist = norm2 ( xyz (:, nearest_ID ) - droplet_position (:)) ! 末端ノードとの比較が終わったのでfalse NotYetCompared ( self % node ( parentID )% cell_ID ) = . false . do ! 注目する親ノードIDを更新 parentID = self % node ( parentID )% parent_ID depth = self % node ( parentID )% depth switch = mod ( depth , 3 ) + 1 leftChildID = self % node ( parentID )% child_ID_1 rightChildID = self % node ( parentID )% child_ID_2 ! 右もしくは左の子が存在しない場合の処理。存在しないときの子ノードIDは0となる ! self%node(0)%cell_IDは存在しないので、除外する。 if ( leftChildID == 0 . or . rightChildID == 0 ) then allocate ( cellIDarray ( 1 )) cellIDarray ( 1 ) = self % node ( parentID )% cell_ID else ! 注目している親の左の子をまだ比較していないならtrue if ( NotYetCompared ( self % node ( leftChildID )% cell_ID )) then ! 注目する親とそれに付随する左の子すべてのcellIDを返す allocate ( cellIDarray ( size ( self % node ( leftChildID )% cellID_array ) + 1 )) cellIDarray ( 1 ) = self % node ( parentID )% cell_ID cellIDarray ( 2 :) = self % node ( leftChildID )% cellID_array else ! 注目する親とそれに付随する右の子すべてのcellIDを返す allocate ( cellIDarray ( size ( self % node ( rightChildID )% cellID_array ) + 1 )) cellIDarray ( 1 ) = self % node ( parentID )% cell_ID cellIDarray ( 2 :) = self % node ( rightChildID )% cellID_array end if end if ! (末端ノード-飛沫座標)<=(末端ノードの親の注目(switch)座標-飛沫の注目(switch)座標) if ( mindist <= abs ( xyz ( switch , self % node ( parentID )% cell_ID ) - droplet_position ( switch ))) then ! 注目している親と左or右のすべての子をfalse NotYetCompared ( cellIDarray ) = . false . else do i = 1 , size ( cellIDarray ) ! (注目している親および左or右のすべての子-飛沫座標)を比較 if ( norm2 ( xyz (:, cellIDarray ( i )) - droplet_position (:)) <= mindist ) then mindist = norm2 ( xyz (:, cellIDarray ( i )) - droplet_position (:)) nearest_ID = cellIDarray ( i ) end if NotYetCompared ( cellIDarray ( i )) = . false . end do end if deallocate ( cellIDarray ) if ( parentID == 1 ) then exit end if end do deallocate ( NotYetCompared ) end subroutine subroutine saveAsDOT ( self , xyz , fname ) class ( kdTree ), intent ( in ) :: self real , intent ( in ) :: xyz (:,:) character ( * ), intent ( in ) :: fname integer n_unit integer i character ( 1 ), parameter :: dq = '\"' open ( newunit = n_unit , file = fname ) write ( n_unit , '(\"graph {\")' ) write ( n_unit , '(4x, \"node [\")' ) write ( n_unit , '(2(4x), \"shape = record,\")' ) write ( n_unit , '(4x, \"];\")' ) write ( n_unit , '()' ) ! node define do i = 1 , size ( self % node ) write ( n_unit , '(4x, i0, \"[label = \", A, \"{\", i0, \"| cell ID : \", i0, \"|\", 3(f10.5), \"}\", A, \"];\")' ) & i , dq , i , self % node ( i )% cell_ID , xyz (:, self % node ( i )% cell_ID ), dq end do write ( n_unit , '()' ) ! edge define do i = 1 , size ( self % node ) if ( self % node ( i )% child_ID_1 /= 0 ) then write ( n_unit , '(4x, i0, \" -- \", i0, \";\")' ) i , self % node ( i )% child_ID_1 end if if ( self % node ( i )% child_ID_2 /= 0 ) then write ( n_unit , '(4x, i0, \" -- \", i0, \";\")' ) i , self % node ( i )% child_ID_2 end if end do write ( n_unit , '(\"}\")' ) end subroutine subroutine saveAsTXT ( self , fname ) class ( kdTree ), intent ( in ) :: self character ( * ), intent ( in ) :: fname character ( size ( self % node )) fmt integer i , n_unit , iimx iimx = size ( self % node ) open ( newunit = n_unit , file = fname ) write ( n_unit , '(I0)' ) iimx do i = 1 , iimx write ( n_unit , '(7(1x,I0))' ) i , self % node ( i )% cell_ID , self % node ( i )% parent_ID , & self % node ( i )% child_ID_1 , self % node ( i )% child_ID_2 , self % node ( i )% depth , & size ( self % node ( i )% cellID_array ) end do write ( n_unit , '()' ) do i = 1 , size ( self % node ) write ( fmt , '(\"(\"I0\"(1x,I0))\")' ) size ( self % node ( i )% cellID_array ) write ( n_unit , fmt ) self % node ( i )% cellID_array end do close ( n_unit ) end subroutine subroutine read_kdTree ( self , fname ) class ( kdTree ), intent ( inout ) :: self character ( * ), intent ( in ) :: fname integer i , n_unit , iimx integer , allocatable :: nodeID (:), cellID_arraySize (:) open ( newunit = n_unit , file = fname ) read ( n_unit , * ) iimx allocate ( self % node ( iimx )) allocate ( nodeID ( iimx )) allocate ( cellID_arraySize ( iimx )) do i = 1 , iimx read ( n_unit , * ) nodeID ( i ), self % node ( i )% cell_ID , self % node ( i )% parent_ID , & self % node ( i )% child_ID_1 , self % node ( i )% child_ID_2 , self % node ( i )% depth , & cellID_arraySize ( i ) end do read ( n_unit , '()' ) do i = 1 , iimx allocate ( self % node ( i )% cellID_array ( cellID_arraySize ( i ))) read ( n_unit , * ) self % node ( i )% cellID_array end do close ( n_unit ) ! do i = 1, iimx !     print'(6(1x,I0))', nodeID(i), self%node(i)%cell_ID, self%node(i)%parent_ID, & !     self%node(i)%child_ID_1, self%node(i)%child_ID_2, self%node(i)%depth ! end do ! do i = 1, iimx !     print *, self%node(i)%cellID_array ! end do end subroutine end module","tags":"","loc":"sourcefile/kdtree.f90.html"},{"title":"simpleFile_reader.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~simplefile_reader.f90~~AfferentGraph sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~boxcounter.f90 boxCounter.f90 sourcefile~boxcounter.f90->sourcefile~simplefile_reader.f90 sourcefile~casename.f90 caseName.f90 sourcefile~casename.f90->sourcefile~simplefile_reader.f90 sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~dropletequation.f90->sourcefile~simplefile_reader.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletgenerator.f90->sourcefile~simplefile_reader.f90 sourcefile~dropletgenerator.f90->sourcefile~dropletequation.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~simplefile_reader.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~boxcounter.f90 sourcefile~droplet2csv.f90 droplet2CSV.f90 sourcefile~droplet2csv.f90->sourcefile~dropletequation.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~casename.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~boxcounter.f90 sourcefile~dropletcount.f90->sourcefile~casename.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletequation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules simpleFile_reader Source Code simpleFile_reader.f90 Source Code !>簡単なファイル（CSV、TXTなど）の読込手続き集モジュール module simpleFile_reader implicit none private !>CSV読込手続き interface read_CSV module procedure read_csv_dble , read_csv_int , read_csv_char end interface public read_CSV , read_textRecord contains subroutine read_csv_char ( filename , matrix , column , header ) integer i , Num_unit character ( * ), intent ( in ) :: filename character ( * ), intent ( inout ), allocatable :: matrix (:,:) integer :: mat_size ( 2 ) integer , intent ( in ), optional :: column logical , optional :: header logical :: header_flag = . true . if ( present ( header )) header_flag = header print * , 'CSV_READER:' , filename open ( newunit = Num_unit , file = filename , status = 'old' , action = 'read' ) mat_size = get_size_csv ( Num_unit , header_flag ) if ( present ( column )) mat_size ( 1 ) = column allocate ( matrix ( mat_size ( 1 ), mat_size ( 2 ))) print * , 'Size =' , mat_size (:) if ( header_flag ) read ( Num_unit , '()' ) !ヘッダーの読み飛ばし do i = 1 , mat_size ( 2 ) !本読み込み read ( Num_unit , * ) matrix (:, i ) ! print *, matrix(:,i) end do close ( Num_unit ) end subroutine read_csv_char subroutine read_csv_dble ( filename , matrix , column , header ) integer i , Num_unit character ( * ), intent ( in ) :: filename double precision , intent ( inout ), allocatable :: matrix (:,:) integer :: mat_size ( 2 ) integer , intent ( in ), optional :: column logical , optional :: header logical :: header_flag = . true . if ( present ( header )) header_flag = header print * , 'CSV_READER:' , filename open ( newunit = Num_unit , file = filename , status = 'old' , action = 'read' ) mat_size = get_size_csv ( Num_unit , header_flag ) if ( present ( column )) mat_size ( 1 ) = column allocate ( matrix ( mat_size ( 1 ), mat_size ( 2 ))) print * , 'Size =' , mat_size (:) if ( header_flag ) read ( Num_unit , '()' ) !ヘッダーの読み飛ばし do i = 1 , mat_size ( 2 ) !本読み込み read ( Num_unit , * ) matrix (:, i ) ! print *, matrix(:,i) end do close ( Num_unit ) end subroutine read_csv_dble subroutine read_csv_int ( filename , matrix , column , header ) integer i , Num_unit character ( * ), intent ( in ) :: filename integer , intent ( inout ), allocatable :: matrix (:,:) integer :: mat_size ( 2 ) integer , intent ( in ), optional :: column logical , optional :: header logical :: header_flag = . true . if ( present ( header )) header_flag = header print * , 'CSV_READER:' , filename open ( newunit = Num_unit , file = filename , status = 'old' , action = 'read' ) mat_size = get_size_csv ( Num_unit , header_flag ) if ( present ( column )) mat_size ( 1 ) = column allocate ( matrix ( mat_size ( 1 ), mat_size ( 2 ))) print * , 'Size =' , mat_size (:) if ( header_flag ) read ( Num_unit , '()' ) !ヘッダーの読み飛ばし do i = 1 , mat_size ( 2 ) !本読み込み read ( Num_unit , * ) matrix (:, i ) ! print *, matrix(:,i) end do close ( Num_unit ) end subroutine read_csv_int !>TXTファイルを、全行読み込む。 !>1行あたりの文字数は引数に依存。 subroutine read_textRecord ( filename , array ) character ( * ), intent ( in ) :: filename !!ファイル名（パス） character ( * ), intent ( out ), allocatable :: array (:) !!文字列配列 !!要素数はallocatableだが、1要素あたりの文字数は予め指定 integer i , Num_unit integer :: num_record print * , 'simpleREADER : ' , filename open ( newunit = Num_unit , file = filename , status = 'old' , action = 'read' ) num_record = get_num_records ( Num_unit , header_flag = . false .) allocate ( array ( num_record )) print * , '#Records =' , num_record do i = 1 , num_record read ( Num_unit , '(A)' ) array ( i ) end do close ( Num_unit ) end subroutine function get_size_csv ( Num_unit , header_flag ) result ( mat_size ) integer , intent ( in ) :: Num_unit logical , intent ( in ) :: header_flag integer :: mat_size ( 2 ) character ( 255 ) A mat_size (:) = 0 read ( Num_unit , '(A)' ) A mat_size ( 1 ) = get_num_columns ( A ) mat_size ( 2 ) = get_num_records ( Num_unit , header_flag ) end function get_size_csv integer function get_num_records ( Num_unit , header_flag ) integer , intent ( in ) :: Num_unit logical , intent ( in ) :: header_flag character ( 20 ) A integer ios rewind ( Num_unit ) ! ファイルの最初に戻る get_num_records = 0 if ( header_flag ) read ( Num_unit , '()' ) !ヘッダーの読み飛ばし do !レコード数を調べるループ read ( Num_unit , '(A)' , iostat = ios ) A !ファイル終端であればiosに-1が返る if (( trim ( A ) == '' ). or .( ios /= 0 )) exit !終端もしくは空白行であればループ脱出 get_num_records = get_num_records + 1 end do rewind ( Num_unit ) ! ファイルの最初に戻る end function integer function get_num_columns ( str ) character ( * ), intent ( in ) :: str character ( 1 ) delimiter integer i , j delimiter = ',' if ( index ( str , ',' ) == 0 ) delimiter = ' ' get_num_columns = 1 i = 1 do j = index ( str ( i :), delimiter ) if ( j > 0 ) then if ( j > 1 ) get_num_columns = get_num_columns + 1 i = i + j else exit end if end do end function end module simpleFile_reader","tags":"","loc":"sourcefile/simplefile_reader.f90.html"},{"title":"flow_field.f90 – Droplets Simulation","text":"This file depends on sourcefile~~flow_field.f90~~EfferentGraph sourcefile~flow_field.f90 flow_field.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~flow_field.f90->sourcefile~path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~array.f90 array.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~unstructuredgrid.f90->sourcefile~filename_mod.f90 sourcefile~vector.f90 vector.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~flow_field.f90~~AfferentGraph sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules flow_field_m Source Code flow_field.f90 Source Code module flow_field_m use unstructuredGrid_m implicit none private type , public , extends ( FlowFieldUnstructuredGrid ) :: FlowField private integer INTERVAL !気流データ出力間隔 integer LoopHead , LoopTail , OFFSET double precision DT integer STEP , NextUpdate character (:), allocatable :: FullFileName character (:), allocatable :: FileNameFormat contains private procedure , public :: update => update_FlowField procedure , public :: get_defaultFlowFileName , isUpdateTiming procedure , public :: set_time => set_timeSTEPinFLOW procedure set_FileNameFormat , calc_NextUpdate , get_FileNumber , clamp_STEP procedure :: get_requiredFileName => get_requiredFlowFieldFileName end type public FlowField_ contains type ( FlowField ) function FlowField_ (& time , PATH2FlowFile , DeltaT , OFFSET , outputINTERVAL , LoopHead , LoopTail , meshFile ) double precision , intent ( in ) :: time , DeltaT integer , intent ( in ) :: OFFSET , outputINTERVAL , LoopHead , LoopTail character ( * ), intent ( in ) :: PATH2FlowFile character ( * ), intent ( in ), optional :: meshFile call FlowField_ % set_FileNameFormat ( PATH2FlowFile ) FlowField_ % INTERVAL = outputINTERVAL if ( FlowField_ % INTERVAL <= 0 ) then print * , 'AirFlow is Steady' else print * , 'Interval of AirFlow =' , FlowField_ % INTERVAL FlowField_ % OFFSET = OFFSET print * , 'OFFSET =' , FlowField_ % OFFSET FlowField_ % LoopHead = LoopHead FlowField_ % LoopTail = LoopTail if ( FlowField_ % LoopTail - FlowField_ % LoopHead > 0 ) then print * , 'Loop is from' , FlowField_ % LoopHead , 'to' , FlowField_ % LoopTail elseif ( FlowField_ % LoopTail - FlowField_ % LoopHead == 0 ) then print * , 'After' , FlowField_ % LoopTail , ', Checkout SteadyFlow' end if FlowField_ % DT = DeltaT print * , 'Delta_Time inFLOW =' , FlowField_ % DT call FlowField_ % set_time ( time ) end if if ( present ( meshFile )) then FlowField_ % FlowFieldUnstructuredGrid = FlowFieldUnstructuredGrid_ ( FlowField_ % get_requiredFileName (), meshFile ) else FlowField_ % FlowFieldUnstructuredGrid = FlowFieldUnstructuredGrid_ ( FlowField_ % get_requiredFileName ()) end if call FlowField_ % calc_NextUpdate () end function subroutine set_FileNameFormat ( self , PATH2FlowFile ) use path_operator_m class ( FlowField ) self character ( * ), intent ( in ) :: PATH2FlowFile character (:), allocatable :: PATH2FlowDir , prefix , suffix , FileName integer i_integerPart , i_ , i_dot integer num_digit !ファイル名の整数部桁数 self % FullFileName = PATH2FlowFile call get_DirFromPath ( PATH2FlowFile , PATH2FlowDir , FileName ) i_integerPart = index ( FileName , '0' ) !ひとまず最初のゼロの位置を整数部位置とする i_ = index ( FileName , '_' , back = . true .) !アンダーバーの位置取得 if ( i_ > i_integerPart ) i_integerPart = i_ + 1 !アンダーバーの位置がゼロの位置より後ろの場合、アンダーバー以降を整数部位置とする prefix = FileName (: i_integerPart - 1 ) !ファイル名の接頭部(整数部位置の手前まで) i_dot = index ( FileName , '.' ) !ドットの位置 num_digit = i_dot - i_integerPart !ファイル名の整数部桁数(整数部位置からドットまでの文字数) suffix = FileName ( i_dot : ) block character ( 2 * ( num_digit / 10 + 1 ) + 2 ) digitsFormat if ( suffix == '.fld' ) then digitsFormat = 'i0' else write ( digitsFormat , '(\"i\", i0, \".\", i0)' ) num_digit , num_digit end if self % FileNameFormat = '(\"' // PATH2FlowDir // prefix // '\",' // trim ( digitsFormat ) // ',\"' // suffix // '\")' print * , 'self%FileNameFormat : ' , self % FileNameFormat end block end subroutine function get_requiredFlowFieldFileName ( self ) result ( FileName ) class ( FlowField ) self character (:), allocatable :: FileName if ( self % INTERVAL <= 0 ) then FileName = self % FullFileName else block character ( 255 ) str write ( str , self % FileNameFormat ) self % get_FileNumber () FileName = trim ( str ) end block end if end function subroutine update_FlowField ( self ) class ( FlowField ) self call self % updateWithFlowFieldFile ( self % get_requiredFileName ()) call self % calc_NextUpdate () print * , \"Update_FlowField : FIN\" end subroutine logical function isUpdateTiming ( self ) class ( FlowField ) self if ( self % STEP >= self % NextUpdate . and . self % INTERVAL > 0 ) then isUpdateTiming = . true . else isUpdateTiming = . false . end if end function subroutine set_timeSTEPinFLOW ( self , time ) class ( FlowField ) self DOUBLE PRECISION , intent ( in ) :: time self % STEP = int ( time / self % DT ) + self % OFFSET !気流計算における時刻ステップ数に相当 end subroutine subroutine calc_NextUpdate ( self ) class ( FlowField ) self integer i i = 0 do while ( i * self % INTERVAL + self % OFFSET <= self % STEP ) i = i + 1 end do self % NextUpdate = i * self % INTERVAL + self % OFFSET end subroutine integer function get_FileNumber ( self ) class ( FlowField ) self get_FileNumber = self % OFFSET do while ( get_FileNumber < self % STEP ) get_FileNumber = get_FileNumber + self % INTERVAL end do get_FileNumber = get_FileNumber + self % INTERVAL !前進評価 call self % clamp_STEP ( get_FileNumber ) end function subroutine clamp_STEP ( self , STEP ) class ( FlowField ) self integer , intent ( inout ) :: STEP integer Lamda , Delta if ( STEP >= self % LoopTail ) then Lamda = self % LoopTail - self % LoopHead if ( Lamda > 0 ) then Delta = mod ( STEP - self % LoopHead , Lamda ) STEP = self % LoopHead + Delta else if ( Lamda == 0 ) then STEP = self % LoopTail self % INTERVAL = - 1 print * , '**Checkout SteadyFlow**' end if end if end subroutine clamp_STEP function get_defaultFlowFileName ( self ) result ( fname ) class ( FlowField ) self character (:), allocatable :: fname fname = self % FullFileName end function end module flow_field_m","tags":"","loc":"sourcefile/flow_field.f90.html"},{"title":"adjacency_solver.f90 – Droplets Simulation","text":"This file depends on sourcefile~~adjacency_solver.f90~~EfferentGraph sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~adjacency_solver.f90~~AfferentGraph sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules adjacencySolver_m Source Code adjacency_solver.f90 Source Code MODULE adjacencySolver_m !!セルの隣接関係解決モジュール IMPLICIT NONE private !>ハーフフェイス構造体 type halfFace_t integer :: nodeID ( 4 ) = 0 , pairID = 0 , ID_sum = 0 , ownerID ( 2 ) = - 1 end type halfFace_t !>隣接関係ソルバークラス type AdjacencySolver type ( halfFace_t ), allocatable :: halfFaceArray (:) integer num_BoundFace contains procedure set_halfFaceArray , check_halfFace , find_boundFaceInformation , find_adjacentCellID end type public solve_BoundaryAndAdjacency contains subroutine set_halfFaceArray ( self , cellVertices ) !!各セルごとにハーフフェイスをカウントし、配列に格納 class ( AdjacencySolver ) self integer , intent ( in ) :: cellVertices (:,:) INTEGER II , JJJ , j , n , JJJMX , num_halfFace , num_cell integer , allocatable :: n_type (:) integer , parameter :: num_halfFace_perCELL ( 3 ) = [ 4 , 5 , 5 ] integer , parameter :: IDtrans ( 4 , 5 , 3 ) = reshape ([ & 1 , 2 , 3 , 0 , 2 , 3 , 4 , 0 , 3 , 4 , 1 , 0 , 4 , 1 , 2 , 0 , 0 , 0 , 0 , 0 ,& !テトラ 1 , 2 , 3 , 0 , 4 , 5 , 6 , 0 , 1 , 2 , 4 , 5 , 2 , 3 , 5 , 6 , 3 , 1 , 6 , 4 ,& !プリズム 5 , 1 , 2 , 0 , 5 , 2 , 3 , 0 , 5 , 3 , 4 , 0 , 5 , 4 , 1 , 0 , 1 , 2 , 3 , 4 ], shape ( IDtrans )) !ピラミッド num_cell = size ( cellVertices , dim = 2 ) !cellVerticesには、(6ｘセル数)の配列が入ってきている想定 if ( num_cell <= 0 ) then print * , 'ERROR_num_cells' , num_cell error stop end if allocate ( n_type ( num_cell )) DO II = 1 , num_cell select case ( count ( cellVertices (:, II ) == 0 )) case ( 2 ) !ゼロの数が2個：頂点数が4個：テトラ n_type ( II ) = 1 case ( 0 ) !ゼロの数が0個：頂点数が6個：プリズム n_type ( II ) = 2 case ( 1 ) !ゼロの数が1個：頂点数が5個：ピラミッド n_type ( II ) = 3 case default print * , '**CEll VERTICES ERROR**' error stop end select END DO num_halfFace = count ( n_type == 1 ) * 4 + count ( n_type == 2 ) * 5 + count ( n_type == 3 ) * 5 !半面数：テトラ数×4 (+プリズム数×5 +ピラミッド数×5) allocate ( self % halfFaceArray ( num_halfFace )) JJJ = 0 DO II = 1 , num_cell do j = 1 , num_halfFace_perCELL ( n_type ( II )) JJJ = JJJ + 1 do n = 1 , 3 ! print*, JJJ, n, j, n_type, II self % halfFaceArray ( JJJ )% nodeID ( n ) = cellVertices ( IDtrans ( n , j , n_type ( II )), II ) end do if ( IDtrans ( 4 , j , n_type ( II )) > 0 ) then self % halfFaceArray ( JJJ )% nodeID ( 4 ) = cellVertices ( IDtrans ( 4 , j , n_type ( II )), II ) !四角形面なら4点目を代入 end if self % halfFaceArray ( JJJ )% ownerID ( 1 ) = II self % halfFaceArray ( JJJ )% ID_sum = sum ( self % halfFaceArray ( JJJ )% nodeID (:)) end do END DO JJJMX = JJJ if ( JJJMX == num_halfFace ) then print * , 'JJJMX / num_halfFace =' , JJJMX , '/' , num_halfFace else print * , 'JJJMX_ERROR:' , JJJMX , num_halfFace error stop end if end subroutine subroutine check_halfFace ( self ) !!各ハーフフェイスに対して相方を探す !!相方がみつかれば、相方のセルと隣接していることがわかる !!相方のいないハーフフェイスは境界面 use terminalControler_m class ( AdjacencySolver ) self INTEGER match , width , numNode , faceID , groupID , num_group , maxID_sum , num_halfFace , num_BoundFaces integer checkCounter , faceCounter , i , j , faceID1 , faceID2 , num_face , k , l integer , allocatable :: faceID_array (:) type faceGroup_t integer , allocatable :: faceID (:) end type faceGroup_t type ( faceGroup_t ), allocatable :: faceGroup (:) ! real time1, time2 ! call cpu_time(time1) print * , 'START-FACE CHECK!' !同一面の探索 num_halfFace = size ( self % halfFaceArray ) num_group = num_halfFace / 5000 + 1 !面グループ数（1グループ数に約5000枚面が入るようにする）（この値は経験則） allocate ( faceGroup ( num_group )) allocate ( faceID_array ( num_halfFace ), source = 0 ) maxID_sum = maxval ( self % halfFaceArray (:)% ID_sum ) width = maxID_sum / num_group + 1 !1グループの幅（最大節点番号和を面グループ数で割る） checkCounter = 0 call set_formatTC ( '(\"DIVIDE halfFace [ #group : \",i6,\" / \",i6,\" ]\")' ) do groupID = 1 , num_group !面をグループに分ける call print_progress ([ groupID , num_group ]) faceID_array (:) = 0 faceCounter = 1 do faceID = 1 , num_halfFace if (( self % halfFaceArray ( faceID )% ID_sum > ( groupID - 1 ) * width ) & . and .( self % halfFaceArray ( faceID )% ID_sum <= groupID * width )) then faceID_array ( faceCounter ) = faceID faceCounter = faceCounter + 1 checkCounter = checkCounter + 1 end if end do faceGroup ( groupID )% faceID = faceID_array ( 1 : faceCounter - 1 ) end do if ( checkCounter /= num_halfFace ) then print * , 'faceCounter_ERROR:' , checkCounter , num_halfFace error stop end if num_BoundFaces = 0 call set_formatTC ( '(\"CHECK halfFace [ #group : \",i6,\" / \",i6,\" ]\")' ) !$omp parallel do private(faceID1,faceID2, match, k,l, num_face,numNode) reduction(+:num_BoundFaces) do groupID = 1 , num_group call print_progress ([ groupID , num_group ]) num_face = size ( faceGroup ( groupID )% faceID ) face1 : do i = 1 , num_face faceID1 = faceGroup ( groupID )% faceID ( i ) if ( self % halfFaceArray ( faceID1 )% ownerID ( 2 ) >= 0 ) cycle face1 !面共有セル探索が済んでいる場合スキップ if ( self % halfFaceArray ( faceID1 )% nodeID ( 4 ) <= 0 ) then numNode = 3 !三角形面 else numNode = 4 !四角形面 end if face2 : do j = i + 1 , num_face faceID2 = faceGroup ( groupID )% faceID ( j ) if ( self % halfFaceArray ( faceID2 )% ownerID ( 2 ) >= 0 ) cycle face2 !面共有セル探索が済んでいる場合スキップ if (( numNode == 3 ). and .( self % halfFaceArray ( faceID2 )% nodeID ( 4 ) > 0 )) cycle face2 !三角形面を注目中に四角形面が現れればスキップ match = 0 do k = 1 , numNode do l = 1 , numNode if ( self % halfFaceArray ( faceID1 )% nodeID ( k ) == self % halfFaceArray ( faceID2 )% nodeID ( l )) match = match + 1 !点IDが一致すればカウント end do end do if ( match < numNode ) cycle face2 !節点数と同じ回数一致しなければスキップ（必要十分条件） !ここまでくれば同一の2面発見 self % halfFaceArray ( faceID1 )% ownerID ( 2 ) = self % halfFaceArray ( faceID2 )% ownerID ( 1 ) self % halfFaceArray ( faceID2 )% ownerID ( 2 ) = self % halfFaceArray ( faceID1 )% ownerID ( 1 ) cycle face1 !共有セルが見つかったので次の面へ end do face2 self % halfFaceArray ( faceID1 )% ownerID ( 2 ) = 0 !共有セルが見つからなかった:境界面 num_BoundFaces = num_BoundFaces + 1 !境界面カウント end do face1 end do !$omp end parallel do print * , '# Boundary Face =' , num_BoundFaces self % num_BoundFace = num_BoundFaces print * , 'END-FACE CHECK!' ! call cpu_time(time2) ! print*, time2 - time1 ! error stop END subroutine check_halfFace subroutine find_boundFaceInformation ( self , cellBoundFaces , boundFaceVertices ) !!境界面のみを取り出し、配列に格納 class ( AdjacencySolver ) self INTEGER II , JJJ , JB integer cellBoundFaces (:,:) integer , allocatable :: NoB (:) integer , allocatable , intent ( out ) :: boundFaceVertices (:,:) allocate ( NoB ( size ( cellBoundFaces , dim = 2 )), source = 0 ) allocate ( boundFaceVertices ( 3 , self % num_BoundFace ), source = 0 ) JB = 0 DO JJJ = 1 , size ( self % halfFaceArray ) IF ( self % halfFaceArray ( JJJ )% ownerID ( 2 ) /= 0 ) cycle !境界面以外はスルー JB = JB + 1 II = self % halfFaceArray ( JJJ )% ownerID ( 1 ) !JJが属する要素番号 NoB ( II ) = NoB ( II ) + 1 !IIが所有する境界面数カウント cellBoundFaces ( NoB ( II ), II ) = JB !IIが所有する境界面番号 boundFaceVertices ( 1 : 3 , JB ) = self % halfFaceArray ( JJJ )% nodeID ( 1 : 3 ) END DO end subroutine subroutine find_adjacentCellID ( self , adjacentCellArray ) !!隣接関係を配列に格納 class ( AdjacencySolver ) self integer II , JJJ , adjacentCellArray (:,:) integer , allocatable :: num_adjacent (:) allocate ( num_adjacent ( size ( adjacentCellArray )), source = 0 ) do JJJ = 1 , size ( self % halfFaceArray ) if ( self % halfFaceArray ( JJJ )% ownerID ( 2 ) <= 0 ) cycle !境界面はスルー II = self % halfFaceArray ( JJJ )% ownerID ( 1 ) num_adjacent ( II ) = num_adjacent ( II ) + 1 adjacentCellArray ( num_adjacent ( II ), II ) = self % halfFaceArray ( JJJ )% ownerID ( 2 ) end do end subroutine subroutine solve_BoundaryAndAdjacency ( cellVertices , cellBoundFaces , boundFaceVertices , adjacentCellArray ) !!境界面と隣接関係を、それぞれ配列に格納 integer , intent ( in ) :: cellVertices (:,:) integer cellBoundFaces (:,:), adjacentCellArray (:,:) integer , allocatable , intent ( out ) :: boundFaceVertices (:,:) type ( AdjacencySolver ) AS print * , '~ SolvingAdjacency is Required. ~' call AS % set_halfFaceArray ( cellVertices ) !面情報のセッティング call AS % check_halfFace () !同一面のチェック call AS % find_boundFaceInformation ( cellBoundFaces , boundFaceVertices ) !境界面情報 call AS % find_adjacentCellID ( adjacentCellArray ) !セル隣接情報 end subroutine END MODULE adjacencySolver_m","tags":"","loc":"sourcefile/adjacency_solver.f90.html"},{"title":"conditionValue.f90 – Droplets Simulation","text":"This file depends on sourcefile~~conditionvalue.f90~~EfferentGraph sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~conditionvalue.f90->sourcefile~filename_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~conditionvalue.f90~~AfferentGraph sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~conditionvalue.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~conditionvalue.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~conditionvalue.f90 sourcefile~droplet2csv.f90 droplet2CSV.f90 sourcefile~droplet2csv.f90->sourcefile~conditionvalue.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules conditionValue_m Source Code conditionValue.f90 Source Code module conditionValue_m !!飛沫計算用の諸条件を取り扱う implicit none private !>条件値クラス !>条件指定ファイル（namelist）を読み込んだ結果を格納する type , public :: conditionValue_t !!飛沫計算用の諸条件をまとめた構造体 double precision dt , L , U , direction_g ( 3 ) character (:), allocatable :: initialDistributionFName integer restart , stepEnd , outputInterval , num_drop , periodicGeneration real T , RH character (:), allocatable :: path2FlowFile , meshFile double precision DT_FLOW integer OFFSET , INTERVAL_FLOW , LoopHead , LoopTail contains procedure isInitialDistributionSpecified !!飛沫初期分布ファイルが指定されたか否かを返す procedure isMeshFileSpecified !!メッシュファイルが別途指定されたか否かを返す end type public read_condition contains function read_condition ( dir ) result ( self ) !!条件ファイルを読み込み、結果を構造体で返す。 !!このサブルーチン実装当時、構造体をそのままnamelistにできることを知らず、わざわざ変数ひとつひとつ定義した。 !!現在ここを変えると進行中のプロジェクト（オフィス飛沫計算など）に影響が出るおそれがあり、触れない。 !!いつか修正したい。 use filename_m , only : conditionFName => conditionFileName type ( conditionValue_t ) self character ( * ), intent ( in ) :: dir integer n_unit character ( 4 ), parameter :: None = 'None' double precision delta_t , L_represent , U_represent , direction_g ( 3 ) character ( 255 ) :: initialDistributionFName integer num_restart , n_end , outputInterval , num_droplets real temperature , relativeHumidity integer :: periodicGeneration = 0 character ( 255 ) PATH2FlowFile , meshFile double precision DT_FLOW integer OFFSET , INTERVAL_FLOW , LoopHead , LoopTail namelist / dropletSetting / num_restart , n_end , delta_t , outputInterval , temperature , relativeHumidity ,& num_droplets , direction_g , initialDistributionFName , periodicGeneration namelist / flowFieldSetting / PATH2FlowFile , meshFile , DT_FLOW , OFFSET , INTERVAL_FLOW , LoopHead , LoopTail ,& L_represent , U_represent initialDistributionFName = None !初期化 meshFile = None !初期化 OPEN ( newunit = n_unit , FILE = dir // '/' // conditionFName , status = 'old' , action = 'read' ) read ( n_unit , nml = dropletSetting ) read ( n_unit , nml = flowFieldSetting ) CLOSE ( n_unit ) self % dt = delta_t self % L = L_represent self % U = U_represent self % direction_g (:) = direction_g (:) if ( initialDistributionFName /= None ) self % initialDistributionFName = trim ( initialDistributionFName ) self % restart = num_restart self % stepEnd = n_end self % outputInterval = outputInterval self % num_drop = num_droplets self % T = temperature self % RH = relativeHumidity self % periodicGeneration = periodicGeneration self % PATH2FlowFile = trim ( PATH2FlowFile ) if ( meshFile /= None ) self % meshFile = trim ( meshFile ) self % DT_FLOW = DT_FLOW self % OFFSET = OFFSET self % INTERVAL_FLOW = INTERVAL_FLOW self % LoopHead = LoopHead self % LoopTail = LoopTail end function logical function isInitialDistributionSpecified ( self ) class ( conditionValue_t ), intent ( in ) :: self isInitialDistributionSpecified = allocated ( self % initialDistributionFName ) end function logical function isMeshFileSpecified ( self ) class ( conditionValue_t ), intent ( in ) :: self isMeshFileSpecified = allocated ( self % meshFile ) end function end module conditionValue_m","tags":"","loc":"sourcefile/conditionvalue.f90.html"},{"title":"caseName.f90 – Droplets Simulation","text":"This file depends on sourcefile~~casename.f90~~EfferentGraph sourcefile~casename.f90 caseName.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~casename.f90->sourcefile~simplefile_reader.f90 sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~casename.f90->sourcefile~filename_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~casename.f90~~AfferentGraph sourcefile~casename.f90 caseName.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~casename.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~casename.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules caseName_m Source Code caseName.f90 Source Code module caseName_m implicit none contains subroutine case_check ( caseName_array ) !!case名をキーボードから取得する。 !!TXTファイルを指定すると、それを全行読み込んで配列に格納。 use simpleFile_reader use filename_m , only : conditionFName => conditionFileName character ( * ), allocatable , intent ( out ) :: caseName_array (:) character ( 255 ) caseName integer i logical existance print * , 'Case Name ?' read ( 5 , '(A)' ) caseName if ( index ( caseName , '.txt' ) > 0 ) then call read_textRecord ( trim ( caseName ), caseName_array ) else caseName_array = [ caseName ] end if do i = 1 , size ( caseName_array ) inquire ( file = trim ( caseName_array ( i )) // '/' // conditionFName , exist = existance ) if (. not . existance ) then print * , 'Case:[ ' , trim ( caseName_array ( i )), ' ] is not found.' error stop end if end do end subroutine end module caseName_m","tags":"","loc":"sourcefile/casename.f90.html"},{"title":"filename_mod.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~filename_mod.f90~~AfferentGraph sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~conditionvalue.f90->sourcefile~filename_mod.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~filename_mod.f90 sourcefile~casename.f90 caseName.f90 sourcefile~casename.f90->sourcefile~filename_mod.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletgenerator.f90->sourcefile~filename_mod.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~filename_mod.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~conditionvalue.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~conditionvalue.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~conditionvalue.f90 sourcefile~dropletcount.f90->sourcefile~casename.f90 sourcefile~droplet2csv.f90 droplet2CSV.f90 sourcefile~droplet2csv.f90->sourcefile~conditionvalue.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~casename.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules filename_m Source Code filename_mod.f90 Source Code module filename_m character ( 13 ), parameter :: adjacencyFileName = 'adjacency.txt' character ( 12 ), parameter :: boundaryFileName = 'boundary.txt' character ( 21 ), parameter :: conditionFileName = 'condition.nml' character ( 20 ), parameter :: InitialPositionFileName = 'initial_position.csv' character ( 22 ), parameter :: InitialDistributionFileName = 'InitialDistribution.bu' character ( 20 ), parameter :: kdTreeFName = 'kdTree.txt' end module filename_m","tags":"","loc":"sourcefile/filename_mod.f90.html"},{"title":"vtkMesh_operator.f90 – Droplets Simulation","text":"This file depends on sourcefile~~vtkmesh_operator.f90~~EfferentGraph sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~vtkmesh_operator.f90~~AfferentGraph sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~vtkmesh_operator.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~vtkmesh_operator.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~vtkmesh_operator.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules VTK_operator_m Source Code vtkMesh_operator.f90 Source Code module VTK_operator_m use unstructuredElement_m implicit none private type , extends ( cell_t ) :: cell_inVTK_t integer , private :: n_TYPE end type type , public :: UnstructuredGrid_inVTK type ( node_t ), allocatable :: node_array (:) type ( cell_inVTK_t ), allocatable :: cell_array (:) contains procedure :: read => read_UnstructuredGrid_inVTK procedure :: output => output_UnstructuredGrid_inVTK procedure get_numCell , get_numNode , get_nodeCoordinate , get_cellVertices procedure set_nodeCoordinate , set_cellVertices end type public UnstructuredGrid_inVTK_ contains type ( UnstructuredGrid_inVTK ) function UnstructuredGrid_inVTK_ ( cdn , vertices , types ) real , intent ( in ) :: cdn (:,:) integer , intent ( in ) :: vertices (:,:), types (:) call UnstructuredGrid_inVTK_ % set_nodeCoordinate ( cdn ) call UnstructuredGrid_inVTK_ % set_cellVertices ( vertices , types ) end function subroutine read_UnstructuredGrid_inVTK ( self , FNAME , action , cellScalar , cellVector ) class ( UnstructuredGrid_inVTK ) self character ( * ), intent ( in ) :: FNAME character ( * ), intent ( in ), optional :: action real , allocatable , intent ( out ), optional :: cellScalar (:), cellVector (:,:) integer II , KK , num_node , n_unit , KKMX , IIMX , ios integer l , nodeID ( 8 ) character AAA * 7 , str * 99 logical dataOnly dataOnly = . false . if ( present ( action )) then if ( action == 'dataOnly' ) dataOnly = . true . end if print * , 'READ_VTK:' , FNAME open ( newunit = n_unit , FILE = FNAME , status = 'old' , action = 'read' ) if ( dataOnly ) then do while ( index ( AAA , 'CELL_DATA' ) == 0 ) read ( n_unit , '(A)' ) AAA end do else read ( n_unit , '()' ) read ( n_unit , '()' ) read ( n_unit , '()' ) read ( n_unit , '()' ) read ( n_unit , * ) AAA , KKMX allocate ( self % node_array ( KKMX )) DO KK = 1 , KKMX read ( n_unit , * ) self % node_array ( KK )% coordinate (:) END DO read ( n_unit , '()' ) read ( n_unit , * ) AAA , IIMX allocate ( self % cell_array ( IIMX )) DO II = 1 , IIMX read ( n_unit , '(A)' ) str !一旦1行丸ごと読む read ( str , * ) num_node read ( str , * ) num_node , ( nodeID ( l ), l = 1 , num_node ) self % cell_array ( II )% nodeID = nodeID (: num_node ) + 1 END DO read ( n_unit , '()' ) read ( n_unit , '()' ) !CELL_TYPES DO II = 1 , IIMX read ( n_unit , * ) self % cell_array ( II )% n_TYPE END DO if ((. not . present ( cellScalar )) . and . (. not . present ( cellVector ))) return read ( n_unit , '()' ) read ( n_unit , '()' ) !CELL_DATA end if do read ( n_unit , '(A)' , iostat = ios ) AAA if ( ios /= 0 ) exit select case ( AAA ) case ( 'SCALARS' ) read ( n_unit , '()' ) if ( present ( cellScalar )) then allocate ( cellScalar ( IIMX )) DO II = 1 , IIMX read ( n_unit , * ) cellScalar ( II ) END DO else DO II = 1 , IIMX read ( n_unit , '()' ) END DO end if case ( 'VECTORS' ) if ( present ( cellVector )) then allocate ( cellVector ( 3 , IIMX )) DO II = 1 , IIMX read ( n_unit , * ) cellVector (:, II ) END DO end if exit end select end do close ( n_unit ) end subroutine subroutine output_UnstructuredGrid_inVTK ( self , FNAME , cellScalar , cellVector , scalarName , vectorName ) class ( UnstructuredGrid_inVTK ) self character ( * ), intent ( in ) :: FNAME real , intent ( in ), optional :: cellScalar (:), cellVector (:,:) character ( * ), intent ( in ), optional :: scalarName , vectorName integer II , KK , n_unit , KKMX , IIMX , IITOTAL integer , allocatable :: nodeID (:) print * , 'OUTPUT_VTK:' , FNAME open ( newunit = n_unit , FILE = FNAME , STATUS = 'replace' ) write ( n_unit , '(A)' ) '# vtk DataFile Version 2.0' write ( n_unit , '(A)' ) 'Header' write ( n_unit , '(A)' ) 'ASCII' write ( n_unit , '(A)' ) 'DATASET UNSTRUCTURED_GRID' KKMX = size ( self % node_array ) write ( n_unit , '(A,1x,I0,1x,A)' ) 'POINTS' , KKMX , 'float' DO KK = 1 , KKMX write ( n_unit , '(3(e12.5,2X))' ) self % node_array ( KK )% coordinate (:) END DO write ( n_unit , '()' ) IIMX = size ( self % cell_array ) IITOTAL = 0 do II = 1 , IIMX IITOTAL = IITOTAL + size ( self % cell_array ( II )% nodeID ) + 1 end do write ( n_unit , '(A,I0,2X,I0)' ) 'CELLS ' , IIMX , IITOTAL DO II = 1 , IIMX nodeID = self % cell_array ( II )% nodeID (:) - 1 write ( n_unit , '(*(g0:,\",\"))' ) size ( nodeID ), nodeID (:) END DO write ( n_unit , '()' ) write ( n_unit , '(A,I0)' ) 'CELL_TYPES ' , IIMX DO II = 1 , IIMX write ( n_unit , '(I0)' ) self % cell_array ( II )% n_TYPE END DO if ( present ( cellScalar ) . or . present ( cellVector )) then write ( n_unit , '()' ) write ( n_unit , '(A,I0)' ) 'CELL_DATA ' , IIMX if ( present ( cellScalar )) then if ( present ( scalarName )) then write ( n_unit , '(A)' ) 'SCALARS ' // scalarName // ' float' else write ( n_unit , '(A)' ) 'SCALARS scalar float' end if write ( n_unit , '(A)' ) 'LOOKUP_TABLE default' DO II = 1 , IIMX write ( n_unit , '(e12.5)' ) cellScalar ( II ) END DO end if if ( present ( cellVector )) then if ( present ( vectorName )) then write ( n_unit , '(A)' ) 'VECTORS ' // vectorName // ' float' else write ( n_unit , '(A)' ) 'VECTORS vector float' end if DO II = 1 , IIMX write ( n_unit , '(3(e12.5,2X))' ) cellVector (:, II ) END DO end if end if close ( n_unit ) end subroutine integer function get_numNode ( self ) class ( UnstructuredGrid_inVTK ), intent ( in ) :: self get_numNode = size ( self % node_array ) end function integer function get_numCell ( self ) class ( UnstructuredGrid_inVTK ), intent ( in ) :: self get_numCell = size ( self % cell_array ) end function function get_nodeCoordinate ( self ) result ( cdn ) class ( UnstructuredGrid_inVTK ), intent ( in ) :: self real , allocatable :: cdn (:,:) integer k , num_node num_node = size ( self % node_array ) allocate ( cdn ( 3 , num_node )) do k = 1 , num_node cdn (:, k ) = self % node_array ( k )% coordinate (:) end do end function subroutine get_cellVertices ( self , vertices , types ) class ( UnstructuredGrid_inVTK ), intent ( in ) :: self integer , allocatable , intent ( out ) :: vertices (:,:), types (:) integer i , num_cell , num_node num_cell = size ( self % cell_array ) allocate ( vertices ( 6 , num_cell )) allocate ( types ( num_cell )) do i = 1 , num_cell num_node = size ( self % cell_array ( i )% nodeID ) vertices ( 1 : num_node , i ) = self % cell_array ( i )% nodeID (:) types ( i ) = self % cell_array ( i )% n_TYPE end do end subroutine subroutine set_nodeCoordinate ( self , cdn ) class ( UnstructuredGrid_inVTK ) self real , intent ( in ) :: cdn (:,:) integer k , num_node num_node = size ( cdn , dim = 2 ) allocate ( self % node_array ( num_node )) do k = 1 , num_node self % node_array ( k )% coordinate (:) = cdn (:, k ) end do end subroutine subroutine set_cellVertices ( self , vertices , types ) class ( UnstructuredGrid_inVTK ) self integer , intent ( in ) :: vertices (:,:), types (:) integer i , num_cell , num_node num_cell = size ( vertices , dim = 2 ) allocate ( self % cell_array ( num_cell )) do i = 1 , num_cell select case ( types ( i )) case ( 10 ) !tetra num_node = 4 case ( 11 ) !hexa num_node = 8 case ( 13 ) !prism num_node = 6 case ( 14 ) !pyramid num_node = 5 end select self % cell_array ( i )% nodeID = vertices ( 1 : num_node , i ) self % cell_array ( i )% n_TYPE = types ( i ) end do end subroutine end module VTK_operator_m","tags":"","loc":"sourcefile/vtkmesh_operator.f90.html"},{"title":"vector.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~vector.f90~~AfferentGraph sourcefile~vector.f90 vector.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~dropletequation.f90->sourcefile~vector.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~geometry.f90->sourcefile~vector.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90->sourcefile~geometry.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletequation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletgenerator.f90->sourcefile~dropletequation.f90 sourcefile~droplet2csv.f90 droplet2CSV.f90 sourcefile~droplet2csv.f90->sourcefile~dropletequation.f90 sourcefile~geometry_test.f90 geometry_test.f90 sourcefile~geometry_test.f90->sourcefile~geometry.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules vector_m Source Code vector.f90 Source Code module vector_m implicit none interface cross_product module procedure cross_product_dble , cross_product_real end interface interface normalize_vector module procedure normalize_vector_dble , normalize_vector_real end interface contains function cross_product_dble ( a , b ) result ( cross ) double precision , intent ( in ) :: a ( 3 ), b ( 3 ) double precision cross ( 3 ) cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function function cross_product_real ( a , b ) result ( cross ) real , intent ( in ) :: a ( 3 ), b ( 3 ) real cross ( 3 ) cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function function normalize_vector_dble ( a ) result ( normalized ) double precision , intent ( in ) :: a ( 3 ) double precision norm , normalized ( 3 ) norm = norm2 ( a ) normalized (:) = a (:) / norm end function function normalize_vector_real ( a ) result ( normalized ) real , intent ( in ) :: a ( 3 ) real norm , normalized ( 3 ) norm = norm2 ( a ) normalized (:) = a (:) / norm end function end module vector_m","tags":"","loc":"sourcefile/vector.f90.html"},{"title":"geometry.f90 – Droplets Simulation","text":"This file depends on sourcefile~~geometry.f90~~EfferentGraph sourcefile~geometry.f90 geometry.f90 sourcefile~vector.f90 vector.f90 sourcefile~geometry.f90->sourcefile~vector.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~geometry.f90~~AfferentGraph sourcefile~geometry.f90 geometry.f90 sourcefile~geometry_test.f90 geometry_test.f90 sourcefile~geometry_test.f90->sourcefile~geometry.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~geometry.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules geometry_m Source Code geometry.f90 Source Code module geometry_m use vector_m implicit none private real , parameter :: delta = 1.e-6 real , parameter :: frac_1_6 = 1. / 6. public volume_tetra , insideJudgment_tetra , insideJudgment_tetra_check contains !>テトラの体積計算。 function volume_tetra ( vertices ) result ( volume ) real , intent ( in ) :: vertices ( 3 , 4 ) real volume real , dimension ( 3 ) :: a , b , c a = vertices (:, 2 ) - vertices (:, 1 ) b = vertices (:, 3 ) - vertices (:, 1 ) c = vertices (:, 4 ) - vertices (:, 1 ) volume = frac_1_6 * abs ( dot_product ( cross_product ( a , b ), c )) end function !>任意の点がテトラの内部にあるかどうかを判定する。 !>点でテトラを分割したそれぞれの体積の和が、元々のテトラの体積を上回れば、点はテトラ外部にある。 !>https://matcha-choco010.net/2018/03/14/point-in-tetrahedron/ function insideJudgment_tetra ( vertices , point ) result ( isInside ) real , intent ( in ) :: vertices ( 3 , 4 ), point ( 3 ) real volume , vol_sum logical isInside volume = volume_tetra ( vertices ) vol_sum = partitionedVolume_sum_tetra ( vertices , point ) !点がテトラの内部にあるとき、分割体積和と元々の体積は厳密に一致するはずだが、 !数値誤差のために少し条件を緩和する isInside = ( vol_sum <= volume * ( 1. + delta )) end function !>点でテトラを分割したそれぞれの体積の和を求める function partitionedVolume_sum_tetra ( vertices , point ) result ( vol_sum ) real , intent ( in ) :: vertices ( 3 , 4 ), point ( 3 ) real vol_sum , mini_vertices ( 3 , 4 ) integer i vol_sum = 0. do i = 1 , 4 mini_vertices = vertices mini_vertices (:, i ) = point vol_sum = vol_sum + volume_tetra ( mini_vertices ) end do end function subroutine insideJudgment_tetra_check ( vertices , point , vol_sum , volume ) real , intent ( in ) :: vertices ( 3 , 4 ), point ( 3 ) real , intent ( out ) :: volume , vol_sum volume = volume_tetra ( vertices ) vol_sum = partitionedVolume_sum_tetra ( vertices , point ) end subroutine end module geometry_m","tags":"","loc":"sourcefile/geometry.f90.html"},{"title":"boxCounter.f90 – Droplets Simulation","text":"This file depends on sourcefile~~boxcounter.f90~~EfferentGraph sourcefile~boxcounter.f90 boxCounter.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~boxcounter.f90->sourcefile~simplefile_reader.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~boxcounter.f90~~AfferentGraph sourcefile~boxcounter.f90 boxCounter.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~boxcounter.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~boxcounter.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules boxCounter_m Source Code boxCounter.f90 Source Code module boxCounter_m implicit none type boxCounter real center ( 3 ), width ( 3 ), min_cdn ( 3 ), max_cdn ( 3 ) logical , allocatable :: Flag (:) contains procedure add_Flag procedure get_FlagID end type contains function get_box_array ( dir , num_Flag ) result ( new_box_array ) use simpleFile_reader type ( boxCounter ), allocatable :: new_box_array (:) character ( * ), intent ( in ) :: dir integer , intent ( in ) :: num_Flag double precision , allocatable :: boxSize_mat (:,:) integer i , num_box call read_CSV ( filename = dir // '/boxList.csv' , matrix = boxSize_mat , header = . true .) num_box = size ( boxSize_mat , dim = 2 ) allocate ( new_box_array ( num_box )) do i = 1 , num_box new_box_array ( i )% center (:) = real ( boxSize_mat ( 1 : 3 , i )) new_box_array ( i )% width (:) = real ( boxSize_mat ( 4 : 6 , i )) new_box_array ( i )% min_cdn (:) = new_box_array ( i )% center (:) - new_box_array ( i )% width (:) * 0.5 new_box_array ( i )% max_cdn (:) = new_box_array ( i )% center (:) + new_box_array ( i )% width (:) * 0.5 if (( new_box_array ( i )% width ( 1 ) <= 0.d0 )& . or .( new_box_array ( i )% width ( 2 ) <= 0.d0 ). or .( new_box_array ( i )% width ( 3 ) <= 0.d0 )) then print * , 'ERROR boxSize :' , new_box_array ( i )% center (:), new_box_array ( i )% width (:) error stop end if allocate ( new_box_array ( i )% Flag ( num_Flag ), source = . false .) end do end function subroutine add_Flag ( self , id_array ) class ( boxCounter ) self integer , intent ( in ) :: id_array (:) self % Flag ( id_array ) = . true . end subroutine function get_FlagID ( self ) result ( id_array ) class ( boxCounter ) self integer , allocatable :: id_array (:) integer i , cnt , n_size n_size = count ( self % Flag ) allocate ( id_array ( n_size )) cnt = 0 do i = 1 , size ( self % Flag ) if ( self % Flag ( i )) then cnt = cnt + 1 id_array ( cnt ) = i end if end do end function end module boxCounter_m","tags":"","loc":"sourcefile/boxcounter.f90.html"},{"title":"dropletGenerator.f90 – Droplets Simulation","text":"This file depends on sourcefile~~dropletgenerator.f90~~EfferentGraph sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~dropletgenerator.f90->sourcefile~virusdroplet.f90 sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~dropletgenerator.f90->sourcefile~filename_mod.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~dropletgenerator.f90->sourcefile~simplefile_reader.f90 sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~dropletgenerator.f90->sourcefile~dropletequation.f90 sourcefile~array.f90 array.f90 sourcefile~dropletgenerator.f90->sourcefile~array.f90 sourcefile~dropletequation.f90->sourcefile~simplefile_reader.f90 sourcefile~vector.f90 vector.f90 sourcefile~dropletequation.f90->sourcefile~vector.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~dropletgenerator.f90~~AfferentGraph sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dropletGenerator_m Source Code dropletGenerator.f90 Source Code module dropletGenerator_m use virusDroplet_m use dropletEquation_m implicit none private type placementBox double precision center ( 3 ), width ( 3 ) end type type SequentialArray private integer index real , allocatable :: array (:) contains procedure set_SequentialArray procedure :: get_value => get_valueFromSequentialArray procedure :: get_valueArray => get_valueArrayFromSequentialArray end type type , public :: DropletGenerator private type ( DropletEquationSolver ), pointer :: equation type ( placementBox ), allocatable :: pBox_array (:) ! double precision, allocatable :: radiusThreshold(:,:) type ( SequentialArray ) initialRadiusArray , deadlineArray integer :: generateRate = 0 contains procedure , public :: generateDroplet procedure , public :: periodicGeneration => dropletPeriodicGeneration procedure set_dropletPlacementBox procedure calc_initialPosition end type ! public BasicParameter, DropletEquationSolver, BasicParameter_, DropletEquationSolver_ public DropletGroup , DropletGenerator_ contains type ( DropletGenerator ) function DropletGenerator_ ( & equation , radiusDistributionFile , positionDir , generationRate ) !コンストラクタ type ( DropletEquationSolver ), target :: equation character ( * ), intent ( in ) :: radiusDistributionFile character ( * ), intent ( in ) :: positionDir integer , intent ( in ) :: generationRate DropletGenerator_ % equation => equation call DropletGenerator_ % initialRadiusArray % set_SequentialArray ( 'data/' // radiusDistributionFile ) call DropletGenerator_ % deadlineArray % set_SequentialArray ( 'data/deadline.txt' ) call DropletGenerator_ % set_dropletPlacementBox ( positionDir ) DropletGenerator_ % generateRate = generationRate end function type ( DropletGroup ) function generateDroplet ( self , num_droplet , nowTime ) class ( DropletGenerator ) self integer , intent ( in ) :: num_droplet double precision , intent ( in ) :: nowTime double precision , allocatable :: initialRadius (:), deadline (:) if ( num_droplet <= 0 ) return allocate ( generateDroplet % droplet ( num_droplet )) call self % calc_initialPosition ( generateDroplet ) initialRadius = self % initialRadiusArray % get_valueArray ( num_droplet ) * 1.d-6 !マイクロメートル換算 initialRadius = initialRadius / self % equation % repValue ( 'length' ) !無次元化 call generateDroplet % set_initialRadius ( initialRadius ) call generateDroplet % set_radiusLowerLimit ( self % equation % get_radiusLowerLimitRatio ()) deadline = self % deadlineArray % get_valueArray ( num_droplet ) / self % equation % repValue ( 'time' ) !無次元化 deadline = deadline + nowTime call generateDroplet % set_deadline ( deadline ) if ( self % generateRate > 0 ) call generateDroplet % set_status ( 'nonActive' ) end function subroutine calc_initialPosition ( self , dGroup ) class ( DropletGenerator ), intent ( in ) :: self type ( DropletGroup ) dGroup integer kx , ky , kz , num_perEdge , num_perBox , k , k_end , cnt integer i_box , num_box , num_drop double precision :: standard ( 3 ), delta ( 3 ), width ( 3 ) !, randble(3) if (. not . allocated ( self % pBox_array )) then print * , 'ERROR : InitialPositionBox is not Set.' error stop end if num_box = size ( self % pBox_array ) num_drop = size ( dGroup % droplet ) num_perBox = num_drop / num_box ! print*, 'calc_initialPosition' num_perEdge = 1 do while ( num_box * (( num_perEdge + 1 ) ** 3 ) < num_drop ) num_perEdge = num_perEdge + 1 !配置帯一辺当たりの飛沫数 end do k = 1 cnt = 1 box : do i_box = 1 , num_box k_end = i_box * num_perBox if ( i_box == num_box ) k_end = num_drop width (:) = self % pBox_array ( i_box )% width (:) standard (:) = self % pBox_array ( i_box )% center (:) - 0.5d0 * self % pBox_array ( i_box )% width (:) if ( num_perEdge >= 2 ) then delta (:) = width (:) / dble ( num_perEdge - 1 ) do kx = 1 , num_perEdge do ky = 1 , num_perEdge do kz = 1 , num_perEdge dGroup % droplet ( k )% position ( 1 ) = standard ( 1 ) + delta ( 1 ) * dble ( kx - 1 ) dGroup % droplet ( k )% position ( 2 ) = standard ( 2 ) + delta ( 2 ) * dble ( ky - 1 ) dGroup % droplet ( k )% position ( 3 ) = standard ( 3 ) + delta ( 3 ) * dble ( kz - 1 ) k = k + 1 end do end do end do end if if ( k <= k_end ) then block integer d , d_max integer :: direction ( 3 , 6 ) = reshape ([ 1 , 0 , 0 , - 1 , 0 , 0 , 0 , 1 , 0 , 0 , - 1 , 0 , 0 , 0 , 1 , 0 , 0 , - 1 ], shape ( direction )) width (:) = 0.d0 d_max = 1 placement : do ! call random_number(randble(:)) ! dGroup%droplet(k)%position(:) = standard(:) + width(:)*randble(:) do d = 1 , d_max dGroup % droplet ( k )% position (:) = self % pBox_array ( i_box )% center (:) + width (:) * dble ( direction (:, d )) k = k + 1 if ( k > k_end ) exit placement end do width (:) = ( width (:) + 0.5d0 * self % pBox_array ( i_box )% width (:)) * 0.5d0 d_max = 6 end do placement end block end if ! print*, 'BOX', i_box, 'has', k - cnt, 'droplets.' cnt = k end do box end subroutine subroutine set_dropletPlacementBox ( self , positionDir ) use simpleFile_reader use filename_m , only : IniPositionFName => InitialPositionFileName class ( DropletGenerator ) self character ( * ), intent ( in ) :: positionDir integer i_box , num_box double precision , allocatable :: position_mat (:,:) character (:), allocatable :: fname logical existance fname = positionDir // '/' // IniPositionFName inquire ( file = fname , exist = existance ) if (. not . existance ) then print * , '**Warning** ' // fname // ' is not found!' return end if call read_CSV ( fname , position_mat ) num_box = size ( position_mat , dim = 2 ) allocate ( self % pBox_array ( num_box )) do i_box = 1 , num_box self % pBox_array ( i_box )% center (:) = position_mat ( 1 : 3 , i_box ) self % pBox_array ( i_box )% width (:) = position_mat ( 4 : 6 , i_box ) end do end subroutine subroutine dropletPeriodicGeneration ( self , dGroup , nowTime , stat ) class ( DropletGenerator ) self type ( DropletGroup ) dGroup double precision , intent ( in ) :: nowTime integer num_generated , required_generation , num_nowGenerate logical , intent ( out ) :: stat stat = . false . if ( self % generateRate == 0 ) return required_generation = int ( dble ( self % generateRate ) * nowTime * self % equation % repValue ( 'time' )) !このステップ終了までに生成されているべき数 num_generated = dGroup % counter ( 'total' ) - dGroup % counter ( 'nonActive' ) !今までに生成された数 if ( num_generated == size ( dGroup % droplet )) return !生成され尽くした場合リターン num_nowGenerate = required_generation - num_generated !今このステップで生成されるべき数 ! print*, num_generated, required_generation, num_nowGenerate block integer generateEnd , nonActive_perBox , i_box , num_box , generate_perBox integer , allocatable :: nonActiveID_array (:) num_box = size ( self % pBox_array ) if ( num_nowGenerate >= num_box ) then nonActiveID_array = dGroup % IDinState ( 'nonActive' ) if ( required_generation < size ( dGroup % droplet )) then nonActive_perBox = size ( nonActiveID_array ) / num_box generate_perBox = num_nowGenerate / num_box do i_box = 1 , num_box generateEnd = min ( nonActive_perBox * ( i_box - 1 ) + generate_perBox , nonActive_perBox * i_box ) call dGroup % set_status ( 'floating' , nonActiveID_array ( nonActive_perBox * ( i_box - 1 ) + 1 : generateEnd )) end do else !この時刻までに生成されているべき数が総飛沫数未満でない　＝＞　全て生成されるべき call dGroup % set_status ( 'floating' , nonActiveID_array (:)) end if stat = . true . end if end block ! print*, TimeOnSimu(), num_generated end subroutine subroutine set_SequentialArray ( self , filename ) use array_m class ( SequentialArray ) self character ( * ), intent ( in ) :: filename call read_1dArray_real ( filename , self % array ) self % index = 1 end subroutine real function get_valueFromSequentialArray ( self ) class ( SequentialArray ) self get_valueFromSequentialArray = self % array ( self % index ) self % index = self % index + 1 if ( self % index > size ( self % array )) self % index = 1 end function function get_valueArrayFromSequentialArray ( self , arraySize ) result ( array ) class ( SequentialArray ) self integer , intent ( in ) :: arraySize real , allocatable :: array (:) integer i allocate ( array ( arraySize )) do i = 1 , arraySize array ( i ) = self % get_value () end do end function subroutine check_category ( array , categories , frequency ) real , intent ( in ) :: array (:) real category_array ( size ( array )) integer frequency_array ( size ( array )) integer i , i_ctgry , num_category logical hit real , allocatable , intent ( out ) :: categories (:) integer , allocatable , intent ( out ) :: frequency (:) category_array = - 1.e20 category_array ( 1 ) = array ( 1 ) frequency_array ( 1 ) = 1 num_category = 1 do i = 2 , size ( array ) hit = . false . do i_ctgry = 1 , num_category if ( array ( i ) == category_array ( i_ctgry )) then frequency_array ( i_ctgry ) = frequency_array ( i_ctgry ) + 1 hit = . true . exit end if end do if (. not . hit ) then num_category = num_category + 1 category_array ( num_category ) = array ( i ) frequency_array ( num_category ) = 1 end if end do categories = category_array (: num_category ) frequency = frequency_array (: num_category ) end subroutine end module dropletGenerator_m","tags":"","loc":"sourcefile/dropletgenerator.f90.html"},{"title":"virusDroplet.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~virusdroplet.f90~~AfferentGraph sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletgenerator.f90->sourcefile~virusdroplet.f90 sourcefile~initial_translate.f90 initial_translate.f90 sourcefile~initial_translate.f90->sourcefile~virusdroplet.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~virusdroplet.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~virusdroplet.f90 sourcefile~droplet2csv.f90 droplet2CSV.f90 sourcefile~droplet2csv.f90->sourcefile~virusdroplet.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules virusDroplet_m Source Code virusDroplet.f90 Source Code module virusDroplet_m implicit none private type , public :: virusDroplet_t double precision :: position ( 3 ), velocity ( 3 ) = 0.d0 double precision , private :: radius , radius_min , initialRadius , deadline integer , private :: status = 0 integer :: coalesID = 0 , refCellID = 0 , adhesBoundID = 0 contains procedure :: isFloating => isDropletFloating procedure :: coalescenceID => dropletCoalescneceID procedure stop_droplet , isEvaporating , evaporation , get_radius end type type , public :: DropletGroup type ( virusDroplet_t ), allocatable :: droplet (:) integer , allocatable :: statusCSV (:) contains procedure output_backup procedure :: output_VTK => output_droplet_VTK procedure :: output_CSV => output_droplet_CSV procedure :: counter => dropletCounter procedure :: IDinBox => dropletIDinBox procedure :: inBox => dropletInBox procedure :: totalVolume => dropletTotalVolume procedure :: IDinState => dropletIDinState procedure :: getArea => get_dropletGroupArea procedure set_initialRadius , set_radiusLowerLimit procedure :: set_status => set_dropletGroupStatus procedure :: set_deadline => set_virusDeadline procedure survival_check procedure coalescence_check ! procedure :: calculation => Calculation_Droplets ! procedure :: append => append_dropletGroup end type public read_backup contains logical function isDropletFloating ( self ) class ( virusDroplet_t ), intent ( in ) :: self if ( self % status == 0 ) then isDropletFloating = . true . else isDropletFloating = . false . end if end function double precision function get_radius ( self ) class ( virusDroplet_t ), intent ( in ) :: self get_radius = self % radius end function logical function isEvaporating ( self ) class ( virusDroplet_t ), intent ( in ) :: self if ( self % radius > self % radius_min ) then isEvaporating = . true . else isEvaporating = . false . end if end function subroutine evaporation ( self , dr ) class ( virusDroplet_t ) self double precision , intent ( in ) :: dr self % radius = max ( self % radius + dr , self % radius_min ) end subroutine integer function dropletCoalescneceID ( self ) class ( virusDroplet_t ), intent ( in ) :: self dropletCoalescneceID = self % coalesID end function integer function get_statusNumber ( name ) character ( * ), intent ( in ) :: name select case ( name ) case ( 'floating' ) get_statusNumber = 0 case ( 'adhesion' ) get_statusNumber = 1 case ( 'death' ) get_statusNumber = - 1 case ( 'coalescence' ) get_statusNumber = - 2 case ( 'nonActive' ) get_statusNumber = - 99 case default print * , '**ERROR [statusNumber] : ' , name , ' is not found.**' error stop end select end function subroutine survival_check ( self , time ) ! use terminalControler_m class ( DropletGroup ) self double precision , intent ( in ) :: time integer vfloat , vn ! double precision rand ! double precision, save :: death_rate = 0.d0 vfloat = count ( self % droplet (:)% status == 0 ) if ( vfloat == 0 ) return !浮遊数がゼロならリターン do vn = 1 , size ( self % droplet ) if (( self % droplet ( vn )% status == 0 ). and .& ( time > self % droplet ( vn )% deadline )) then call self % droplet ( vn )% stop_droplet ( status =- 1 ) end if end do ! death_rate = death_rate + dble(vfloat)*(survival_rate(timeStep) - survival_rate(timeStep+1))    !このステップで死滅すべき飛沫数 ! do while(death_rate >= 1.0d0) !     call random_number(rand)    !死滅IDは乱数で決まる !     vn = int(num_droplets*rand) !     if(vn < 1) cycle !     if (self%droplet(vn)%status == 0) then !浮遊粒子からのみ除去する !         self%droplet(vn)%status = -1 !         ! self%droplet(vn)%position(:) = MIN_CDN(:) - 1.0d0 !計算エリア外に配置（不要かも） !         self%droplet(vn)%velocity(:) = 0.0d0 !         death_rate = death_rate - 1.0d0 !     end if ! end do end subroutine integer function dropletCounter ( self , name ) class ( DropletGroup ) self character ( * ), intent ( in ) :: name select case ( name ) case ( 'total' ) dropletCounter = size ( self % droplet ) case default dropletCounter = count ( self % droplet (:)% status == get_statusNumber ( name )) end select end function function dropletIDinBox ( self , min_cdn , max_cdn , status ) result ( ID_array ) class ( DropletGroup ) self double precision , intent ( in ) :: min_cdn ( 3 ), max_cdn ( 3 ) integer , intent ( in ), optional :: status double precision position ( 3 ) integer , allocatable :: ID_array (:) integer i , id_array_ ( size ( self % droplet )), cnt cnt = 0 if ( present ( status )) then do i = 1 , size ( self % droplet ) if ( self % droplet ( i )% status /= status ) cycle position (:) = self % droplet ( i )% position (:) if ( (( min_cdn ( 1 ) <= position ( 1 )) . and . ( position ( 1 ) <= max_cdn ( 1 ))) & . and .(( min_cdn ( 2 ) <= position ( 2 )) . and . ( position ( 2 ) <= max_cdn ( 2 ))) & . and .(( min_cdn ( 3 ) <= position ( 3 )) . and . ( position ( 3 ) <= max_cdn ( 3 ))) ) then cnt = cnt + 1 id_array_ ( cnt ) = i end if end do else do i = 1 , size ( self % droplet ) position (:) = self % droplet ( i )% position (:) if ( (( min_cdn ( 1 ) <= position ( 1 )) . and . ( position ( 1 ) <= max_cdn ( 1 ))) & . and .(( min_cdn ( 2 ) <= position ( 2 )) . and . ( position ( 2 ) <= max_cdn ( 2 ))) & . and .(( min_cdn ( 3 ) <= position ( 3 )) . and . ( position ( 3 ) <= max_cdn ( 3 ))) ) then cnt = cnt + 1 id_array_ ( cnt ) = i end if end do end if ID_array = id_array_ (: cnt ) end function type ( DropletGroup ) function dropletInBox ( self , min_cdn , max_cdn ) class ( DropletGroup ) self double precision , intent ( in ) :: min_cdn ( 3 ), max_cdn ( 3 ) integer , allocatable :: IDinBox (:) IDinBox = self % IDinBox ( min_cdn , max_cdn ) dropletInBox % droplet = self % droplet ( IDinBox ) end function double precision function dropletTotalVolume ( self ) class ( DropletGroup ) self integer i double precision , parameter :: PI = acos ( - 1.d0 ) dropletTotalVolume = 0.d0 do i = 1 , size ( self % droplet ) dropletTotalVolume = dropletTotalVolume + self % droplet ( i )% initialRadius ** 3 end do dropletTotalVolume = dropletTotalVolume * 4.d0 / 3.d0 * PI end function function dropletIDinState ( self , status ) result ( ID_array ) class ( DropletGroup ) self character ( * ), intent ( in ) :: status integer , allocatable :: ID_array (:) integer i , cnt , statusNumber cnt = 0 statusNumber = get_statusNumber ( status ) allocate ( ID_array ( count ( self % droplet (:)% status == statusNumber ))) do i = 1 , size ( self % droplet ) if ( self % droplet ( i )% status == statusNumber ) then cnt = cnt + 1 ID_array ( cnt ) = i end if end do end function subroutine get_dropletGroupArea ( self , AreaMin , AreaMax ) class ( DropletGroup ) self double precision , intent ( out ) :: AreaMin ( 3 ), AreaMax ( 3 ) integer i , m AreaMin (:) = 1.d9 AreaMax (:) = - 1.d9 do m = 1 , size ( self % droplet ) if ( self % droplet ( m )% status == 0 ) then do i = 1 , 3 AreaMin ( i ) = min ( self % droplet ( m )% position ( i ), AreaMin ( i )) AreaMax ( i ) = max ( self % droplet ( m )% position ( i ), AreaMax ( i )) end do end if end do end subroutine subroutine coalescence_check ( self , stat ) class ( DropletGroup ) self integer , intent ( out ), optional :: stat integer d1 , d2 , num_droplets , num_coales double precision :: distance , r1 , r2 num_coales = 0 num_droplets = size ( self % droplet ) !$OMP parallel do private(distance, r1, r2) drop1 : do d1 = 1 , num_droplets - 1 if ( self % droplet ( d1 )% status /= 0 ) cycle drop1 r1 = self % droplet ( d1 )% radius drop2 : do d2 = d1 + 1 , num_droplets if ( self % droplet ( d2 )% status /= 0 ) cycle drop2 r2 = self % droplet ( d2 )% radius distance = norm2 ( self % droplet ( d2 )% position (:) - self % droplet ( d1 )% position (:)) if (( r1 + r2 ) >= distance ) then ! print*, d1, 'and', d2, 'coalesce!' if ( r1 >= r2 ) then call coalescence ( self % droplet ( d1 ), self % droplet ( d2 ), d1 ) else call coalescence ( self % droplet ( d2 ), self % droplet ( d1 ), d2 ) end if num_coales = num_coales + 1 end if end do drop2 end do drop1 !$OMP end parallel do if ( present ( stat )) stat = num_coales end subroutine coalescence_check subroutine coalescence ( droplet1 , droplet2 , baseID ) type ( virusDroplet_t ), intent ( inout ) :: droplet1 , droplet2 integer , intent ( in ) :: baseID double precision r3_1 , r3_2 , position_c ( 3 ), velocity_c ( 3 ) r3_1 = droplet1 % radius ** 3 r3_2 = droplet2 % radius ** 3 position_c (:) = ( r3_1 * droplet1 % position (:) + r3_2 * droplet2 % position (:)) / ( r3_1 + r3_2 ) velocity_c (:) = ( r3_1 * droplet1 % velocity (:) + r3_2 * droplet2 % velocity (:)) / ( r3_1 + r3_2 ) droplet1 % radius = ( r3_1 + r3_2 ) ** ( 1.d0 / 3.d0 ) droplet1 % position (:) = position_c (:) droplet1 % velocity (:) = velocity_c (:) droplet1 % radius_min = ( droplet1 % radius_min ** 3 + droplet2 % radius_min ** 3 ) ** ( 1.d0 / 3.d0 ) ! droplet1%initialRadius = radius_afterCoalescence(droplet1%initialRadius, droplet2%initialRadius) droplet2 % radius = 0.d0 droplet2 % position (:) = position_c (:) droplet2 % velocity (:) = velocity_c (:) droplet2 % status = - 2 droplet2 % coalesID = baseID end subroutine coalescence subroutine output_backup ( self , fname ) class ( DropletGroup ) self character ( * ), intent ( in ) :: fname integer i , n_unit , num_drop num_drop = size ( self % droplet (:)) open ( newunit = n_unit , form = 'unformatted' , file = fname , status = 'replace' ) write ( n_unit ) num_drop do i = 1 , num_drop write ( n_unit ) self % droplet ( i ) end do close ( n_unit ) print * , 'writeOUT:' , trim ( fname ) end subroutine subroutine output_droplet_VTK ( self , fname , deadline ) class ( DropletGroup ) self character ( * ), intent ( in ) :: fname logical , optional :: deadline integer vn , n_unit , num_drop num_drop = size ( self % droplet ) open ( newunit = n_unit , file = fname , status = 'replace' ) !ここで出力ファイルを指定 write ( n_unit , '(A)' ) '# vtk DataFile Version 2.0' !ファイルの始め4行は文字列（決まり文句） write ( n_unit , '(A)' ) 'FOR TEST' write ( n_unit , '(A)' ) 'ASCII' write ( n_unit , '(A)' ) 'DATASET UNSTRUCTURED_GRID' write ( n_unit , '(A,I0,A)' ) 'POINTS ' , num_drop , ' float' !節点の数 DO vn = 1 , num_drop !節点の数だけループ write ( n_unit , '(3(f10.5,2X))' ) self % droplet ( vn )% position (:) !節点の座標（左から順にx,y,z） END DO write ( n_unit , '()' ) !改行 write ( n_unit , '(A,I0,2X,I0)' ) 'CELLS ' , num_drop , num_drop * 2 !セルの数、セルの数×2 DO vn = 1 , num_drop !セルの数だけループ write ( n_unit , '(I0,2X,I0)' ) 1 , vn - 1 !セルを構成する点の数（セル形状が点なので1）、その点のID END DO write ( n_unit , '()' ) !改行 write ( n_unit , '(A,I0)' ) 'CELL_TYPES ' , num_drop DO vn = 1 , num_drop !セルの数だけループ write ( n_unit , '(I0)' ) 1 !セルの形状（1は点であることを意味する） END DO write ( n_unit , '()' ) !改行 write ( n_unit , '(A,I0)' ) 'CELL_DATA ' , num_drop !ここからセルのデータという合図、セルの数 write ( n_unit , '(A)' ) 'SCALARS Status int' !飛沫の状態(0:浮遊、1:付着、2:回収) write ( n_unit , '(A)' ) 'LOOKUP_TABLE default' DO vn = 1 , num_drop !セルの数だけループ write ( n_unit , '(I0)' ) self % droplet ( vn )% status !飛沫の状態(0:浮遊、1:付着、2:回収) END DO write ( n_unit , '(A)' ) 'SCALARS Diameter float' !飛沫の直径 write ( n_unit , '(A)' ) 'LOOKUP_TABLE default' DO vn = 1 , num_drop !セルの数だけループ write ( n_unit , '(e10.3)' ) self % droplet ( vn )% radius * 2.0d0 !飛沫の直径 END DO if ( present ( deadline )) then if ( deadline ) then write ( n_unit , '(A)' ) 'SCALARS Deadline float' write ( n_unit , '(A)' ) 'LOOKUP_TABLE default' DO vn = 1 , num_drop !セルの数だけループ write ( n_unit , '(e10.3)' ) self % droplet ( vn )% deadline END DO end if end if write ( n_unit , '(A)' ) 'VECTORS Velocity float' !最後に飛沫の速度 DO vn = 1 , num_drop !セルの数だけループ write ( n_unit , '(3(f10.5,2X))' ) self % droplet ( vn )% velocity (:) !飛沫の速度 END DO close ( n_unit ) print * , 'writeOUT:' , trim ( fname ) end subroutine output_droplet_VTK subroutine output_droplet_CSV ( self , fname , time , initial ) class ( DropletGroup ) self character ( * ), intent ( in ) :: fname double precision , intent ( in ) :: time logical , intent ( in ) :: initial integer n_unit , J if ( initial ) then !初回ならファイル新規作成 open ( newunit = n_unit , file = fname , status = 'replace' ) else open ( newunit = n_unit , file = fname , action = 'write' , status = 'old' , position = 'append' ) end if if (. not . allocated ( self % statusCSV )) self % statusCSV = [ 0 , 1 , - 1 , - 2 ] write ( n_unit , '(*(g0:,\",\"))' ) real ( time ), ( count ( self % droplet (:)% status == self % statusCSV ( J )), J = 1 , size ( self % statusCSV )) close ( n_unit ) end subroutine ! subroutine append_dropletGroup(self, dGroup) !     class(DropletGroup) self !     type(DropletGroup), intent(in) :: dGroup !     self%droplet = [self%droplet, dGroup%droplet] ! end subroutine function read_backup ( fname ) result ( dGroup_read ) character ( * ), intent ( in ) :: fname type ( DropletGroup ) dGroup_read integer i , n_unit , num_drop print * , 'READ : ' , trim ( fname ) open ( newunit = n_unit , form = 'unformatted' , file = fname , status = 'old' , action = 'read' ) read ( n_unit ) num_drop allocate ( dGroup_read % droplet ( num_drop )) do i = 1 , num_drop read ( n_unit ) dGroup_read % droplet ( i ) end do close ( n_unit ) end function function read_droplet_VTK ( fname ) result ( dGroup_read ) implicit none character ( * ), intent ( in ) :: fname type ( DropletGroup ) dGroup_read double precision , allocatable :: diameter (:) integer vn , n_unit , num_drop character ( 10 ) str print * , 'READ : ' , fname open ( newunit = n_unit , file = fname , status = 'old' , action = 'read' ) read ( n_unit , '()' ) read ( n_unit , '()' ) read ( n_unit , '()' ) read ( n_unit , '()' ) read ( n_unit , * ) str , num_drop allocate ( dGroup_read % droplet ( num_drop ), diameter ( num_drop )) DO vn = 1 , num_drop read ( n_unit , * ) dGroup_read % droplet ( vn )% position (:) END DO read ( n_unit , '()' ) read ( n_unit , '()' ) DO vn = 1 , num_drop read ( n_unit , '()' ) END DO read ( n_unit , '()' ) read ( n_unit , '()' ) DO vn = 1 , num_drop read ( n_unit , '()' ) END DO read ( n_unit , '()' ) read ( n_unit , '()' ) !CELL_DATA read ( n_unit , '()' ) read ( n_unit , '()' ) DO vn = 1 , num_drop read ( n_unit , * ) dGroup_read % droplet ( vn )% status END DO read ( n_unit , '()' ) read ( n_unit , '()' ) DO vn = 1 , num_drop read ( n_unit , * ) diameter ( vn ) END DO read ( n_unit , '()' ) read ( n_unit , '()' ) DO vn = 1 , num_drop read ( n_unit , * ) dGroup_read % droplet ( vn )% deadline END DO read ( n_unit , '()' ) DO vn = 1 , num_drop read ( n_unit , * ) dGroup_read % droplet ( vn )% velocity (:) END DO close ( n_unit ) dGroup_read % droplet (:)% radius = diameter (:) * 0.5d0 end function subroutine stop_droplet ( self , status ) class ( virusDroplet_t ) self integer , optional :: status self % velocity (:) = 0.0d0 if ( present ( status )) then self % status = status else self % status = 1 end if end subroutine subroutine set_initialRadius ( self , radius ) class ( DropletGroup ) self double precision , intent ( in ) :: radius (:) self % droplet (:)% initialRadius = radius (:) self % droplet (:)% radius = self % droplet (:)% initialRadius end subroutine subroutine set_radiusLowerLimit ( self , lowerLimitRatio ) class ( DropletGroup ) self double precision , intent ( in ) :: lowerLimitRatio self % droplet (:)% radius_min = self % droplet (:)% initialRadius * lowerLimitRatio end subroutine subroutine set_virusDeadline ( self , deadline ) class ( DropletGroup ) self double precision , intent ( in ) :: deadline (:) self % droplet (:)% deadline = deadline (:) end subroutine subroutine set_dropletGroupStatus ( self , status , ID ) class ( DropletGroup ) self character ( * ), intent ( in ) :: status integer , intent ( in ), optional :: ID (:) if ( present ( ID )) then self % droplet ( ID )% status = get_statusNumber ( status ) else self % droplet (:)% status = get_statusNumber ( status ) end if end subroutine end module virusDroplet_m","tags":"","loc":"sourcefile/virusdroplet.f90.html"},{"title":"sort.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~sort.f90~~AfferentGraph sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~sort_test.f90 sort_test.f90 sourcefile~sort_test.f90->sourcefile~sort.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~kdtree.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules sort_m Source Code sort.f90 Source Code module sort_m implicit none private !>コンテンツ構造体 !>実数とIDをメンバに持つ type , public :: content_t integer originID real value end type !>ヒープ木クラス !>実体は単なる配列だがツリー構造を表現している !>要素 i に注目すると、親ノードは要素 i/2(小数切り捨て) であり、子ノードは要素 2i, 2i + 1 である type HeapTree type ( content_t ), allocatable :: node (:) integer switch contains procedure totalHeaplification !, partialHeaplification procedure get_featuredChildID , rebuild_tree end type public heap_sort public real2content contains !>ヒープ木のコンストラクタ type ( HeapTree ) function HeapTree_ ( array ) type ( content_t ), intent ( in ) :: array (:) HeapTree_ % node = array call HeapTree_ % totalHeaplification () end function !>全体ヒープ化（親子の大小関係解決）メソッド subroutine totalHeaplification ( self ) class ( HeapTree ) self integer num_node integer parentID , child1ID , child2ID , featuredChildID num_node = size ( self % node ) do parentID = num_node / 2 , 1 , - 1 !子を持つノードに対してのみ下（葉の方）からループ child1ID = parentID * 2 child2ID = parentID * 2 + 1 featuredChildID = self % get_featuredChildID ( child1ID , child2ID ) if ( self % node ( parentID )% value > self % node ( featuredChildID )% value ) call swap_content ( self % node , parentID , featuredChildID ) end do end subroutine !入れ替えの起こった部分だけヒープ化（親子の大小関係解決）メソッド !こっちのほうが速いと思うが、現在バグってます ! subroutine partialHeaplification(self) !     class(HeapTree) self !     integer parentID, child1ID, child2ID, featuredChildID !     integer num_node !     num_node = size(self%node) !     parentID = 1 !     do !         child1ID = parentID*2 !         if(child1ID > num_node) exit    !第一子すら存在しなければループ終了 !         child2ID = parentID*2 + 1 !         featuredChildID = self%get_featuredChildID(child1ID, child2ID) !         if(self%node(parentID)%value > self%node(featuredChildID)%value) then !             call swap_content(self%node, parentID, featuredChildID) !             parentID = featuredChildID !         else !             exit    !入れ替えが起こらなければループ終了 !         end if !     end do ! end subroutine !>根ノードを除去し、ノード配列を左詰めにする。 subroutine rebuild_tree ( self ) class ( HeapTree ) self self % node = self % node ( 2 :) end subroutine subroutine swap_content ( array , ID1 , ID2 ) integer , intent ( in ) :: ID1 , ID2 type ( content_t ), intent ( inout ) :: array (:) type ( content_t ) temp !一時的に格納する変数 temp = array ( ID1 ) array ( ID1 ) = array ( ID2 ) array ( ID2 ) = temp end subroutine function get_featuredChildID ( self , child1ID , child2ID ) result ( featuredChildID ) class ( HeapTree ) self integer , intent ( in ) :: child1ID , child2ID integer featuredChildID if ( child2ID <= size ( self % node )) then !第2子が存在する（配列サイズ内）場合 if ( self % node ( child1ID )% value < self % node ( child2ID )% value ) then featuredChildID = child1ID else featuredChildID = child2ID end if !self%node(:)%valueの臨時配列生成に時間がかかってたぽい ! featuredChildID = get_smallerID(self%node(:)%value, child1ID, child2ID) else !第2子が存在しない（配列サイズ外）場合 featuredChildID = child1ID end if end function ! function get_smallerID(array, ID1, ID2) result(smaller_ID) !     real,intent(in) :: array(:) !     integer, intent(in) :: ID1, ID2 !     integer smaller_ID !     if (array(ID1) < array(ID2)) then !         smaller_ID = ID1 !     else !         smaller_ID = ID2 !     end if ! end function !>ヒープソート subroutine heap_sort ( array_origin , array_sorted ) type ( content_t ), intent ( in ) :: array_origin (:) type ( content_t ), intent ( out ) :: array_sorted (:) type ( HeapTree ) heap_tree integer i integer arraySize arraySize = size ( array_origin ) if ( size ( array_sorted ) /= arraySize ) then print '(\"SORT ERROR\")' error stop end if heap_tree = HeapTree_ ( array_origin ) do i = 1 , arraySize !ソート後の配列に格納するループ array_sorted ( i ) = heap_tree % node ( 1 ) call heap_tree % rebuild_tree () call heap_tree % totalHeaplification () ! call heap_tree%partialHeaplification() end do end subroutine !>実数型配列をコンテンツ配列に変換する function real2content ( real_array ) result ( content_array ) real , intent ( in ) :: real_array (:) type ( content_t ), allocatable :: content_array (:) integer i allocate ( content_array ( size ( real_array ))) do i = 1 , size ( real_array ) content_array ( i )% originID = i content_array ( i )% value = real_array ( i ) end do end function end module sort_m","tags":"","loc":"sourcefile/sort.f90.html"},{"title":"plot3d_operator.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~plot3d_operator.f90~~AfferentGraph sourcefile~plot3d_operator.f90 plot3d_operator.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~plot3d_operator.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules plot3d_operator Source Code plot3d_operator.f90 Source Code !>CUBE出力ファイル形式：Plot3Dを取り扱うためのモジュール module plot3d_operator implicit none private !>エリア構造体 type area_t real , dimension ( 3 ) :: min , max !最小座標と最大座標 end type !>cube（Plot3D形式における立方体）構造体 type cube_inP3D real , allocatable :: nodes (:,:,:,:) !!節点座標配列（i,j,k, xyz） real , allocatable :: f (:,:,:,:) !!保存量配列（i,j,k, f） type ( area_t ) area contains procedure , public :: isIncluded procedure areaOfCube , nearest_nodeID !, nearer_nodeID end type !>節点情報構造体 type , public :: plot3dNodeInfo integer cubeID , nodeID ( 3 ) !節点が属するcubeID、そのcube内の節点ID（i,j,kそれぞれのIDを指定するので要素数3） end type !>Plot3Dメッシュクラス type , public :: Plot3dMesh private type ( cube_inP3D ), allocatable :: cubes (:) !!cube配列 contains procedure areaOfMesh procedure , public :: read_plot3d_function , get_numCube , get_velocity , get_cubeShape procedure , public :: get_cubeID_contains , nearestNodeInfo end type public :: read_plot3d_multigrid !Plot3Dメッシュクラスの事実上コンストラクタ contains !>メッシュファイル（.g）を読み込んでメッシュクラスを返す関数 function read_plot3d_multigrid ( fName ) result ( mesh ) character ( * ), intent ( in ) :: fName type ( Plot3dMesh ) mesh integer n_unit , i , j , k , i_cube , num_cube , xyz integer , allocatable :: ni (:), nj (:), nk (:) print * , 'READ_multigrid:' , fName open ( newunit = n_unit , form = 'unformatted' , file = fName , status = 'old' , action = 'read' ) read ( n_unit ) num_cube ; print * , 'num_cube=' , num_cube allocate ( mesh % cubes ( num_cube )) allocate ( ni ( num_cube ), nj ( num_cube ), nk ( num_cube )) read ( n_unit ) ( ni ( i_cube ), nj ( i_cube ), nk ( i_cube ), i_cube = 1 , num_cube ) print * , 'ni=' , minval ( ni (:)), maxval ( ni (:)) print * , 'nj=' , minval ( nj (:)), maxval ( ni (:)) print * , 'nk=' , minval ( nk (:)), maxval ( ni (:)) do i_cube = 1 , num_cube allocate ( mesh % cubes ( i_cube )% nodes ( ni ( i_cube ), nj ( i_cube ), nk ( i_cube ), 3 )) end do do i_cube = 1 , num_cube read ( n_unit ) (((( mesh % cubes ( i_cube )% nodes ( i , j , k , xyz ), & i = 1 , ni ( i_cube ) ), j = 1 , nj ( i_cube ) ), k = 1 , nk ( i_cube ) ), xyz = 1 , 3 ) ! (((iblank(i,j,k,i_cube), i = 1, ni(i_cube) ), j = 1, nj(i_cube) ), k = 1, nk(i_cube) ) mesh % cubes ( i_cube )% area = mesh % cubes ( i_cube )% areaOfCube () end do close ( n_unit ) block type ( area_t ) area area = mesh % areaOfMesh () print * , 'min_cdn =' , area % min print * , 'max_cdn =' , area % max end block end function !>メッシュのエリアを構造体で返す関数 type ( area_t ) function areaOfMesh ( self ) class ( Plot3dMesh ), intent ( in ) :: self integer i_cube , num_cube num_cube = size ( self % cubes ) areaOfMesh % min (:) = 1.e9 areaOfMesh % max (:) = - 1.e9 do i_cube = 1 , num_cube areaOfMesh % min ( 1 ) = min ( areaOfMesh % min ( 1 ), self % cubes ( i_cube )% area % min ( 1 )) areaOfMesh % min ( 2 ) = min ( areaOfMesh % min ( 2 ), self % cubes ( i_cube )% area % min ( 2 )) areaOfMesh % min ( 3 ) = min ( areaOfMesh % min ( 3 ), self % cubes ( i_cube )% area % min ( 3 )) areaOfMesh % max ( 1 ) = max ( areaOfMesh % max ( 1 ), self % cubes ( i_cube )% area % max ( 1 )) areaOfMesh % max ( 2 ) = max ( areaOfMesh % max ( 2 ), self % cubes ( i_cube )% area % max ( 2 )) areaOfMesh % max ( 3 ) = max ( areaOfMesh % max ( 3 ), self % cubes ( i_cube )% area % max ( 3 )) end do end function !>cubeのエリアを構造体で返す関数 type ( area_t ) function areaOfCube ( self ) class ( cube_inP3D ), intent ( in ) :: self areaOfCube % min ( 1 ) = minval ( self % nodes (:,:,:, 1 )) areaOfCube % min ( 2 ) = minval ( self % nodes (:,:,:, 2 )) areaOfCube % min ( 3 ) = minval ( self % nodes (:,:,:, 3 )) areaOfCube % max ( 1 ) = maxval ( self % nodes (:,:,:, 1 )) areaOfCube % max ( 2 ) = maxval ( self % nodes (:,:,:, 2 )) areaOfCube % max ( 3 ) = maxval ( self % nodes (:,:,:, 3 )) end function !>cubeのエリア内に任意座標（引数）が含まれているかを返す関数 logical function isIncluded ( self , cdn ) class ( cube_inP3D ), intent ( in ) :: self real , intent ( in ) :: cdn ( 3 ) isIncluded = . false . if (( cdn ( 1 ) >= self % area % min ( 1 )). and .( cdn ( 2 ) >= self % area % min ( 2 )). and .( cdn ( 3 ) >= self % area % min ( 3 ))) then if (( cdn ( 1 ) <= self % area % max ( 1 )). and .( cdn ( 2 ) <= self % area % max ( 2 )). and .( cdn ( 3 ) <= self % area % max ( 3 ))) then isIncluded = . true . end if end if end function !>任意座標（引数）を含むcubeをメッシュの中から探してそのIDを返す関数 integer function get_cubeID_contains ( self , cdn ) class ( Plot3dMesh ), intent ( in ) :: self real , intent ( in ) :: cdn ( 3 ) integer i_cube , num_cube get_cubeID_contains = 0 num_cube = self % get_numCube () do i_cube = 1 , num_cube if ( self % cubes ( i_cube )% isIncluded ( cdn )) then get_cubeID_contains = i_cube return end if end do print * , 'ERROR : The Point is Out of Area.' , cdn error stop end function !>任意座標（引数）に最近傍な節点を探してそのIDを返す関数 function nearest_nodeID ( self , cdn ) result ( nodeID ) class ( cube_inP3D ), intent ( in ) :: self real , intent ( in ) :: cdn ( 3 ) integer nodeID ( 3 ) integer i , j , k , cubeShape ( 4 ) real relation ( 3 ) real , allocatable :: distance (:,:,:) cubeShape = shape ( self % nodes ) allocate ( distance ( cubeShape ( 1 ), cubeShape ( 2 ), cubeShape ( 3 )), source = 1.e9 ) !$OMP parallel private(relation) !$OMP do collapse(3) do k = 1 , cubeShape ( 3 ) do j = 1 , cubeShape ( 2 ) do i = 1 , cubeShape ( 1 ) relation (:) = cdn (:) - self % nodes ( i , j , k , :) distance ( i , j , k ) = norm2 ( relation (:)) end do end do end do !$OMP end do !$OMP end parallel nodeID = minloc ( distance ) end function ! function nearer_nodeID(self, cdn, inodeID) result(rnodeID) !     class(cube_inP3D), intent(in) :: self !     real, intent(in) :: cdn(3) !     integer, intent(in) :: inodeID(3) !     integer nodeID(3), rnodeID(3), i, maxID !     real distance_min, relation(3) !     integer,parameter :: diff(3,6) & !                         = reshape([1,0,0, -1,0,0, 0,1,0, 0,-1,0, 0,0,1, 0,0,-1], shape(diff)) !     logical update !     type(cube_inP3D) cube_ !     type(node_inCUBE) node_ !     node_ = self%nodes(inodeID(1), inodeID(2), inodeID(3)) !     relation(1) = cdn(1) - node_%x !     relation(2) = cdn(2) - node_%y !     relation(3) = cdn(3) - node_%z !     distance_min = norm2(relation(:)) !     rnodeID = inodeID !     update = .true. !     maxID = size(cube_%nodes(:,:,:), dim=1) !     do while(update) !         update = .false. !         check : do i = 1, 6 !             nodeID(:) = rnodeID(:) + diff(:,i) !             if((minval(nodeID) < 1).or.(maxval(nodeID) > maxID)) cycle check !             node_ = cube_%nodes(nodeID(1), nodeID(2), nodeID(3)) !             relation(1) = cdn(1) - node_%x !             relation(2) = cdn(2) - node_%y !             relation(3) = cdn(3) - node_%z !             if(norm2(relation(:)) < distance_min) then !                 distance_min = norm2(relation(:)) !                 rnodeID = nodeID !                 update = .true. !             end if !         end do check !     end do ! end function !>任意座標（引数）に最近傍な節点を探し、その情報（cubeID,nodeID）を返す関数 type ( plot3dNodeInfo ) function nearestNodeInfo ( self , cdn ) class ( Plot3dMesh ), intent ( in ) :: self real , intent ( in ) :: cdn ( 3 ) integer cubeID !, nodeID(3) cubeID = self % get_cubeID_contains ( cdn ) nearestNodeInfo % cubeID = cubeID nearestNodeInfo % nodeID (:) = self % cubes ( cubeID )% nearest_nodeID ( cdn ) ! nodeID = self%cubes(cubeID)%nearest_nodeID(cdn, 4) ! nearestNodeInfo%nodeID(:) = self%cubes(cubeID)%nearer_nodeID(cdn, nodeID) end function ! subroutine write_plot3d_multigrid(mesh_in, fName) !     type(cube_inP3D), intent(in) :: mesh_in(:) !     character(*), intent(in) :: fName !     integer n_unit, i,j,k, i_cube, num_cube !     integer, allocatable :: ni(:), nj(:), nk(:) !     num_cube = size(mesh_in) !     allocate(ni(num_cube), nj(num_cube), nk(num_cube)) !     do i_cube = 1, num_cube !         ni(i_cube) = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !         nj(i_cube) = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !         nk(i_cube) = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !     end do !     open(newunit=n_unit , form='unformatted', file=fName, status='replace') !         write(n_unit) num_cube !         write(n_unit) (ni(i_cube), nj(i_cube), nk(i_cube), i_cube=1,num_cube) !         do i_cube = 1, num_cube !             write(n_unit) & !                 ((( mesh_in(i_cube)%nodes(i,j,k)%x, & !                     i = 1, ni(i_cube) ), j = 1, nj(i_cube) ), k = 1, nk(i_cube) ), & !                 ((( mesh_in(i_cube)%nodes(i,j,k)%y, & !                     i = 1, ni(i_cube) ), j = 1, nj(i_cube) ), k = 1, nk(i_cube) ), & !                 ((( mesh_in(i_cube)%nodes(i,j,k)%z, & !                     i = 1, ni(i_cube) ), j = 1, nj(i_cube) ), k = 1, nk(i_cube) ) !                 ! (((iblank(i,j,k,i_cube), i = 1, ni(i_cube) ), j = 1, nj(i_cube) ), k = 1, nk(i_cube) ) !         end do !     close(n_unit) ! end subroutine ! subroutine write_plot3d_f(mesh_in, fName) !     type(cube_inP3D), intent(in) :: mesh_in(:) !     character(*), intent(in) :: fName !     integer n_unit, i,j,k,l, i_cube, num_cube !     integer, allocatable :: ni(:), nj(:), nk(:), nf(:) !     num_cube = size(mesh_in) !     allocate(ni(num_cube), nj(num_cube), nk(num_cube), nf(num_cube)) !     do i_cube = 1, num_cube !         ni(i_cube) = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !         nj(i_cube) = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !         nk(i_cube) = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !     end do !     do i_cube = 1, num_cube !         nf(i_cube) = size(mesh_in(i_cube)%nodes(1,1,1)%f(:), dim=1) !     end do !     open(newunit=n_unit , form='unformatted', file=fName, status='replace') !         write(n_unit) num_cube !         write(n_unit) (ni(i_cube), nj(i_cube), nk(i_cube), nf(i_cube), i_cube=1,num_cube) !         do i_cube = 1, num_cube !             write(n_unit) & !             (((( mesh_in(i_cube)%nodes(i,j,k)%f(l), & !             i = 1, ni(i_cube) ), j = 1, nj(i_cube) ), k = 1, nk(i_cube) ), & !             l = 1, nf(i_cube)) !         end do !     close(n_unit) ! end subroutine ! subroutine write_plot3d_asVTK(mesh_in, fName, n_cell)   !ひとつのcubeをひとつの節点とみなしてVTK出力 !     type(cube_inP3D), intent(in) :: mesh_in(:) !     character(*), intent(in) :: fName !     integer, intent(in) :: n_cell    !CUBE一辺当たりのセル数 !     integer n_unit, i_cube, num_cube, i,j,k, num_func, i_node, num_nodes, num_cells, i_cell !     integer i_max, j_max, k_max, delta_i, delta_j, delta_k, i1,i2,i3,i4, i_n !     real :: cdn(3), velocity(3) !     num_cube = size(mesh_in) !     num_nodes = num_cube*((n_cell + 1)**3) !     num_cells = num_cube*(n_cell**3) !     print*, 'VTK informations:' !     print*, 'nodes =', num_nodes !     print*, 'cells=', num_cells !     open(newunit=n_unit , form='formatted', file=fName, status='replace') !         write(n_unit, '(A)') '# vtk DataFile Version 2.0' !         write(n_unit, '(A)') 'Header' !         write(n_unit, '(A)') 'ASCII' !         write(n_unit, '(A)') 'DATASET UNSTRUCTURED_GRID' !         write(n_unit, *) 'POINTS', num_nodes, 'float' !         do i_cube = 1, num_cube !             i_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !             j_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !             k_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !             delta_i = (i_max - 1) / n_cell !             delta_j = (j_max - 1) / n_cell !             delta_k = (k_max - 1) / n_cell !             do k = 1, k_max, delta_k !                 do j = 1, j_max, delta_j !                     do i = 1, i_max, delta_i !                         cdn(1) = mesh_in(i_cube)%nodes(i,j,k)%x !                         cdn(2) = mesh_in(i_cube)%nodes(i,j,k)%y !                         cdn(3) = mesh_in(i_cube)%nodes(i,j,k)%z !                         write(n_unit, '(3(E15.8e2,2X))') cdn(:) !                     end do !                 end do !             end do !         end do !         write(n_unit, *) 'CELLS ', num_cells, num_cells*9 !         do i_cube = 1, num_cube !             i_node =  (i_cube - 1)*((n_cell + 1)**3)    !CUBEの基準点ID !             i_n = 0 !             do i_cell = 1, n_cell**3 !                 i1 = i_node + i_n    !セルの基準点ID !                 i2 = i1 + n_cell + 1 !                 i3 = i1 + (n_cell + 1)**2 !                 i4 = i3 + n_cell + 1 !                 write(n_unit, *)  8, i1, i1+1, i2, i2+1, i3, i3+1, i4, i4+1 !                 i_n = i_n + 1 !                 if(mod(i_n +1, n_cell +1) == 0) i_n = i_n + 1 !                 if(mod(i_n +1 +n_cell, (n_cell +1)**2)==0) i_n = i_n + (n_cell + 1) !             end do !         end do !         write(n_unit, *) 'CELL_TYPES', num_cells !         do i_cell = 1, num_cells !             write(n_unit, *) 11 !11:直方体 !         end do !         num_func = size(mesh_in(1)%nodes(1,1,1)%f(:)) !         write(n_unit, *) 'POINT_DATA', num_nodes !         write(n_unit, '(A)') 'SCALARS density float' !         write(n_unit, '(A)') 'LOOKUP_TABLE default' !         do i_cube = 1, num_cube !             i_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !             j_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !             k_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !             delta_i = (i_max - 1) / n_cell !             delta_j = (j_max - 1) / n_cell !             delta_k = (k_max - 1) / n_cell !             do k = 1, k_max, delta_k !                 do j = 1, j_max, delta_j !                     do i = 1, i_max, delta_i !                         write(n_unit, '(E15.8e2)') mesh_in(i_cube)%nodes(i,j,k)%f(1) !                     end do !                 end do !             end do !         end do !         write(n_unit, '(A)') 'VECTORS velocity float' !         do i_cube = 1, num_cube !             i_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !             j_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !             k_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !             delta_i = (i_max - 1) / n_cell !             delta_j = (j_max - 1) / n_cell !             delta_k = (k_max - 1) / n_cell !             do k = 1, k_max, delta_k !                 do j = 1, j_max, delta_j !                     do i = 1, i_max, delta_i !                         velocity(:) = mesh_in(i_cube)%nodes(i,j,k)%f(2:4) / mesh_in(i_cube)%nodes(i,j,k)%f(1) !                         write(n_unit, '(3(E15.8e2,2X))') velocity(:) !                     end do !                 end do !             end do !         end do !     close(n_unit) ! end subroutine !>メッシュクラスメソッド !>保存量ファイル（.f）を読み込み、メッシュクラスに格納する subroutine read_plot3d_function ( self , fName ) class ( Plot3dMesh ) self character ( * ), intent ( in ) :: fName integer num_cube integer n_unit , i , j , k , l , i_cube real , allocatable :: min_f (:), max_f (:) integer , allocatable :: ni (:), nj (:), nk (:), nf (:) print * , 'READ_function:' , fName open ( newunit = n_unit , form = 'unformatted' , file = fName , status = 'old' , action = 'read' ) read ( n_unit ) num_cube ; print * , 'num_cube=' , num_cube if ( num_cube /= size ( self % cubes )) then print * , 'ERROR:the number of cube is not macth' , num_cube , size ( self % cubes ) error stop end if allocate ( ni ( num_cube ), nj ( num_cube ), nk ( num_cube ), nf ( num_cube )) read ( n_unit ) ( ni ( i_cube ), nj ( i_cube ), nk ( i_cube ), nf ( i_cube ), i_cube = 1 , num_cube ) print * , 'nf=' , minval ( nf (:)), maxval ( nf (:)) if (. not . allocated ( self % cubes ( 1 )% f )) then do i_cube = 1 , num_cube allocate ( self % cubes ( i_cube )% f ( ni ( i_cube ), nj ( i_cube ), nk ( i_cube ), nf ( i_cube ))) end do end if do i_cube = 1 , num_cube read ( n_unit ) & (((( self % cubes ( i_cube )% f ( i , j , k , l ), & i = 1 , ni ( i_cube )), j = 1 , nj ( i_cube )), k = 1 , nk ( i_cube )), l = 1 , nf ( i_cube )) end do allocate ( min_f ( maxval ( nf (:))), source = 1.e9 ) allocate ( max_f ( maxval ( nf (:))), source =- 1.e9 ) do i_cube = 1 , num_cube do l = 1 , nf ( i_cube ) min_f ( l ) = min ( min_f ( l ), minval ( self % cubes ( i_cube )% f (:,:,:, l ))) max_f ( l ) = max ( max_f ( l ), maxval ( self % cubes ( i_cube )% f (:,:,:, l ))) end do end do print * , min_f print * , max_f close ( n_unit ) end subroutine ! function extract_cube(mesh_in, min_cdn, max_cdn) result(mesh_extracted) !     type(cube_inP3D), intent(in) :: mesh_in(:) !     type(cube_inP3D), allocatable :: mesh_extracted(:) !     real, intent(in) :: min_cdn(3), max_cdn(3) !     real :: center(3) !     integer i_cube, l, cube_cnt, num_cube !     logical extract !     integer :: original_ID(size(mesh_in)) !     num_cube = size(mesh_in) !     cube_cnt = 0 !     do i_cube = 1, num_cube !         extract = .false. !         center(:) = get_center_position(mesh_in(i_cube)%nodes) !         do l = 1, 3 !             if(center(l) < min_cdn(l)) extract = .true. !             if(center(l) > max_cdn(l)) extract = .true. !         end do !         if(extract) cycle !         cube_cnt = cube_cnt +1 !         original_ID(cube_cnt) = i_cube !     end do !     print*, 'cube_count=', cube_cnt !     allocate(mesh_extracted(cube_cnt)) !     do i_cube = 1, cube_cnt !         mesh_extracted(i_cube) = mesh_in(original_ID(i_cube)) !     end do ! end function ! function change_resolution(mesh_in, resolution) result(mesh_changed) !     type(cube_inP3D), intent(in) :: mesh_in(:) !     type(cube_inP3D) :: mesh_changed(size(mesh_in)) !     integer, intent(in) :: resolution   !一辺当たりのセル数 !     integer i_cube, i,j,k, num_cube, i_max, j_max, k_max, delta_i, delta_j, delta_k !     integer ii,jj,kk !     num_cube = size(mesh_in) !     do i_cube = 1, num_cube !         allocate(mesh_changed(i_cube)%nodes(resolution+1, resolution+1, resolution+1)) !         ! do k = 1, resolution+1 !         !     do j = 1, resolution+1 !         !         do i = 1, resolution+1 !         !             nf = size(mesh_in(i_cube)%nodes(i,j,k)%f(:)) !         !             allocate(mesh_changed(i_cube)%nodes(i,j,k)%f(nf)) !         !         end do !         !     end do !         ! end do !     end do !     do i_cube = 1, num_cube !         i_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !         j_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !         k_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !         delta_i = (i_max - 1) / resolution !         delta_j = (j_max - 1) / resolution !         delta_k = (k_max - 1) / resolution !         kk = 1 !         do k = 1, k_max, delta_k !             jj = 1 !             do j = 1, j_max, delta_j !                 ii = 1 !                 do i = 1, i_max, delta_i !                     mesh_changed(i_cube)%nodes(ii,jj,kk) = mesh_in(i_cube)%nodes(i,j,k) !                     ii = ii + 1 !                 end do !                 jj = jj + 1 !             end do !             kk = kk + 1 !         end do !     end do ! end function ! function extract_function(mesh_in, nf) result(mesh_extracted) !     type(cube_inP3D), intent(in) :: mesh_in(:) !     type(cube_inP3D) :: mesh_extracted(size(mesh_in)) !     integer, intent(in) :: nf   !関数の数 !     integer i_cube, i,j,k, num_cube, i_max, j_max, k_max !     num_cube = size(mesh_in) !     do i_cube = 1, num_cube !         i_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !         j_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !         k_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !         allocate(mesh_extracted(i_cube)%nodes(i_max, j_max, k_max)) !         do k = 1, k_max !             do j = 1, j_max !                 do i = 1, i_max !                     allocate(mesh_extracted(i_cube)%nodes(i,j,k)%f(nf)) !                     mesh_extracted(i_cube)%nodes(i,j,k)%f(:) = mesh_in(i_cube)%nodes(i,j,k)%f(:nf) !                 end do !             end do !         end do !     end do ! end function ! function get_center_position(nodes) result(center) !     type(node_inCUBE) :: nodes(:,:,:) !     real :: center(3) !     integer ni,nj,nk,num_nodes !     ni = size(nodes(:,:,:), dim=1) !     nj = size(nodes(:,:,:), dim=2) !     nk = size(nodes(:,:,:), dim=3) !     num_nodes = ni * nj * nk !     center(1) = sum(nodes(:,:,:)%x) !     center(2) = sum(nodes(:,:,:)%y) !     center(3) = sum(nodes(:,:,:)%z) !     center(:) = center(:) / num_nodes ! end function ! real function mean_value(nodes, n_func) !     type(node_inCUBE) :: nodes(:,:,:) !     integer, intent(in) :: n_func !     integer ni,nj,nk,num_nodes, i,j,k !     ni = size(nodes(:,:,:), dim=1) !     nj = size(nodes(:,:,:), dim=2) !     nk = size(nodes(:,:,:), dim=3) !     num_nodes = ni * nj * nk !     mean_value = 0.0 !     do k = 1, nk !         do j = 1, nj !             do i = 1, ni !                 mean_value = mean_value+ nodes(i,j,k)%f(n_func) !             end do !         end do !     end do !     mean_value = mean_value / num_nodes ! end function !>メッシュを構成するcube数を返す関数 integer function get_numCube ( self ) class ( Plot3dMesh ), intent ( in ) :: self get_numCube = size ( self % cubes ) end function !>cubeの形状（i,j,k節点数）を返す関数 function get_cubeShape ( self ) result ( cubeShape ) class ( Plot3dMesh ), intent ( in ) :: self integer shapeArray ( 4 ), cubeShape ( 3 ) shapeArray = shape ( self % cubes ( 1 )% nodes ) cubeShape = shapeArray ( 1 : 3 ) end function !>任意節点（引数）における流速を返す関数 function get_velocity ( self , node ) result ( velocity ) class ( Plot3dMesh ) self type ( plot3dNodeInfo ), intent ( in ) :: node !!節点 type ( cube_inP3D ) cube real velocity ( 3 ) cube = self % cubes ( node % cubeID ) !質量流束（第2〜第4成分）を密度（第1成分）で割ることで流速を取得する velocity (:) = cube % f ( node % nodeID ( 1 ), node % nodeID ( 2 ), node % nodeID ( 3 ), 2 : 4 ) & / cube % f ( node % nodeID ( 1 ), node % nodeID ( 2 ), node % nodeID ( 3 ), 1 ) end function end module plot3d_operator","tags":"","loc":"sourcefile/plot3d_operator.f90.html"},{"title":"SCTfile_reader.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~sctfile_reader.f90~~AfferentGraph sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules SCT_file_reader_m Source Code SCTfile_reader.f90 Source Code module SCT_file_reader_m !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !!version: 2.5.2 !!author: T.Ikeda, Y.Ida !!summary: !!- SC/TETRA 出力のファイルを読み取り，データを取り出す. !!- 今までのconverterと異なり, 本モジュールで独立して扱えるようになっている. !!- 並列化には対応していない. !! !!@note !! !!- セルの節点の並び順はwedge以外はvtkのものと同じ. !!- SC/TETRAでは，セル番号および節点番号は0スタートなので, fortran運用のためインデックス+1. !!- 頂点配列(NDNO)はセルタイプ毎に並んでいない. !!- cell2verticesのrank 1には最大で8つ(hexahedron), face2verticesには4つの値が入るが, !!  値が入っていない箇所は全て-1に統一されている. !! !!@endnote !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ implicit none private integer ( 4 ) LCORD !!座標番号(=0固定): 多分不要 integer , parameter :: LengthOfSubRecord = 4194304 !!サブレコード1行あたりの長さの上限. 必要はないがメモとして !面の定義. [頂点数, ローカル節点番号の並び].ローカル節点番号は1~最大8. integer , private , target :: SCTTetraFaces_ ( 3 + 1 , 4 ) = reshape ( & [ 3 , 4 , 3 , 2 , & 3 , 4 , 1 , 3 , & 3 , 4 , 2 , 1 , & 3 , 1 , 2 , 3 ], shape ( SCTTetraFaces_ )) integer , private , target :: SCTPyramidFaces_ ( 4 + 1 , 5 ) = reshape ( & [ 3 , 1 , 5 , 2 , - 1 , & 3 , 2 , 5 , 3 , - 1 , & 3 , 3 , 5 , 4 , - 1 , & 3 , 4 , 5 , 1 , - 1 , & 4 , 1 , 2 , 3 , 4 ], shape ( SCTPyramidFaces_ )) integer , private , target :: SCTPrismFaces_ ( 4 + 1 , 5 ) = reshape ( & [ 4 , 1 , 4 , 5 , 2 , & 4 , 2 , 5 , 6 , 3 , & 4 , 3 , 6 , 4 , 1 , & 3 , 1 , 2 , 3 , - 1 , & 3 , 6 , 5 , 4 , - 1 ], shape ( SCTPrismFaces_ )) integer , private , target :: SCTHexahedronFaces_ ( 4 + 1 , 6 ) = reshape ( & [ 4 , 1 , 5 , 6 , 2 , & 4 , 2 , 6 , 7 , 3 , & 4 , 3 , 7 , 8 , 4 , & 4 , 4 , 8 , 5 , 1 , & 4 , 1 , 2 , 3 , 4 , & 4 , 8 , 7 , 6 , 5 ], shape ( SCTHexahedronFaces_ )) real ( 8 ), parameter , public :: MissingValueSize = 1.0d20 !! SC/TETRAで規定された欠測値の大きさ. character ( 10 ), parameter :: LS_Scalar_HeadName = \"LS_Scalar:\" character ( 10 ), parameter :: LS_Vector_HeadName = \"LS_Vector:\" character ( 32 ), parameter :: OverLapEndLabel = \"OverlapEnd\" integer , parameter :: LS_Scalar_DataSize = 30 !!.fldに含まれるスカラーデータの個数上限. integer , parameter :: LS_Vector_DataSize = 30 !!.fldに含まれるベクトルデータの個数上限. type , private :: LS_Scalar_t character (:), allocatable :: name character (:), allocatable :: abbreviated_name integer ( 4 ) ndata real ( 8 ), allocatable :: data (:) end type type , private :: LS_Vector_t character (:), allocatable :: name character (:), allocatable :: abbreviated_name integer ( 4 ) ndata real ( 8 ), allocatable :: x (:), y (:), z (:) end type type , private :: sctregion_t integer ( 4 ) NE character (:), allocatable :: LRGN integer ( 4 ), allocatable :: IE (:) !!領域を構成する要素番号 integer ( 4 ), allocatable :: IFA (:) !!領域を構成するローカル面番号. contains procedure , private :: get_data => get_sctregion_data_ procedure , private :: extract_region_surface_ end type sctregion_t type sct_data_name_list_t !! スカラーorベクトルデータの名前だけを取り出す. 構造体の配列にして使用する. !! region用に使うことも出来る. その場合abbreviatedは使わない. !! 異なる文字長の配列が実装できなかったのでこれで代用する. character (:), allocatable :: name character (:), allocatable :: abbreviated_name end type type sct_grid_t !! SC/TETRA メッシュクラス. !! 必要最低限の変数のみ保持. 変数名はフォーマットに準拠. !! メッシュそのものを取り扱うのでメモリ圧迫する可能性大. !! ソルバ内で使う場合はサブルーチンのローカル変数として扱う方が無難(自動開放されるはず) logical , private :: is_FLD logical , private :: includes_topo ! integer,private :: error_code integer ( 4 ), private :: NELEM = 0 !!要素数 integer ( 4 ), private :: NTTE = 0 !!1要素あたりの節点数の合計 integer ( 4 ), allocatable , private :: IETYP (:) !! 要素タイプ. !! 34:tetrahedron, 35:pyramid, 36:wedge, 38:hexahedron integer ( 4 ), allocatable , private :: NDNO (:) !! 節点番号 integer ( 4 ), allocatable , private :: GRP (:) !! グループ番号 integer ( 4 ), allocatable , private :: MAT (:) !! 物性番号 !! 多分使えないけど念のため... integer ( 4 ), private :: NNODS = 0 !! 節点の総数 real ( 8 ), allocatable , private :: CDN_X (:), CDN_Y (:), CDN_Z (:) !! 節点座標 integer ( 4 ), private :: NDATA = 0 !! 場の変数のデータ数(=NNODS) ! SctRegion用変数 integer ( 4 ), private :: NRGN = 0 !! NRGN: 領域の個数, 配列regionの次元 integer ( 4 ), private :: NLEN = 0 !! NLEN: 領域名LRGNのバイト数 type ( sctregion_t ), allocatable , private :: region (:) !test 2021/10/12 !連結リストの方が良い? integer , private :: scalar_data_count = 0 integer , private :: vector_data_count = 0 type ( LS_Scalar_t ), allocatable , private :: scalars (:) type ( LS_Vector_t ), allocatable , private :: vectors (:) integer , private :: tetra_count_ = 0 integer , private :: pyramid_count_ = 0 integer , private :: wedge_count_ = 0 integer , private :: hexa_count_ = 0 contains procedure , public :: includes_topology procedure , public :: is_fld_file procedure , public :: print_self procedure , public :: read_SCT_file procedure , public :: extract_original_cell_vertices procedure , public :: extract_cell_vertices procedure , public :: extract_ordered_cell_vertices procedure , public :: get_2d_array_of_point_coords ! procedure get_2d_array_of_point_velocity !データをsearch_vector_dataで探す方針なので削除. procedure , public :: get_cell_types procedure , public :: get_element_count procedure , public :: get_vertex_count procedure , public :: get_tetrahedron_count procedure , public :: get_wedge_count procedure , public :: get_pyramid_count procedure , public :: get_hexahedron_count procedure , public :: get_region_count procedure , public :: get_region_namelist procedure , public :: extract_face2vertices_on_region procedure , public :: search_scalar_data procedure , public :: search_vector_data procedure , public :: get_data_titles final destructor end type interface get_data_array_ module procedure get_data_array_int32_ module procedure get_data_array_float64_ end interface get_data_array_ public sct_grid_t , sct_data_name_list_t , get_cell_data_from_cellvertices contains !========================================================================== ! PUBLIC : subroutine !========================================================================== subroutine get_cell_data_from_cellvertices ( cell_data , cell2vertices , point_data ) !! 各セル毎の頂点配列に関連する節点中心データからセル中心データを構築する. !! 値はセルを構成する節点データの算術平均として計算する. implicit none integer , intent ( inout ) :: cell_data (:) !!出力されるセル中心データ. integer , intent ( in ) :: cell2vertices (:,:) !!頂点配列. integer , intent ( in ) :: point_data (:) !!任意の節点データ. integer cell , node_count node_count = ubound ( cell2vertices , dim = 1 ) do cell = 1 , size ( cell2vertices , dim = 2 ) cell_data ( cell ) = sum ( point_data ( cell2vertices ( 1 : node_count , cell ))) / node_count end do end subroutine !========================================================================== ! type bounded procedure : sct_grid_t !========================================================================== logical function includes_topology ( this ) !! 格子ファイルがトポロジを含むか. implicit none class ( sct_grid_t ), intent ( in ) :: this includes_topology = this % includes_topo end function logical function is_fld_file ( this ) !!ファイルがFLDか. implicit none class ( sct_grid_t ), intent ( in ) :: this is_fld_file = this % is_FLD end function subroutine print_self ( this , unit ) implicit none class ( sct_grid_t ), intent ( in ) :: this integer , intent ( in ) :: unit integer i , nrg write ( unit , \"('sct grid information ')\" , advance = \"no\" ) if ( this % includes_topo ) then write ( unit , \"(A)\" ) \"from \" // merge ( \"fld file\" , \"pre file\" , this % is_FLD ) write ( unit , \"(' cell      :: ', i0)\" ) this % NELEM write ( unit , \"(' - tetra   :: ', i0)\" ) this % tetra_count_ write ( unit , \"(' - pyramid :: ', i0)\" ) this % pyramid_count_ write ( unit , \"(' - wedge   :: ', i0)\" ) this % wedge_count_ write ( unit , \"(' - hexa    :: ', i0)\" ) this % hexa_count_ write ( unit , \"(' node      :: ', i0)\" ) this % NNODS if ( allocated ( this % region )) then write ( unit , \"(' region info ')\" ) do nrg = 1 , this % NRGN write ( unit , \"(2x,A,1x,A)\" ) trim ( this % region ( nrg )% LRGN ), merge ( \"(vol )\" , \"(surf)\" , all ( this % region ( nrg )% IFA == 0 )) end do endif else write ( unit , \"('topology information not found.')\" ) endif if ( this % is_FLD ) then write ( unit , \"(' scalar data  :: ', i0)\" ) this % scalar_data_count write ( unit , \"(A,' = ',A)\" ) ( this % scalars ( i )% abbreviated_name , this % scalars ( i )% name , i = 1 , this % scalar_data_count ) write ( unit , \"(' vector data  :: ', i0)\" ) this % vector_data_count write ( unit , \"(A,' = ',A)\" ) ( this % vectors ( i )% abbreviated_name , this % vectors ( i )% name , i = 1 , this % vector_data_count ) endif end subroutine subroutine read_SCT_file ( this , filename ) !! SCTファイルを開き，データを取得する. 事実上のコンストラクタ. !! 既に別のファイルを開いていた場合，そのデータを破棄して開く. implicit none class ( sct_grid_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: filename ! character(256) :: errmsg integer unit !割り付けされている物があれば解放する. call destructor ( this ) if (. not . open_binary_sequential_ ( unit , filename )) then return endif select case ( get_extension_ ( filename )) case ( \".pre\" ) ! メッシュファイルの場合 this % is_FLD = . false . this % includes_topo = . true . call readPRE_Header_data_ ( unit ) call readPRE_Main_data_ ( unit , this % NELEM , this % IETYP , this % NTTE , this % NDNO , this % GRP , this % MAT , this % NNODS , & this % CDN_X , this % CDN_Y , this % CDN_Z , this % region , this % NRGN , this % NLEN ) case ( \".fld\" ) ! fldファイルの場合 ! fldの初期ファイルでないとトポロジー情報が入手できないらしい. this % is_FLD = . true . call readFLD_Header_data_ ( unit ) !call readFLD_Main_data_(unit, this%NELEM, this%IETYP, this%NTTE, this%NDNO, this%MAT, this%NNODS, & !                       this%CDN_X, this%CDN_Y, this%CDN_Z, this%NDATA, this%VEL_X, this%VEL_Y, this%VEL_Z, this%PRES) call readFLD_Main_data_2 ( unit , this % NELEM , this % IETYP , this % NTTE , this % NDNO , this % MAT , this % NNODS , & this % CDN_X , this % CDN_Y , this % CDN_Z , this % scalars , this % vectors , & this % scalar_data_count , this % vector_data_count , this % includes_topo ) case default print \"(A,' is not supported. STOP')\" , trim ( filename ) return end  select !各セル数. if ( this % includes_topo ) then this % tetra_count_ = count ( this % IETYP == 34 ) this % pyramid_count_ = count ( this % IETYP == 35 ) this % wedge_count_ = count ( this % IETYP == 36 ) this % hexa_count_ = count ( this % IETYP == 38 ) end if close ( unit ) ! if(this%error_code == -3) stop \"invalid data format. \" end subroutine subroutine extract_original_cell_vertices ( this , cell2vertices ) !!Sc/Tetraで出力されたセル-頂点関係の配列をそのまま出力する. !!セルの種類毎に並んでいないのが特徴.  頂点番号は1から始まる. implicit none class ( sct_grid_t ), intent ( in ) :: this integer , allocatable , intent ( inout ) :: cell2vertices (:,:) !!頂点配列. 1st arg: vertex count, 2nd arg: cell number integer II integer offset integer nc integer KK_beg , KK_end if (. not . this % includes_topo ) return if (. not . allocated ( cell2vertices )) allocate ( cell2vertices ( 1 : 8 , 1 : this % NELEM ), source = - 1 ) nc = 1 KK_beg = 1 do II = 1 , this % NELEM offset = this % IETYP ( II ) - 30 KK_end = KK_beg + offset - 1 cell2vertices ( 1 : offset , nc ) = this % NDNO ( KK_beg : KK_end ) nc = nc + 1 KK_beg = KK_end + 1 end do end subroutine subroutine extract_cell_vertices ( this , tetras , pyramids , wedges , hexas ) !!afdet solver との互換性のため, セルタイプごとの頂点配列を出力する. !!頂点配列にはセル毎の頂点のインデックスが格納される. 頂点番号は1から始まる. implicit none class ( sct_grid_t ), intent ( in ) :: this integer , allocatable , intent ( inout ), optional :: tetras (:,:), pyramids (:,:), wedges (:,:), hexas (:,:) if (. not . this % includes_topo ) return if ( present ( tetras )) call extract_primitives_ ( this , tetras , \"tetra\" ) if ( present ( pyramids )) call extract_primitives_ ( this , pyramids , \"pyramid\" ) if ( present ( wedges )) call extract_primitives_ ( this , wedges , \"wedge\" ) if ( present ( hexas )) call extract_primitives_ ( this , hexas , \"hexa\" ) end subroutine subroutine extract_ordered_cell_vertices ( this , cell2vertices ) !!セルの種類毎に並んだ格子全体の頂点配列を作成する. !!セルはtetra→pyramid→wedge→hexaの順に並べられる. 頂点番号は1から始まる. implicit none class ( sct_grid_t ), intent ( in ) :: this integer , allocatable , intent ( inout ) :: cell2vertices (:,:) integer , allocatable :: tmp (:,:) integer :: celltypes ( 4 ) = [ 34 , 35 , 36 , 38 ] character ( 5 ), dimension ( 4 ) :: typename = [ \"tetra\" , \"pyram\" , \"wedge\" , \"hexah\" ] !gfortranだと文字数が同じでないとerrorになるため無理矢理揃えた. !ifortなら問題ないのだが... integer i , cell_beg , cell_end if (. not . this % includes_topo ) return if (. not . allocated ( cell2vertices )) allocate ( cell2vertices ( 1 : 8 , 1 : this % NELEM )) cell_beg = 1 do i = 1 , 4 if ( count ( this % IETYP == celltypes ( i )) > 0 ) then call extract_primitives_ ( this , tmp , typename ( i )) cell_end = cell_beg + size ( tmp , dim = 2 ) - 1 cell2vertices ( 1 : size ( tmp , dim = 1 ), cell_beg : cell_end ) = tmp (:,:) cell_beg = cell_end + 1 deallocate ( tmp ) end if end do end subroutine subroutine get_2d_array_of_point_coords ( this , xyz ) !! 節点座標を2次元配列で出力する. implicit none class ( sct_grid_t ), intent ( in ) :: this real ( 8 ), allocatable , intent ( inout ) :: xyz (:,:) if (. not . this % includes_topo ) return call packing_vector_into_2Darray_ ( xyz , this % CDN_X , this % CDN_Y , this % CDN_Z ) end subroutine ! subroutine get_2d_array_of_point_velocity(this, velocity) !     !! 節点流速データを2次元配列で出力する. !     implicit none !     class(sct_grid_t),intent(in) :: this !     real(8),allocatable,intent(inout) :: velocity(:,:) !     if(this%error_code /= 0) return !     call packing_vector_into_2Darray_(velocity, this%VEL_X, this%VEL_Y, this%VEL_Z) ! end subroutine subroutine get_cell_types ( this , celltypes , conversion ) !!セルタイプ配列を出力する. !!extract_original_cell_verticesで出力したセル-節点配列に対して有効. implicit none class ( sct_grid_t ), intent ( in ) :: this integer , allocatable , intent ( inout ) :: celltypes (:) !!セルタイプ配列 character ( * ), intent ( in ), optional :: conversion !!セルタイプ番号をvtk, xdmfいずれかに変換する. if (. not . this % includes_topo ) return allocate ( celltypes , source = this % IETYP ) if (. not . present ( conversion )) return select case ( trim ( conversion )) case ( \"vtk\" , \"VTK\" ) where ( celltypes == 34 ) celltypes = 10 elsewhere ( celltypes == 35 ) celltypes = 14 elsewhere ( celltypes == 36 ) celltypes = 13 elsewhere ( celltypes == 38 ) celltypes = 12 endwhere case ( \"xdmf\" , \"XDMF\" ) where ( celltypes == 34 ) celltypes = 6 elsewhere ( celltypes == 35 ) celltypes = 7 elsewhere ( celltypes == 36 ) celltypes = 8 elsewhere ( celltypes == 38 ) celltypes = 9 endwhere case default print * , trim ( conversion ), \" is not implemented. \" return end select end subroutine integer function get_element_count ( this ) !!要素数を取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this if ( this % includes_topo ) get_element_count = this % NELEM end function integer function get_vertex_count ( this ) !!節点数を取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this if ( this % includes_topo ) get_vertex_count = this % NNODS end function integer function get_tetrahedron_count ( this ) !!格子に含まれるテトラ格子数を取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this if ( this % includes_topo ) get_tetrahedron_count = this % tetra_count_ end function integer function get_pyramid_count ( this ) !!格子に含まれるピラミッド格子数を取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this if ( this % includes_topo ) get_pyramid_count = this % pyramid_count_ end function integer function get_wedge_count ( this ) !!格子に含まれるプリズム格子数を取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this if ( this % includes_topo ) get_wedge_count = this % wedge_count_ end function integer function get_hexahedron_count ( this ) !!格子に含まれるヘキサ格子数を取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this if ( this % includes_topo ) get_hexahedron_count = this % hexa_count_ end function integer function get_region_count ( this ) !!領域の個数. implicit none class ( sct_grid_t ), intent ( in ) :: this get_region_count = this % NRGN end function subroutine get_region_namelist ( this , name_list ) implicit none class ( sct_grid_t ), intent ( in ) :: this type ( sct_data_name_list_t ), allocatable , intent ( inout ) :: name_list (:) integer nrg allocate ( name_list ( 1 : this % NRGN )) do nrg = 1 , this % NRGN name_list ( nrg )% name = this % region ( nrg )% LRGN enddo end subroutine subroutine extract_face2vertices_on_region ( this , region_num , cell2vertices , face2vertices ) !!任意のregionを構成する頂点配列を取得する. 体積領域は無視する. !!cell2verticesはoriginalの物でなければならない. implicit none class ( sct_grid_t ), intent ( in ) :: this integer , intent ( in ) :: region_num !!region番号. integer , allocatable , intent ( in ) :: cell2vertices (:,:) !!並べ替えのされていないセル-頂点配列. integer , allocatable , intent ( inout ) :: face2vertices (:,:) !!regionを構成する面-頂点配列. ! integer nrg if (. not . this % includes_topo ) return if ( region_num > this % NRGN ) then print * , \"error(sct_grid_t) :: region_num must be less than \" , this % NRGN return endif call this % region ( region_num )% extract_region_surface_ ( this % IETYP , cell2vertices , face2vertices ) end subroutine subroutine search_scalar_data ( this , key , scalar ) !! .fldに含まれるスカラー場データを取得する. !! keyにタイトル名を入れて検索する. 該当しない場合含まれるデータ一覧を表示. implicit none class ( sct_grid_t ), intent ( in ) :: this character ( * ), intent ( in ) :: key !!取り出したいデータのSC/TETRAでの名称. real ( 8 ), allocatable , intent ( inout ) :: scalar (:) integer i if (. not . this % is_FLD ) return !FLDファイルなら場のデータは含まれると判断. do i = 1 , size ( this % scalars ) if ( trim ( this % scalars ( i )% abbreviated_name ) == trim ( key ) ) then if ( . not . allocated ( scalar ) ) then allocate ( scalar , source = this % scalars ( i )% data ) else scalar (:) = this % scalars ( i )% data (:) end if return end if end do print \"(A,' does not exists.')\" , key print \"('Existing Scalar data are listed below:')\" do i = 1 , this % scalar_data_count print \"(A,1x,':',A)\" , this % scalars ( i )% name , this % scalars ( i )% abbreviated_name end do end subroutine subroutine search_vector_data ( this , key , vector ) !! .fldに含まれるベクトル場データを取得する. !! keyにタイトル名を入れて検索する. 該当しない場合含まれるデータ一覧を表示. implicit none class ( sct_grid_t ), intent ( in ) :: this character ( * ), intent ( in ) :: key !!取り出したいデータのSC/TETRAでの名称. real ( 8 ), allocatable , intent ( inout ) :: vector (:,:) integer i if (. not . this % is_FLD ) return do i = 1 , size ( this % vectors ) if ( trim ( this % vectors ( i )% abbreviated_name ) == trim ( key ) ) then call packing_vector_into_2Darray_ ( vector , this % vectors ( i )% x , this % vectors ( i )% y , this % vectors ( i )% z ) return end if end do print \"(A,' does not exists.')\" , key print \"('Existing Vector data are listed below:')\" do i = 1 , this % vector_data_count print \"(A,1x,':',A)\" , this % vectors ( i )% name , this % vectors ( i )% abbreviated_name end do end subroutine subroutine get_data_titles ( this , titles , data_type ) !! .fldに含まれるデータのタイトルを取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this type ( sct_data_name_list_t ), allocatable , intent ( inout ) :: titles (:) character ( * ), intent ( in ) :: data_type integer i if (. not . this % is_FLD ) return select case ( data_type ) case ( \"scalar\" ) allocate ( titles ( this % scalar_data_count )) do i = 1 , this % scalar_data_count titles ( i )% abbreviated_name = this % scalars ( i )% abbreviated_name titles ( i )% name = this % scalars ( i )% name end do case ( \"vector\" ) allocate ( titles ( this % vector_data_count )) do i = 1 , this % vector_data_count titles ( i )% abbreviated_name = this % vectors ( i )% abbreviated_name titles ( i )% name = this % vectors ( i )% name end do case default end select end subroutine subroutine destructor ( this ) implicit none type ( sct_grid_t ), intent ( inout ) :: this ! integer i if ( allocated ( this % IETYP )) deallocate ( this % IETYP ) if ( allocated ( this % MAT )) deallocate ( this % MAT ) if ( allocated ( this % NDNO )) deallocate ( this % NDNO ) if ( allocated ( this % GRP )) deallocate ( this % GRP ) if ( allocated ( this % CDN_X )) deallocate ( this % CDN_X ) if ( allocated ( this % CDN_Y )) deallocate ( this % CDN_Y ) if ( allocated ( this % CDN_Z )) deallocate ( this % CDN_Z ) ! if (allocated(this%VEL_X)) deallocate(this%VEL_X) ! if (allocated(this%VEL_Y)) deallocate(this%VEL_Y) ! if (allocated(this%VEL_Z)) deallocate(this%VEL_Z) if ( allocated ( this % region )) deallocate ( this % region ) if ( allocated ( this % scalars )) deallocate ( this % scalars ) if ( allocated ( this % vectors )) deallocate ( this % vectors ) this % NELEM = 0 this % NNODS = 0 this % NDATA = 0 this % NTTE = 0 this % NLEN = 0 this % NRGN = 0 this % tetra_count_ = 0 this % pyramid_count_ = 0 this % wedge_count_ = 0 this % hexa_count_ = 0 this % scalar_data_count = 0 this % vector_data_count = 0 end subroutine !========================================================================== ! PRIVATE : extraction !========================================================================== subroutine extract_primitives_ ( sct_grid , primitive , cell_type ) !!格子からセルタイプ毎の頂点配列を抜き出す. implicit none type ( sct_grid_t ), intent ( in ) :: sct_grid integer , allocatable , intent ( inout ) :: primitive (:,:) !!セルタイプ毎の頂点配列. 1st arg: local node number, 2nd arg: cell number !!頂点インデックスが格納される. インデックスは1スタートになっている. character ( * ), intent ( in ) :: cell_type !!セルの種類. !!\"tetra(or tetrahedron)\", \"prizm(or wedge)\", \"pyramid\", \"hexa(or hexahedron)\" integer ( 4 ) :: nc , offset integer ( 4 ) :: II , node_of_cell integer ( 4 ) :: KK_beg , KK_end integer a_err character ( 512 ) msg nc = 1 select case ( trim ( cell_type )) case ( \"tetra\" , \"tetrahedron\" ) node_of_cell = 4 case ( \"prizm\" , \"wedge\" ) node_of_cell = 6 case ( \"pyramid\" , \"pyram\" ) node_of_cell = 5 case ( \"hexa\" , \"hexahedron\" , \"hexah\" ) node_of_cell = 8 case default print \"('Unclassifiable cell type was detected. choose cell type below:')\" print \"('tetra or tetrahedron')\" print \"('prizm or wedge      ')\" print \"('pyramid             ')\" print \"('hexa  or hexahedron ')\" stop end select if ( count ( sct_grid % IETYP == 30 + node_of_cell ) == 0 ) then print \"('error: cell_type ', A, ' possibly does not exists on your mesh file...')\" , cell_type ! return end if !仮に対応するセルタイプが存在しなくても割り付けは出来るが，その場合は以下の処理も自動的にスルーされる allocate ( primitive ( 1 : node_of_cell , count ( sct_grid % IETYP == 30 + node_of_cell )), source = - 1 , & stat = a_err , errmsg = msg ) if ( a_err /= 0 ) then print \"(i0,1x,A)\" , a_err , msg return end if KK_beg = 1 do II = 1 , size ( sct_grid % IETYP ) offset = sct_grid % IETYP ( II ) - 30 KK_end = KK_beg + offset - 1 if ( sct_grid % IETYP ( II ) == 30 + node_of_cell ) then primitive ( 1 : node_of_cell , nc ) = sct_grid % NDNO ( KK_beg : KK_end ) nc = nc + 1 end if KK_beg = KK_end + 1 end do end subroutine extract_primitives_ ! subroutine get_cell_data_from_point_data_(cell_data, cell_types, node_numbers, point_data) !     !! 節点中心データからセル中心データを取り出す !     !! セルの値はセルを構成する節点データの平均として扱われる !     !!~~~ CAUTION :: THIS IS DEPRICATED METHOD ~~~ !     !! REASON) 作ってみたが，あとでセルタイプ毎に並び替えるためこの方法では矛盾する. !     !!         セル中心データへの補間は外部で行うとする方が都合が良い. !     !!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !     implicit none !     integer,allocatable,intent(inout) :: cell_data(:) !     integer,intent(in) :: cell_types(:) !     integer,intent(in) :: node_numbers(:) !     integer,intent(in) :: point_data(:) !     integer cell, node_beg, node_end, node_count !     allocate(cell_data(size(cell_types))) !     node_beg = 1 !     do cell = 1, size(cell_types) !         node_count = cell_types(cell) - 30 !         node_end = node_beg + node_count - 1 !         cell_data(cell) = sum(point_data(node_numbers(node_beg:node_end))) / node_count !         node_beg = node_end + 1 !     end do ! end subroutine !========================================================================== ! PRIVATE : utility !========================================================================== logical function open_binary_sequential_ ( unit , filename ) result ( is_opened ) !! バイナリファイルをシーケンシャル形式で開く. 開けない場合.false. integer , intent ( inout ) :: unit !! 装置番号. character ( * ), intent ( in ) :: filename character ( 256 ) iomessage integer iostatus open ( newunit = unit , file = filename , iostat = iostatus , iomsg = iomessage , & form = 'unformatted' , access = 'sequential' , status = 'old' , convert = 'big_endian' ) if ( iostatus == 0 ) then is_opened = . true . else is_opened = . false . print \"('error:',i0,1x,A)\" , iostatus , trim ( iomessage ) end if end function function get_extension_ ( filename ) result ( extension_name ) !! ファイル名の拡張子を取得する. !! e.g.) hoge.f90なら\".f90\"が返される. \".\"が2つ以上ある場合は保証しない. character ( * ), intent ( in ) :: filename character (:), allocatable :: extension_name integer extension_start extension_start = index ( filename , \".\" , back = . true .) extension_name = filename ( extension_start : len_trim ( filename )) end function subroutine packing_vector_into_2Darray_ ( array , x , y , z ) !! 実数のベクトル配列を2次元配列に詰め直す implicit none real ( 8 ), allocatable , intent ( out ) :: array (:,:) real ( 8 ), intent ( in ) :: x (:), y (:), z (:) integer size_of_array size_of_array = size ( x ) if ( size_of_array /= size ( y ) . or . size_of_array /= size ( z )) then print \"('ERROR(SCTfile_reader, packing_): size of x is different from y or z')\" return end if if (. not . allocated ( array )) allocate ( array ( 3 , size_of_array )) array ( 1 ,:) = x (:) array ( 2 ,:) = y (:) array ( 3 ,:) = z (:) end subroutine !========================================================================== ! PRIVATE: reading header !========================================================================== subroutine readPRE_Header_data_ ( unit ) !!preファイルのヘッダ部分を読み取る implicit none integer , intent ( in ) :: unit integer ( 4 ) header_num character ( 8 ) header_text character ( 32 ) title_text read ( unit ) header_text read ( unit ) header_num ! 序文データの読み取り ! おそらくvtk化するためには不要なので ! 無限ループでHeaderDataEndを検出した時点でexit do read ( unit ) title_text if ( trim ( title_text ) == 'HeaderDataEnd' ) exit read ( unit ) read ( unit ) read ( unit ) end do end subroutine subroutine readFLD_Header_data_ ( unit ) implicit none integer , intent ( in ) :: unit integer ( 4 ) header_num , NNAMS , n character ( 8 ) header_text character ( 32 ) title_text read ( unit ) header_text read ( unit ) header_num ! 序文データの読み取り ! おそらくvtk化するためには不要なので ! 無限ループでHeaderDataEndを検出した時点でexit do read ( unit ) title_text if ( trim ( title_text ) == 'HeaderDataEnd' ) then exit elseif (( trim ( title_text ) == 'Cycle' ). or .( trim ( title_text ) == 'Unused' )) then read ( unit ) read ( unit ) elseif ( trim ( title_text ) == 'Unit:$TEMP' ) then read ( unit ) read ( unit ) read ( unit ) read ( unit ) read ( unit ) NNAMS do n = 1 , NNAMS read ( unit ) end do read ( unit ) cycle end if read ( unit ) read ( unit ) read ( unit ) end do end subroutine !========================================================================== ! PRIVATE: reading main data !========================================================================== !> 本文データの読み取り．とにかく全て読み取るようにしている subroutine readPRE_Main_data_ ( unit , NELEM , IETYP , NTTE , NDNO , GRP , MAT , NNODS , CDN_X , CDN_Y , CDN_Z , region , NRGN , NLEN ) implicit none integer , intent ( in ) :: unit integer , intent ( inout ) :: NELEM integer , intent ( inout ) :: NTTE integer , allocatable , intent ( inout ) :: IETYP (:) integer , allocatable , intent ( inout ) :: NDNO (:) integer , allocatable , intent ( inout ) :: GRP (:) integer , allocatable , intent ( inout ) :: MAT (:) integer , intent ( inout ) :: NNODS real ( 8 ), allocatable , intent ( inout ) :: CDN_X (:), CDN_Y (:), CDN_Z (:) integer , intent ( inout ) :: NRGN integer , intent ( inout ) :: NLEN type ( sctregion_t ), allocatable , intent ( inout ) :: region (:) integer ( 4 ) nrg character ( 32 ) main_data_title character ( 32 ) TITLE !> OVerlapStart_nの読み取り read ( unit ) main_data_title !本文データの読み取り ! irecn == 1 なら タイトル内のサブレコードは1つ ! iretn == 1 なら サブレコード内のデータは1つ ! ibyte == 4:int32, 8:real64, 1:char(32 or 80 or 1) ! 本文データにて ibyte = 1となることはなさそう !> LS_CoordinateSystem read ( unit ) TITLE read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , LCORD ) read ( unit ) !0, 0, 0 !> LS_Elements read ( unit ) TITLE read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , IETYP , NELEM ) call get_data_int32_ ( unit , NTTE ) call get_data_array_ ( unit , NDNO , NTTE ) !NDNOは0スタートのため, 都合+1する. NDNO ( 1 : NTTE ) = NDNO ( 1 : NTTE ) + 1 read ( unit ) !0, 0, 0 !> LS_GrpOfElements read ( unit ) TITLE read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , GRP , NELEM ) read ( unit ) !> LS_MatOfElements read ( unit ) TITLE read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , MAT , NELEM ) read ( unit ) !> LS_Nodes read ( unit ) TITLE read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NNODS ) call get_data_array_ ( unit , CDN_X , NNODS ) call get_data_array_ ( unit , CDN_Y , NNODS ) call get_data_array_ ( unit , CDN_Z , NNODS ) read ( unit ) !> OverlapEndならそのまま終了 !> そうで無い場合，任意データLS_SctRegionsが存在しうるが !> vtk化のためには不要と思われるので現状は素通り !> 追記：2021/05/30　境界面の指定番号なのでIFACE.DATへ利用可能かも read ( unit ) TITLE if ( trim ( TITLE ) == 'OverlapEnd' ) then print * , 'SctRegion is not included in this file. ' else print * , 'SctRegions is included.' read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NRGN ) allocate ( region ( NRGN )) call get_data_int32_ ( unit , NLEN ) do nrg = 1 , NRGN call region ( nrg )% get_data ( unit , NLEN ) end do read ( unit ) end if end subroutine subroutine readFLD_Main_data_ ( unit , NELEM , IETYP , NTTE , NDNO , MAT , & NNODS , CDN_X , CDN_Y , CDN_Z , & NDATA , VEL_X , VEL_Y , VEL_Z , & PRES ) implicit none integer , intent ( in ) :: unit integer , intent ( inout ) :: NELEM integer , intent ( inout ) :: NTTE integer , allocatable , intent ( inout ) :: IETYP (:) integer , allocatable , intent ( inout ) :: NDNO (:) integer , allocatable , intent ( inout ) :: MAT (:) integer , intent ( inout ) :: NNODS real ( 8 ), allocatable , intent ( inout ) :: CDN_X (:), CDN_Y (:), CDN_Z (:) integer , intent ( inout ) :: NDATA real ( 8 ), allocatable , intent ( inout ) :: VEL_X (:), VEL_Y (:), VEL_Z (:) real ( 8 ), allocatable , intent ( inout ) :: PRES (:) integer ( 4 ) N , NTRY character ( 32 ) main_data_title character ( 32 ) TITLE !> OVerlapStart_nの読み取り read ( unit ) main_data_title !本文データの読み取り ! irecn == 1 なら タイトル内のサブレコードは1つ ! iretn == 1 なら サブレコード内のデータは1つ ! ibyte == 4:int32, 8:real64, 1:char(32 or 80 or 1) ! 本文データにて ibyte = 1となることはなさそう do read ( unit ) TITLE ; print * , TITLE select case ( trim ( TITLE )) case ( 'LS_CoordinateSystem' ) read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , LCORD ) read ( unit ) !0, 0, 0 case ( 'LS_SurfaceGeometryArray' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !NGFAX call ignore_data_ ( unit ) !LLEN call ignore_data_ ( unit ) !LRGNS call ignore_data_ ( unit ) !NBNNS call ignore_data_ ( unit ) !IPTYP call ignore_data_ ( unit ) !IPMAT call ignore_data_ ( unit ) !NTTSS call ignore_data_ ( unit ) !NDFA read ( unit ) !0, 0, 0 case ( 'LS_Elements' ) read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , IETYP , NELEM ) call get_data_int32_ ( unit , NTTE ) call get_data_array_ ( unit , NDNO , NTTE ) !NDNOは0スタートのため, 都合+1する. NDNO ( 1 : NTTE ) = NDNO ( 1 : NTTE ) + 1 read ( unit ) !0, 0, 0 case ( 'LS_MatOfElements' ) read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , MAT , NELEM ) read ( unit ) case ( 'LS_Nodes' ) read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NNODS ) call get_data_array_ ( unit , CDN_X , NNODS ) call get_data_array_ ( unit , CDN_Y , NNODS ) call get_data_array_ ( unit , CDN_Z , NNODS ) read ( unit ) case ( 'LS_VolumeGeometryArray' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !NVORG call ignore_data_ ( unit ) !LLEN call ignore_data_ ( unit ) !LRGNS call ignore_data_ ( unit ) !NELES call ignore_data_ ( unit ) !IELE read ( unit ) case ( 'LS_RegionName&Type' ) call ignore_data_ ( unit ) !LNX call get_data_int32_ ( unit , NTRY ) call ignore_data_ ( unit ) !NLEN do N = 1 , NTRY call ignore_data_ ( unit ) !ITRY call ignore_data_ ( unit ) !MRGN end do read ( unit ) case ( 'LS_SFile' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !NLEN call ignore_data_ ( unit ) !TEXT read ( unit ) !ここを切り分ける. scalar dataは要求するデータのみ探索し, 後は捨てる !一致するもののみよみとり，あとはignoreする. case ( 'LS_Scalar:PRES' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call get_data_int32_ ( unit , NDATA ) !NDATA call get_data_array_ ( unit , PRES , NDATA ) !VAR read ( unit ) case ( 'LS_Scalar:TEMP' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Scalar:TURK' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Scalar:TEPS' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Scalar:EVIS' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Scalar:YPLS' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Scalar:HTRC' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Scalar:USTR' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Vector:VEL' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LVCT call ignore_data_ ( unit ) !LNAM call get_data_int32_ ( unit , NDATA ) !NDATA call get_data_array_ ( unit , VEL_X , NDATA ) call get_data_array_ ( unit , VEL_Y , NDATA ) call get_data_array_ ( unit , VEL_Z , NDATA ) read ( unit ) case ( 'LS_Vector:HVEC' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LVCT call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR call ignore_data_ ( unit ) !VAR call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'OverlapEnd' ) exit case default print * , 'TITLE_ERROR:' , TITLE stop end select end do end subroutine subroutine readFLD_Main_data_2 ( unit , NELEM , IETYP , NTTE , NDNO , MAT , & NNODS , CDN_X , CDN_Y , CDN_Z , & scalars , vectors , scalar_cnt , vector_cnt , topo_included ) !!FLDのメインデータ部分を読み取る. ! !fldが解析スタートファイルでない場合,toporogy情報が含まれない可能性が高い. !したがって, 初期ファイル以外のものを最初に読み取るとトポロジ情報が入手できない． ! implicit none integer , intent ( in ) :: unit integer , intent ( inout ) :: NELEM integer , intent ( inout ) :: NTTE integer , allocatable , intent ( inout ) :: IETYP (:) integer , allocatable , intent ( inout ) :: NDNO (:) integer , allocatable , intent ( inout ) :: MAT (:) integer , intent ( inout ) :: NNODS real ( 8 ), allocatable , intent ( inout ) :: CDN_X (:), CDN_Y (:), CDN_Z (:) type ( LS_Scalar_t ), allocatable , intent ( inout ) :: scalars (:) type ( LS_Vector_t ), allocatable , intent ( inout ) :: vectors (:) integer , intent ( inout ) :: scalar_cnt integer , intent ( inout ) :: vector_cnt logical , intent ( inout ) :: topo_included integer ( 4 ) N , NTRY character ( 32 ) main_data_title character ( 32 ) TITLE !> OVerlapStart_nの読み取り read ( unit ) main_data_title !本文データの読み取り ! irecn == 1 なら タイトル内のサブレコードは1つ ! iretn == 1 なら サブレコード内のデータは1つ ! ibyte == 4:int32, 8:real64, 1:char(32 or 80 or 1) ! 本文データにて ibyte = 1となることはなさそう topo_included = . false . !TITLEは以下の順に並んでいると仮定する. do read ( unit ) TITLE if ( trim ( TITLE ) == 'LS_CoordinateSystem' ) then read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , LCORD ) read ( unit ) !0, 0, 0 else if ( trim ( TITLE ) == 'LS_SurfaceGeometryArray' ) then call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !NGFAX call ignore_data_ ( unit ) !LLEN call ignore_data_ ( unit ) !LRGNS call ignore_data_ ( unit ) !NBNNS call ignore_data_ ( unit ) !IPTYP call ignore_data_ ( unit ) !IPMAT call ignore_data_ ( unit ) !NTTSS call ignore_data_ ( unit ) !NDFA read ( unit ) !0, 0, 0 else if ( trim ( TITLE ) == 'LS_Elements' ) then read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , IETYP , NELEM ) call get_data_int32_ ( unit , NTTE ) call get_data_array_ ( unit , NDNO , NTTE ) !NDNOは0スタートのため, 都合+1する. NDNO ( 1 : NTTE ) = NDNO ( 1 : NTTE ) + 1 read ( unit ) !0, 0, 0 else if ( trim ( TITLE ) == 'LS_MatOfElements' ) then read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , MAT , NELEM ) read ( unit ) else if ( trim ( TITLE ) == 'LS_Nodes' ) then read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NNODS ) call get_data_array_ ( unit , CDN_X , NNODS ) call get_data_array_ ( unit , CDN_Y , NNODS ) call get_data_array_ ( unit , CDN_Z , NNODS ) read ( unit ) !順番的にこれがトポロジー情報の最後とみる. topo_included = . true . !ここでループ抜けすると,LS_Scalar以外の物が前に残っている可能性があるのでNG. ! exit else if ( trim ( TITLE ) == 'LS_VolumeGeometryArray' ) then call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !NVORG call ignore_data_ ( unit ) !LLEN call ignore_data_ ( unit ) !LRGNS call ignore_data_ ( unit ) !NELES call ignore_data_ ( unit ) !IELE read ( unit ) else if ( trim ( TITLE ) == 'LS_RegionName&Type' ) then call ignore_data_ ( unit ) !LNX call get_data_int32_ ( unit , NTRY ) call ignore_data_ ( unit ) !NLEN do N = 1 , NTRY call ignore_data_ ( unit ) !ITRY call ignore_data_ ( unit ) !MRGN end do read ( unit ) else if ( trim ( TITLE ) == 'LS_SFile' ) then call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !NLEN call ignore_data_ ( unit ) !TEXT read ( unit ) !必須データでないらしい. 確実にここでループ抜け出来るとは限らない. ! exit else if ( TITLE ( 1 : 10 ) == \"LS_Scalar:\" ) then !LS_Scalar:以下はループ外で処理するので，1行前に戻ってループ抜けする. backspace ( unit ) exit !もしLS_elementsなどを介せずここに来た場合, トポロジは含まれないと判断. else print * , \"(error) readFLD_main_data_2 :: UnKnown title data was detected. \" , trim ( TITLE ) return end if end do !LS_scalar, LS_vector if (. not . allocated ( scalars )) allocate ( scalars ( LS_Scalar_DataSize )) if (. not . allocated ( vectors )) allocate ( vectors ( LS_Vector_DataSize )) datas_reader : block logical EOR integer s_cnt , v_cnt , i EOR = . false . s_cnt = 0 do while (. not . EOR ) s_cnt = s_cnt + 1 call LS_Scalar_reader ( scalars ( s_cnt ), unit , EOR ) end do scalar_cnt = s_cnt - 1 EOR = . false . v_cnt = 0 do while (. not . EOR ) v_cnt = v_cnt + 1 call LS_Vector_reader ( vectors ( v_cnt ), unit , EOR ) end do vector_cnt = v_cnt - 1 do i = s_cnt , size ( scalars ) scalars ( i )% name = \"NONE\" enddo do i = v_cnt , size ( vectors ) vectors ( i )% name = \"NONE\" enddo ! do i = 1, size(scalars) !     print *, scalars(i)%name !     print *, scalars(i)%abbreviated_name ! enddo ! do i = 1, size(vectors) !     print *, vectors(i)%name !     print *, scalars(i)%abbreviated_name ! enddo end block datas_reader end subroutine !========================================================================== ! LS_Scalar_t !========================================================================== subroutine LS_Scalar_reader ( ls_scalar , unit , is_ended ) !!LS_Scalar:で始まる行のデータ読み取り. implicit none type ( LS_Scalar_t ), intent ( inout ) :: ls_scalar !!LS_Scalar_t 構造体 integer ( 4 ), intent ( in ) :: unit !!装置番号 logical , intent ( out ) :: is_ended !!LS_Scalarの終端かどうか. ! character(:),allocatable,intent(inout) :: LNAME ! integer(4),intent(inout) :: NDATA ! real(8),allocatable,intent(inout) :: VAR(:) character ( 32 ) title is_ended = . false . read ( unit ) title select case ( title ( 1 : 10 )) case ( LS_Scalar_HeadName ) ls_scalar % abbreviated_name = title ( 11 : 14 ) call ignore_data_ ( unit ) call get_data_char_ ( unit , 32 , ls_scalar % name ) call get_data_int32_ ( unit , ls_scalar % ndata ) call get_data_array_ ( unit , ls_scalar % data , ls_scalar % ndata ) read ( unit ) case ( LS_Vector_HeadName ) backspace ( unit ) is_ended = . true . return case ( OverLapEndLabel ) is_ended = . true . return case default print \"('something is wrong. ')\" , trim ( title ( 1 : 10 )) error stop end select end subroutine subroutine LS_Vector_reader ( ls_vector , unit , is_ended ) implicit none type ( LS_Vector_t ), intent ( inout ) :: ls_vector integer ( 4 ), intent ( in ) :: unit logical , intent ( inout ) :: is_ended ! character(:),allocatable,intent(inout) :: LNAME ! integer(4),intent(inout) :: NDATA ! real(8),allocatable,intent(inout) :: VAR(:) character ( 32 ) title is_ended = . false . read ( unit ) title select case ( title ( 1 : 10 )) case ( LS_Vector_HeadName ) ls_vector % abbreviated_name = title ( 11 : 14 ) call ignore_data_ ( unit ) call ignore_data_ ( unit ) call get_data_char_ ( unit , 32 , ls_vector % name ) call get_data_int32_ ( unit , ls_vector % ndata ) call get_data_array_ ( unit , ls_vector % x , ls_vector % ndata ) call get_data_array_ ( unit , ls_vector % y , ls_vector % ndata ) call get_data_array_ ( unit , ls_vector % z , ls_vector % ndata ) read ( unit ) case ( OverLapEndLabel ) is_ended = . true . return case default print \"('something is wrong. ')\" , trim ( title ( 1 : 10 )) error stop end select end subroutine !========================================================================== ! sctregion_t !========================================================================== !> sctregion_tクラスのメソッド subroutine get_sctregion_data_ ( this , unit , n_length ) implicit none class ( sctregion_t ), intent ( inout ) :: this integer ( 4 ), intent ( in ) :: unit , n_length call get_data_char_ ( unit , n_length , this % LRGN ) call get_data_int32_ ( unit , this % NE ) call get_data_array_ ( unit , this % IE , this % NE ) call get_data_array_ ( unit , this % IFA , this % NE ) !要素番号, ローカル面番号は全て1スタートに揃える. 従って体積領域は0番. this % IE ( 1 : this % NE ) = this % IE ( 1 : this % NE ) + 1 this % IFA ( 1 : this % NE ) = this % IFA ( 1 : this % NE ) + 1 end subroutine subroutine extract_region_surface_ ( this , celltypes , cell2vertices , face2vert_on_region ) !! regionを構成する頂点番号の抜き出し. 体積領域はスルー. !! したがってregionの面-頂点関係が取得できる. implicit none class ( sctregion_t ), intent ( in ) :: this integer , intent ( in ) :: celltypes (:) integer , intent ( in ) :: cell2vertices (:,:) !!セル-頂点関係の配列. オリジナルのものでなければならない. integer , allocatable , intent ( inout ) :: face2vert_on_region (:,:) integer i , nv , cell , face integer , dimension (:,:), pointer :: SCTElementFacesDef if ( all ( this % IFA == 0 )) then print * , \"this region :\" // trim ( this % LRGN ) // \" is not a surface region.\" return endif if ( allocated ( face2vert_on_region )) deallocate ( face2vert_on_region ) allocate ( face2vert_on_region ( 1 : 8 , this % NE ), source = - 1 ) do i = 1 , this % NE cell = this % IE ( i ) face = this % IFA ( i ) select case ( celltypes ( cell )) case ( 34 ) SCTElementFacesDef => SCTTetraFaces_ case ( 35 ) SCTElementFacesDef => SCTPyramidFaces_ case ( 36 ) SCTElementFacesDef => SCTPrismFaces_ case ( 38 ) SCTElementFacesDef => SCTHexahedronFaces_ case default print * , \"sctregion_t :: not implemented celltype.\" , celltypes ( cell ) error stop end select nv = SCTElementFacesDef ( 1 , face ) face2vert_on_region ( 1 : nv , i ) = cell2vertices ( SCTElementFacesDef ( 2 : nv + 1 , face ), cell ) end do end subroutine !========================================================================== ! data_reader !========================================================================== !> 整数型データを読みこみ格納 subroutine get_data_int32_ ( unit , retval ) implicit none integer ( 4 ), intent ( in ) :: unit integer ( 4 ), intent ( out ) :: retval integer ( 4 ) ibyte , iretn , irecn read ( unit ) ibyte , iretn , irecn read ( unit ) retval end subroutine !> 整数型配列の読み込み subroutine get_data_array_int32_ ( unit , ret_array , ret_array_size ) implicit none integer ( 4 ), intent ( in ) :: unit integer ( 4 ), allocatable , intent ( out ) :: ret_array (:) integer ( 4 ), intent ( in ) :: ret_array_size integer ( 4 ) ibyte , iretn , irecn integer ( 4 ) irec , L , ios integer ( 4 ) subrecn read ( unit ) ibyte , iretn , irecn subrecn = irecn - 1 if (. not . allocated ( ret_array )) allocate ( ret_array ( ret_array_size )) if ( subrecn == 0 ) then read ( unit , iostat = ios ) ( ret_array ( L ), L = 1 , irecn * iretn ) return else do irec = 1 , subrecn read ( unit , iostat = ios ) ( ret_array ( L ), L = 1 + ( irec - 1 ) * iretn , irec * iretn ) if ( ios /= 0 ) then ! print*,'iostat: ', ios, 'at L=', L exit end if end do read ( unit ) ( ret_array ( L ), L = 1 + ( irecn - 1 ) * iretn , ret_array_size ) endif end subroutine !> 倍精度実数型配列の読み込み subroutine get_data_array_float64_ ( unit , ret_array , ret_array_size ) implicit none integer ( 4 ), intent ( in ) :: unit real ( 8 ), allocatable , intent ( out ) :: ret_array (:) integer ( 4 ), intent ( in ) :: ret_array_size integer ( 4 ) ibyte , iretn , irecn integer ( 4 ) irec , L , ios integer ( 4 ) subrecn read ( unit ) ibyte , iretn , irecn subrecn = irecn - 1 if (. not . allocated ( ret_array )) allocate ( ret_array ( ret_array_size )) if ( subrecn == 0 ) then read ( unit , iostat = ios ) ( ret_array ( L ), L = 1 , irecn * iretn ) return else do irec = 1 , subrecn read ( unit , iostat = ios ) ( ret_array ( L ), L = 1 + ( irec - 1 ) * iretn , irec * iretn ) if ( ios /= 0 ) then ! print*,'iostat: ', ios, 'at L=', L exit end if end do read ( unit ) ( ret_array ( L ), L = 1 + ( irecn - 1 ) * iretn , ret_array_size ) endif end subroutine !> データを読み飛ばす処理 subroutine ignore_data_ ( unit ) implicit none integer ( 4 ), intent ( in ) :: unit integer ( 4 ) ibyte , iretn , irecn integer ( 4 ) irec read ( unit ) ibyte , iretn , irecn do irec = 1 , irecn read ( unit ) end do end subroutine !> 文字列（バイト数指定） subroutine get_data_char_ ( unit , byte , ret_char ) implicit none integer ( 4 ), intent ( in ) :: unit integer ( 4 ), intent ( in ) :: byte character (:), allocatable , intent ( inout ) :: ret_char if (. not . allocated ( ret_char )) allocate ( character ( byte ) :: ret_char ) read ( unit ) read ( unit ) ret_char end subroutine end module SCT_file_reader_m","tags":"","loc":"sourcefile/sctfile_reader.f90.html"},{"title":"geometry_test.f90 – Droplets Simulation","text":"This file depends on sourcefile~~geometry_test.f90~~EfferentGraph sourcefile~geometry_test.f90 geometry_test.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~geometry_test.f90->sourcefile~geometry.f90 sourcefile~vector.f90 vector.f90 sourcefile~geometry.f90->sourcefile~vector.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs geometry_test Source Code geometry_test.f90 Source Code !>テトラ内外判定をテストする。 !>乱数で発生させた点群に対して判定を行う。 !>テスト用のテトラは単純な形状で、平面の方程式から即座に内外判定が行えるので、これと比較してテストする。 program geometry_test use geometry_m implicit none !テスト用テトラ real , parameter :: tetra ( 3 , 4 ) = reshape ([& 0. , 0. , 0. , & 1. , 0. , 0. , & 0. , 1. , 0. , & 0. , 0. , 1. & ], shape ( tetra )) integer , parameter :: imax = 10000 real rand ( 3 , imax ), point ( 3 ) logical plane_judge , tetra_judge integer i call random_number ( rand ) do i = 1 , imax point = rand (:, i ) plane_judge = ( point ( 3 ) < plane_equation ( point ( 1 ), point ( 2 ))) !z座標が斜面より下であればテトラ内部 tetra_judge = insideJudgment_tetra ( tetra , point (:)) if (( plane_judge . neqv . tetra_judge )) then !テトラの斜面の方程式による内外判定と、テトラの一般的な内外判定の結果が一致しなければエラー print * , i , point , plane_judge , tetra_judge error stop end if end do contains !>テスト用テトラの斜面の方程式 function plane_equation ( x , y ) result ( z ) real , intent ( in ) :: x , y real z z = 1. - x - y end function end program geometry_test","tags":"","loc":"sourcefile/geometry_test.f90.html"},{"title":"kdTree_test.f90 – Droplets Simulation","text":"This file depends on sourcefile~~kdtree_test.f90~~EfferentGraph sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~kdtree_test.f90->sourcefile~path_operator.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~kdtree_test.f90->sourcefile~kdtree.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~unstructuredgrid.f90->sourcefile~filename_mod.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~array.f90 array.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~vector.f90 vector.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs kdTree_test Source Code kdTree_test.f90 Source Code program kdTree_test !!kdTreeによる探索結果と、厳密なnearest探索結果が一致するかどうかをテスト use kdTree_m use path_operator_m use unstructuredGrid_m implicit none type ( FlowFieldUnstructuredGrid ) grid real , allocatable :: xyz (:,:) type ( kdTree ) kd_tree ! integer n_unit integer iimx character (:), allocatable :: vtkFName , kd_treeFName character ( 10 ), parameter :: output_dir = 'test_check' logical existance vtkFName = \"VTK/sample.vtk\" kd_treeFName = \"kdTreeOfsample.txt\" call make_directory ( output_dir ) call grid % setupWithFlowFieldFile ( vtkFName ) iimx = grid % get_info ( 'cell' ) xyz = grid % get_allOfCellCenters () inquire ( file = output_dir // '/' // kd_treeFName , exist = existance ) if (. not . existance ) then kd_tree = kdTree_ ( xyz ) call kd_tree % saveAsDOT ( xyz , output_dir // '/kdTree.dot' ) call kd_tree % saveAsTXT ( output_dir // '/' // kd_treeFName ) else call kd_tree % read_kdTree ( output_dir // '/' // kd_treeFName ) end if call test contains subroutine test !!乱数で発生させた点に対して、kdTreeによる探索結果と、厳密なnearest探索結果が一致するかどうかをテスト integer , parameter :: num_test = 10000 integer n integer result_exact , result_kdTree real , dimension ( 3 ) :: min_cdn , max_cdn , delta , rand , point call grid % get_MinMaxOfGrid ( min_cdn , max_cdn ) delta = max_cdn - min_cdn do n = 1 , num_test call random_number ( rand ) point = min_cdn + delta * rand ! print*, point result_exact = grid % nearest_search_exact ( point ) call kd_tree % search ( xyz , point , result_kdTree ) if ( result_exact /= result_kdTree ) then print * , point print * , result_exact , xyz (:, result_exact ) print * , result_kdTree , xyz (:, result_kdTree ) error stop end if end do end subroutine end program kdTree_test","tags":"","loc":"sourcefile/kdtree_test.f90.html"},{"title":"cellCenterCalc_test.f90 – Droplets Simulation","text":"This file depends on sourcefile~~cellcentercalc_test.f90~~EfferentGraph sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~cellcentercalc_test.f90->sourcefile~geometry.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~array.f90 array.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~filename_mod.f90 filename_mod.f90 sourcefile~unstructuredgrid.f90->sourcefile~filename_mod.f90 sourcefile~vector.f90 vector.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~geometry.f90->sourcefile~vector.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs cellCenterCalc_test Source Code cellCenterCalc_test.f90 Source Code !>セル重心計算がうまく行っているかをテストする。 !>具体的には、重心をテトラの内外判定にかけている。 program cellCenterCalc_test use unstructuredGrid_m use geometry_m implicit none type ( FlowFieldUnstructuredGrid ) grid ! character(17), parameter :: cellCenterFName = 'CellCenters.array' real , allocatable :: centers (:,:), vertices (:,:) real center ( 3 ) integer i , imax integer n call grid % setupWithFlowFieldFile ( 'VTK/sax_flow.vtk' ) !このサブルーチン内で重心計算も行われる imax = grid % get_info ( 'cell' ) centers = grid % get_allOfCellCenters () do i = 1 , imax vertices = grid % get_cellVerticesOf ( i ) center = centers (:, i ) !重心がテトラ内部になければエラー if (. not . insideJudgment_tetra ( vertices , center )) then print '(\"============================\")' block real vol_sum , volume call insideJudgment_tetra_check ( vertices , center , vol_sum , volume ) print * , vol_sum , volume end block print '(\"============================\")' print * , i , imax print '(\"============================\")' do n = 1 , size ( vertices , dim = 2 ) print * , vertices (:, n ) end do print '(\"============================\")' print * , center print '(\"============================\")' error stop end if end do ! contains ! subroutine output_cellCenter(dir) !     use array_m !     character(*), intent(in) :: dir !     real, allocatable :: centers(:,:) !     integer num_cell !     num_cell = grid%get_info('cell') !     centers = grid%get_cellCenters() !     call output_2dArray_asBinary(dir//cellCenterFName, centers) ! end subroutine end program cellCenterCalc_test","tags":"","loc":"sourcefile/cellcentercalc_test.f90.html"},{"title":"sort_test.f90 – Droplets Simulation","text":"This file depends on sourcefile~~sort_test.f90~~EfferentGraph sourcefile~sort_test.f90 sort_test.f90 sourcefile~array.f90 array.f90 sourcefile~sort_test.f90->sourcefile~array.f90 sourcefile~sort.f90 sort.f90 sourcefile~sort_test.f90->sourcefile~sort.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs sort_test Source Code sort_test.f90 Source Code !>ヒープソートの機能テスト program sort_test use sort_m use array_m implicit none real , parameter :: test1 ( 10 ) = [ - 9.0 , - 1.0 , 0.0 , 3.0 , 5.0 , 7.2 , 1 4.4 , 9 9.9 , 12 2.5 , 25 5.0 ] real , parameter :: test2 ( 11 ) = [ - 9 9.0 , - 9.0 , - 1.0 , 0.0 , 3.0 , 5.0 , 7.2 , 1 4.4 , 9 9.9 , 12 2.5 , 25 5.0 ] real test3 ( 10000 ) call testing ( test1 ) print '(\"==============================================================\")' call testing ( test2 ) print '(\"==============================================================\")' block integer i real rand !配列を乱数で生成 test3 ( 1 ) = 0. do i = 2 , size ( test3 ) call random_number ( rand ) test3 ( i ) = test3 ( i - 1 ) + rand end do end block call testing ( test3 ) contains subroutine testing ( array_correct ) real , intent ( in ) :: array_correct (:) real tmp ( size ( array_correct )) type ( content_t ) array ( size ( array_correct )), array_sorted ( size ( array_correct )) integer i tmp = FisherYates_shuffle ( array_correct ) ! print *, tmp array = real2content ( tmp ) call heap_sort ( array , array_sorted ) ! ひとつでも違う要素があればテスト失敗 if (. not . all ( array_sorted (:)% value == array_correct )) then do i = 1 , size ( array_sorted ) print '(2(i6, x, f20.16, 4x, \"|\"))' , & array ( i )% originID , array ( i )% value , & array_sorted ( i )% originID , array_sorted ( i )% value end do error stop end if end subroutine end program sort_test","tags":"","loc":"sourcefile/sort_test.f90.html"},{"title":"Read Me – Droplets Simulation","text":"Droplets Simulation Simulation of Virus-Laden Droplets Behavior in AFDET ドキュメント https://enehentaro.github.io/droplets_simulation/ ※ FORD を使用しています 使い方 依存関係解決・コンパイル ビルドに cmake コマンドを使います（ CMakeのインストール が必要）。 $ source build.sh でビルド・CTest・パス通しまで出来る(コンパイル手法を変える場合は各自で編集) $ MAIN で実行 build.sh を使わない場合（Windowsだとそもそもシェルスクリプト使えないかも） $ mkdir build でビルドディレクトリ作成 $ cd build で移動 $ cmake .. で依存関係解決 一部の環境(Windows等)では、 -G \"MinGW Makefiles\" でGenerator指定 -D CMAKE_Fortran_COMPILER=[ifort/gfortran] でコンパイラ指定 -D CMAKE_BUILD_TYPE=debug でデバッグ用コンパイルオプション付与 $ make でコンパイル 実行 ルートディレクトリ（README.mdのあるディレクトリ）での作業 「SampleCase」ディレクトリを複製したのち、名前を変更する（ケース名を付ける） ケースディレクトリ内の条件ファイル(condition.nml, initial_position.csv)を編集 ./build/bin/main で実行。ケース名を入力して計算開始。 条件ファイル(condition.nml, initial_position.csv)解説 condition.nml リスタート位置 num_restart 通常は 0 を指定 1以上 にすると、その値に対応するbackupファイルが読み込まれ、そこからリスタートが始まる 初期分布ファイル名 initialDistributionFName 指定したbackupファイル(.bu)が読み込まれ、それを飛沫初期分布とする 初期分布を固定したくない場合はコメントアウトすること 飛沫周期発生 periodicGeneration 1秒当たりの発生飛沫数（整数）を指定 初期配置飛沫をすべてNonActiveにしたのち、順次Activateしていくので、初期配置数が飛沫数の上限となる 気流データファイル名 path2FlowFile 実行ディレクトリからの相対パス、もしくは絶対パスを指定 現在可能な流れ場ファイル： VTK INP FLD CUBE格子(PLOT3D)は、予め非構造格子に変換してから計算してください。 .arrayファイルを指定する場合、別途メッシュファイルが必要なので、 meshFile = *** と指定する ステップ数オフセット OFFSET 飛沫計算を、流体連番ファイルの途中の番号から始めたいときに指定 気流データを周期的に用いる場合の先頭と末尾 LoopHead, LoopTail 任意の区間の流体連番ファイルを繰り返し用いるときに指定（例えば呼吸のサイクル） (先頭) = (末尾) とすると、そのステップ数到達後は流れ場の更新が起こらなくなる (先頭) > (末尾) とすれば、特殊な処理は起こらず、流体連番ファイルが順番に読み込まれる initial_position.csv 初期飛沫の配置帯（直方体）を設定する 左から順に、直方体の中心座標(x,y,z), 直方体の幅(x,y,z) 改行すれば配置帯を複数設定できる 方程式 飛沫の蒸発方程式 プログラム内では、２次精度ルンゲクッタ法で解いている。 飛沫の運動方程式 プログラム内では、上式を無次元化・離散化した次式を解いている。 サブプログラム CUBE2USG CUBE格子を、非構造格子に変換できる droplet2CSV 飛沫計算結果を再度読み込み、統計データ（浮遊数推移など）をCSVファイルに書き出す dropletCount 飛沫計算結果を再度読み込み、カウントボックスを通過した飛沫数を調べる。optionディレクトリ内の\"boxList.csv\"を、ケースディレクトリに配置する必要がある。 initialTranslate 飛沫の初期配置データを読み込み、任意の座標への回転、平行移動を行う。 by Konishi おまけ機能 複数ケース連続実行 実行時にTXTファイル名を入力すると、そのファイルに列挙された複数ケースを連続実行できる basicSetting.nml optionディレクトリ内にある。付着判定のオンオフや、飛沫間合体の設定が可能。初期半径分布ファイルの指定も可能。 CTest コンパイル後、 $ ctest でCTestが実行可能（buildディレクトリにて） CTestの実行ディレクトリは、 test/ になる（buildディレクトリではない） テスト用プログラムはすべて test/ で管理しよう","tags":"","loc":"page/index.html"}]}