var tipuesearch = {"pages":[{"title":" Droplets Simulation ","text":"Droplets Simulation ウイルス飛沫を飛ばそう。 Warning Work in progress 概要 流れ場のもとで、飛沫の蒸発方程式と運動方程式を解く。 Note がんばってます。 Todo kd-treeの導入 Bug バグあると思うけど今のところ顕在化してない Developer Info Y.Ida","tags":"home","loc":"index.html"},{"title":"boxResult_t – Droplets Simulation ","text":"type :: boxResult_t Contents Variables flowVelocity Components Type Visibility Attributes Name Initial real, public :: flowVelocity (3)","tags":"","loc":"type\\boxresult_t.html"},{"title":"boxResult_t – Droplets Simulation ","text":"type :: boxResult_t Contents Variables num_droplet volume RoI Components Type Visibility Attributes Name Initial integer, public :: num_droplet real, public :: volume real, public :: RoI","tags":"","loc":"type\\boxresult_t~2.html"},{"title":"boxCounter – Droplets Simulation ","text":"type, public :: boxCounter Contents Variables center width min_cdn max_cdn Flag add_Flag get_FlagID Components Type Visibility Attributes Name Initial real, public :: center (3) real, public :: width (3) real, public :: min_cdn (3) real, public :: max_cdn (3) logical, public, allocatable :: Flag (:) procedure, public :: add_Flag procedure, public :: get_FlagID","tags":"","loc":"type\\boxcounter.html"},{"title":"conditionValue_t – Droplets Simulation ","text":"type, public :: conditionValue_t 条件値クラス\n条件指定ファイル（namelist）を読み込んだ結果を格納する\n飛沫計算用の諸条件をまとめた構造体 Contents Variables dt L U direction_g initialDistributionFName restart stepEnd outputInterval num_drop periodicGeneration T RH path2FlowFile meshFile DT_FLOW OFFSET INTERVAL_FLOW LoopHead LoopTail isInitialDistributionSpecified isMeshFileSpecified Components Type Visibility Attributes Name Initial double precision, public :: dt double precision, public :: L double precision, public :: U double precision, public :: direction_g (3) character, public, allocatable :: initialDistributionFName integer, public :: restart integer, public :: stepEnd integer, public :: outputInterval integer, public :: num_drop integer, public :: periodicGeneration real, public :: T real, public :: RH character, public, allocatable :: path2FlowFile character, public, allocatable :: meshFile double precision, public :: DT_FLOW integer, public :: OFFSET integer, public :: INTERVAL_FLOW integer, public :: LoopHead integer, public :: LoopTail procedure, public :: isInitialDistributionSpecified 飛沫初期分布ファイルが指定されたか否かを返す procedure, public :: isMeshFileSpecified メッシュファイルが別途指定されたか否かを返す","tags":"","loc":"type\\conditionvalue_t.html"},{"title":"BasicParameter – Droplets Simulation ","text":"type, public :: BasicParameter 基礎変数クラス\n時間間隔や代表値を格納 Inherited by type~~basicparameter~~InheritedByGraph type~basicparameter BasicParameter type~dropletequationsolver DropletEquationSolver type~dropletequationsolver->type~basicparameter type~dropletgenerator DropletGenerator type~dropletgenerator->type~dropletequationsolver equation Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dt L U Re TimeStep2RealTime Type-Bound Procedures repValue Components Type Visibility Attributes Name Initial double precision, public :: dt double precision, public :: L double precision, public :: U double precision, public :: Re procedure, public :: TimeStep2RealTime Type-Bound Procedures procedure, public :: repValue => representativeValue private function representativeValue(self, name) Arguments Type Intent Optional Attributes Name class( BasicParameter ) :: self character, intent(in) :: name Return Value doubleprecision","tags":"","loc":"type\\basicparameter.html"},{"title":"DropletEquationSolver – Droplets Simulation ","text":"type, public, extends( BasicParameter ) :: DropletEquationSolver 飛沫方程式ソルバクラス\n蒸発方程式や運動方程式を解くメソッドを保持 Inherits type~~dropletequationsolver~~InheritsGraph type~dropletequationsolver DropletEquationSolver type~basicparameter BasicParameter type~dropletequationsolver->type~basicparameter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~dropletequationsolver~~InheritedByGraph type~dropletequationsolver DropletEquationSolver type~dropletgenerator DropletGenerator type~dropletgenerator->type~dropletequationsolver equation Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables dt L U Re TimeStep2RealTime coeff_drdt G T RH minimumRadiusRatio minimumRadiusMatrix set_gravity_acceleration set_dropletEnvironment dropletEnvironment set_coeff_drdt set_minimumRadiusRatio next_position next_velocity get_radiusLowerLimitRatio solve_motionEquation Type-Bound Procedures repValue evaporationEq Components Type Visibility Attributes Name Initial double precision, public :: dt double precision, public :: L double precision, public :: U double precision, public :: Re procedure, public :: TimeStep2RealTime double precision, public :: coeff_drdt 半径変化率の無次元係数 double precision, public :: G (3) 無次元重力加速度 real, public :: T real, public :: RH double precision, public :: minimumRadiusRatio double precision, public, allocatable :: minimumRadiusMatrix (:,:) procedure, public :: set_gravity_acceleration procedure, public :: set_dropletEnvironment procedure, public :: dropletEnvironment procedure, public :: set_coeff_drdt procedure, public :: set_minimumRadiusRatio procedure, public :: next_position procedure, public :: next_velocity procedure, public :: get_radiusLowerLimitRatio procedure, public :: solve_motionEquation Type-Bound Procedures procedure, public :: repValue => representativeValue private function representativeValue(self, name) Arguments Type Intent Optional Attributes Name class( BasicParameter ) :: self character, intent(in) :: name Return Value doubleprecision procedure, public :: evaporationEq => evaporationEquation private function evaporationEquation(self, radius) result(dr) 蒸発方程式。半径変化量を返す。 Arguments Type Intent Optional Attributes Name class( DropletEquationSolver ) :: self double precision, intent(in) :: radius Return Value double precision","tags":"","loc":"type\\dropletequationsolver.html"},{"title":"SequentialArray – Droplets Simulation ","text":"type, public :: SequentialArray Inherited by type~~sequentialarray~~InheritedByGraph type~sequentialarray SequentialArray type~dropletgenerator DropletGenerator type~dropletgenerator->type~sequentialarray initialRadiusArray, deadlineArray Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables set_SequentialArray Type-Bound Procedures get_value get_valueArray Components Type Visibility Attributes Name Initial procedure, public :: set_SequentialArray Type-Bound Procedures procedure, public :: get_value => get_valueFromSequentialArray private function get_valueFromSequentialArray(self) Arguments Type Intent Optional Attributes Name class( SequentialArray ) :: self Return Value real procedure, public :: get_valueArray => get_valueArrayFromSequentialArray private function get_valueArrayFromSequentialArray(self, arraySize) result(array) Arguments Type Intent Optional Attributes Name class( SequentialArray ) :: self integer, intent(in) :: arraySize Return Value real,allocatable, (:)","tags":"","loc":"type\\sequentialarray.html"},{"title":"DropletGenerator – Droplets Simulation ","text":"type, public :: DropletGenerator Inherits type~~dropletgenerator~~InheritsGraph type~dropletgenerator DropletGenerator type~dropletequationsolver DropletEquationSolver type~dropletgenerator->type~dropletequationsolver equation type~placementbox placementBox type~dropletgenerator->type~placementbox pBox_array type~sequentialarray SequentialArray type~dropletgenerator->type~sequentialarray initialRadiusArray, deadlineArray type~basicparameter BasicParameter type~dropletequationsolver->type~basicparameter Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables equation pBox_array initialRadiusArray deadlineArray generateRate set_dropletPlacementBox calc_initialPosition Type-Bound Procedures generateDroplet periodicGeneration Components Type Visibility Attributes Name Initial type( DropletEquationSolver ), public, pointer :: equation type(placementBox), public, allocatable :: pBox_array (:) type( SequentialArray ), public :: initialRadiusArray type( SequentialArray ), public :: deadlineArray integer, public :: generateRate = 0 procedure, public :: set_dropletPlacementBox procedure, public :: calc_initialPosition Type-Bound Procedures procedure, public :: generateDroplet private function generateDroplet(self, num_droplet, nowTime) result(droplets) Arguments Type Intent Optional Attributes Name class( DropletGenerator ) :: self integer, intent(in) :: num_droplet double precision, intent(in) :: nowTime Return Value type( virusDroplet_t ),allocatable, (:) procedure, public :: periodicGeneration => dropletPeriodicGeneration private subroutine dropletPeriodicGeneration(self, droplets, nowTime, stat) Arguments Type Intent Optional Attributes Name class( DropletGenerator ) :: self type( virusDroplet_t ), intent(inout) :: droplets (:) double precision, intent(in) :: nowTime logical, intent(out) :: stat","tags":"","loc":"type\\dropletgenerator.html"},{"title":"FlowField – Droplets Simulation ","text":"type, public, extends( FlowFieldUnstructuredGrid ) :: FlowField Inherits type~~flowfield~~InheritsGraph type~flowfield FlowField type~flowfieldunstructuredgrid FlowFieldUnstructuredGrid type~flowfield->type~flowfieldunstructuredgrid type~node_t node_t type~flowfieldunstructuredgrid->type~node_t NODEs type~boundarytriangle_t boundaryTriangle_t type~flowfieldunstructuredgrid->type~boundarytriangle_t BoundFACEs, FACEs type~kdtree kdTree type~flowfieldunstructuredgrid->type~kdtree kd_tree type~cell_inflow_t cell_inFlow_t type~flowfieldunstructuredgrid->type~cell_inflow_t CELLs type~node_in_kdtree_t node_in_kdTree_t type~kdtree->type~node_in_kdtree_t node type~cell_t cell_t type~cell_inflow_t->type~cell_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables NODEs CELLs BoundFACEs FACEs kd_tree MIN_CDN MAX_CDN num_refCellSearchFalse num_refCellSearch fph_flag set_cellCenter set_cellThreshold set_MinMaxCDN point2cellVelocity nearer_cell AdjacencySolvingProcess read_adjacency read_boundaries solve_adjacencyOnFlowFieldUnstructuredGrid output_boundaries output_adjacency boundary_setting output_STL read_cell2face INTERVAL LoopHead LoopTail OFFSET DT STEP NextUpdate FullFileName FileNameFormat set_FileNameFormat calc_NextUpdate get_FileNumber clamp_STEP Type-Bound Procedures nearcell_check nearest_cell nearest_search_kdTree nearest_search_exact get_movementVectorOfBoundarySurface get_flowVelocityInCELL get_allOfCellCenters get_cellCenterOf get_MinMaxOfGrid get_cellVerticesOf get_info read_FPH read_FLD read_INP read_array read_VTK updateWithFlowFieldFile setupWithFlowFieldFile search_refCELL adhesionCheckOnBound get_nearerSearchFalseRate get_num_nearerSearchFalse update isUpdateTiming get_defaultFlowFileName set_time get_requiredFileName Components Type Visibility Attributes Name Initial type( node_t ), public, allocatable :: NODEs (:) 節点配列 type(cell_inFlow_t), public, allocatable :: CELLs (:) セル配列 type(boundaryTriangle_t), public, allocatable :: BoundFACEs (:) 境界面配列 type(boundaryTriangle_t), public, allocatable :: FACEs (:) type( kdTree ), public :: kd_tree kd-tree（近傍セル探索用） real, public :: MIN_CDN (3) 座標の最小値(xyz) real, public :: MAX_CDN (3) 座標の最大値(xyz) integer, public :: num_refCellSearchFalse = 0 参照セル探索結果が悪いと判断された回数 integer, public :: num_refCellSearch = 0 参照セル探索が行われた回数 logical, public :: fph_flag = .false. procedure, public :: set_cellCenter procedure, public :: set_cellThreshold procedure, public :: set_MinMaxCDN procedure, public :: point2cellVelocity procedure, public :: nearer_cell procedure, public :: AdjacencySolvingProcess procedure, public :: read_adjacency procedure, public :: read_boundaries procedure, public :: solve_adjacencyOnFlowFieldUnstructuredGrid procedure, public :: output_boundaries procedure, public :: output_adjacency procedure, public :: boundary_setting procedure, public :: output_STL procedure, public :: read_cell2face integer, public :: INTERVAL 気流ファイル出力間隔 integer, public :: LoopHead 流れ場ファイルのループの先頭 integer, public :: LoopTail 流れ場ファイルのループの末尾 integer, public :: OFFSET 流れ場と飛沫の間の時間ステップオフセット double precision, public :: DT 流体計算の時間間隔 integer, public :: STEP 時間ステップ integer, public :: NextUpdate 次に流れ場更新を行うべき時間ステップ character, public, allocatable :: FullFileName デフォルトの流れ場ファイル名 character, public, allocatable :: FileNameFormat 流れ場ファイルのファイル名のフォーマット文字列 procedure, public :: set_FileNameFormat procedure, public :: calc_NextUpdate procedure, public :: get_FileNumber procedure, public :: clamp_STEP Type-Bound Procedures procedure, public :: nearcell_check private function nearcell_check(self, X, NCN) result(isNear) 近傍セル探索の結果が妥当かどうかをチェック Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self real, intent(in) :: X (3) 探索対象座標 integer, intent(in) :: NCN 近傍探索結果セルID Return Value logical procedure, public :: nearest_cell private function nearest_cell(self, X) result(nearestCellID) 最近傍セル探索 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self real, intent(in) :: X (3) 探索対象座標 Return Value integer Note 厳密探索かkdツリー探索かはここで切り替える procedure, public :: nearest_search_kdTree private function nearest_search_kdTree(self, X) result(nearestCellID) kdツリーによる最近傍セル探索 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self real, intent(in) :: X (3) 探索対象座標 Return Value integer procedure, public :: nearest_search_exact private function nearest_search_exact(self, X) result(nearestCellID) 厳密最近傍セル探索 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self real, intent(in) :: X (3) 探索対象座標 Return Value integer procedure, public :: get_movementVectorOfBoundarySurface private function get_movementVectorOfBoundarySurface(self, ID) result(vector) 指定IDにおける境界面の移動量ベクトルを返す Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real(3) procedure, public :: get_flowVelocityInCELL private function get_flowVelocityInCELL(self, ID) result(velocity) 指定IDにおけるセルの流速を返す Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real(3) procedure, public :: get_allOfCellCenters private function get_allOfCellCenters(self) result(centers) 全セルの重心座標を２次元配列で返す Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self Return Value real,allocatable, (:,:) procedure, public :: get_cellCenterOf private function get_cellCenterOf(self, ID) result(center) 指定IDにおけるセル重心 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real(3) procedure, public :: get_MinMaxOfGrid private subroutine get_MinMaxOfGrid(self, MIN_CDN, MAX_CDN) 節点群の座標最大最小を返す Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self real, intent(out) :: MIN_CDN (3) real, intent(out) :: MAX_CDN (3) procedure, public :: get_cellVerticesOf private function get_cellVerticesOf(self, ID) result(vertices) 指定IDのセルにおける頂点座標配列を返す\n２次元配列：（xyz、頂点） Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real,allocatable, (:,:) procedure, public :: get_info => get_gridInformation private function get_gridInformation(self, name) result(info) 節点数もしくはセル数を取得 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self character, intent(in) :: name 'node' or 'cell' Return Value integer procedure, public :: read_FPH private subroutine read_FPH(self, FNAME, findTopology, findVelocity) FPHファイルから流れ場を取得する Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME ファイル名 logical, intent(in) :: findTopology トポロジー情報を取得するフラグ logical, intent(in) :: findVelocity 流速情報を取得するフラグ procedure, public :: read_FLD private subroutine read_FLD(self, FNAME, findTopology, findVelocity) FLDファイルから流れ場を取得する Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME ファイル名 logical, intent(in) :: findTopology トポロジー情報を取得するフラグ logical, intent(in) :: findVelocity 流速情報を取得するフラグ procedure, public :: read_INP private subroutine read_INP(self, FNAME) INPファイルを読み込み、節点データを要素データに変換する Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME procedure, public :: read_array => read_Array private subroutine read_Array(self, FNAME) 独自フォーマットArrayファイルから、流速を読み込む Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME procedure, public :: read_VTK private subroutine read_VTK(self, FNAME, meshOnly) VTKファイルから流れ場を取得する Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME ファイル名 logical, intent(in) :: meshOnly メッシュだけ読み込み、流速などは無視するフラグ procedure, public :: updateWithFlowFieldFile private subroutine updateWithFlowFieldFile(self, FNAME) 流れ場ファイルを読み込み、流れ場を更新する\nあくまで既存の流れ場の更新目的であり、セル数の異なるメッシュは想定していない\nセル重心の算出も行う Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME procedure, public :: setupWithFlowFieldFile private subroutine setupWithFlowFieldFile(self, FNAME, meshFile) 流れ場ファイルの読み込み\nVTK, INP, FLDに対応\n独自フォーマットのArrayにも対応\nセル重心の算出も行う Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME character, intent(in), optional :: meshFile procedure, public :: search_refCELL private subroutine search_refCELL(self, X, reference_cell, stat) 参照セル探索\n主に近傍探索が呼ばれるが、探索が芳しくない場合は最近傍探索が呼ばれる Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self real, intent(in) :: X (3) 探索対象座標 integer, intent(inout) :: reference_cell 参照セル logical, optional :: stat procedure, public :: adhesionCheckOnBound private subroutine adhesionCheckOnBound(self, position, radius, cellID, stat) 境界面への飛沫付着判定 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self double precision, intent(in) :: position (3) 飛沫座標 double precision, intent(in) :: radius 飛沫半径 integer, intent(in) :: cellID 判定対象セルID integer, intent(out) :: stat 付着が起こらなければゼロ、起これば付着面の境界面IDが返る procedure, public :: get_nearerSearchFalseRate private function get_nearerSearchFalseRate(self) result(num_nearerSearchFalseRate) 近傍セル探索の結果が悪いと判断された比率を返す Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self Return Value real procedure, public :: get_num_nearerSearchFalse private function get_num_nearerSearchFalse(self) result(num_nearerSearchFalse) 近傍セル探索の結果が悪いと判断された回数を返す Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self Return Value integer procedure, public :: update => update_FlowField private subroutine update_FlowField(self) 流れ場を更新する Arguments Type Intent Optional Attributes Name class( FlowField ) :: self procedure, public :: isUpdateTiming private function isUpdateTiming(self) 現在ステップが流れ場更新のタイミングかどうかを判定 Arguments Type Intent Optional Attributes Name class( FlowField ) :: self Return Value logical procedure, public :: get_defaultFlowFileName private function get_defaultFlowFileName(self) result(fname) デフォルトの流れ場ファイル名を返す Arguments Type Intent Optional Attributes Name class( FlowField ) :: self Return Value character,allocatable procedure, public :: set_time => set_timeSTEPinFLOW private subroutine set_timeSTEPinFLOW(self, time) 流れ場に現在時刻を通知 Arguments Type Intent Optional Attributes Name class( FlowField ) :: self double precision, intent(in) :: time 飛沫計算における時刻 procedure, public :: get_requiredFileName => get_requiredFlowFieldFileName private function get_requiredFlowFieldFileName(self) result(FileName) 現時刻ステップに対応する流れ場ファイル名を返す Arguments Type Intent Optional Attributes Name class( FlowField ) :: self Return Value character,allocatable","tags":"","loc":"type\\flowfield.html"},{"title":"kdTree – Droplets Simulation ","text":"type, public :: kdTree Inherits type~~kdtree~~InheritsGraph type~kdtree kdTree type~node_in_kdtree_t node_in_kdTree_t type~kdtree->type~node_in_kdtree_t node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~kdtree~~InheritedByGraph type~kdtree kdTree type~flowfieldunstructuredgrid FlowFieldUnstructuredGrid type~flowfieldunstructuredgrid->type~kdtree kd_tree type~flowfield FlowField type~flowfield->type~flowfieldunstructuredgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables node set_relation saveAsDOT saveAsTXT read_kdTree Type-Bound Procedures search Components Type Visibility Attributes Name Initial type(node_in_kdTree_t), public, allocatable :: node (:) procedure, public :: set_relation procedure, public :: saveAsDOT procedure, public :: saveAsTXT procedure, public :: read_kdTree Type-Bound Procedures procedure, public :: search => search_kdTree private subroutine search_kdTree(self, xyz, droplet_position, nearest_ID) 探索サブルーチン Arguments Type Intent Optional Attributes Name class( kdTree ), intent(in) :: self real, intent(in) :: xyz (:,:) real, intent(in) :: droplet_position (3) integer, intent(out) :: nearest_ID","tags":"","loc":"type\\kdtree.html"},{"title":"cube_inP3D – Droplets Simulation ","text":"type, public :: cube_inP3D cube（Plot3D形式における立方体）構造体 Inherits type~~cube_inp3d~~InheritsGraph type~cube_inp3d cube_inP3D type~area_t area_t type~cube_inp3d->type~area_t area Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~cube_inp3d~~InheritedByGraph type~cube_inp3d cube_inP3D type~plot3dmesh Plot3dMesh type~plot3dmesh->type~cube_inp3d cubes Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables areaOfCube nearest_nodeID Type-Bound Procedures isIncluded Components Type Visibility Attributes Name Initial procedure, public :: areaOfCube procedure, public :: nearest_nodeID Type-Bound Procedures procedure, public :: isIncluded private function isIncluded(self, cdn) cubeのエリア内に任意座標（引数）が含まれているかを返す関数 Arguments Type Intent Optional Attributes Name class( cube_inP3D ), intent(in) :: self real, intent(in) :: cdn (3) Return Value logical","tags":"","loc":"type\\cube_inp3d.html"},{"title":"plot3dNodeInfo – Droplets Simulation ","text":"type, public :: plot3dNodeInfo 節点情報構造体 Contents Variables cubeID nodeID Components Type Visibility Attributes Name Initial integer, public :: cubeID integer, public :: nodeID (3)","tags":"","loc":"type\\plot3dnodeinfo.html"},{"title":"Plot3dMesh – Droplets Simulation ","text":"type, public :: Plot3dMesh Plot3Dメッシュクラス Inherits type~~plot3dmesh~~InheritsGraph type~plot3dmesh Plot3dMesh type~cube_inp3d cube_inP3D type~plot3dmesh->type~cube_inp3d cubes type~area_t area_t type~cube_inp3d->type~area_t area Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables cubes areaOfMesh Type-Bound Procedures get_cubeShape get_velocity get_numCube read_plot3d_function nearestNodeInfo get_cubeID_contains Components Type Visibility Attributes Name Initial type( cube_inP3D ), public, allocatable :: cubes (:) cube配列 procedure, public :: areaOfMesh Type-Bound Procedures procedure, public :: get_cubeShape private function get_cubeShape(self) result(cubeShape) cubeの形状（i,j,k節点数）を返す関数 Arguments Type Intent Optional Attributes Name class( Plot3dMesh ), intent(in) :: self Return Value integer(3) procedure, public :: get_velocity private function get_velocity(self, node) result(velocity) 任意節点（引数）における流速を返す関数 Arguments Type Intent Optional Attributes Name class( Plot3dMesh ) :: self type( plot3dNodeInfo ), intent(in) :: node 節点 Return Value real(3) procedure, public :: get_numCube private function get_numCube(self) メッシュを構成するcube数を返す関数 Arguments Type Intent Optional Attributes Name class( Plot3dMesh ), intent(in) :: self Return Value integer procedure, public :: read_plot3d_function private subroutine read_plot3d_function(self, fName) メッシュクラスメソッド\n保存量ファイル（.f）を読み込み、メッシュクラスに格納する Arguments Type Intent Optional Attributes Name class( Plot3dMesh ) :: self character, intent(in) :: fName procedure, public :: nearestNodeInfo private function nearestNodeInfo(self, cdn) 任意座標（引数）に最近傍な節点を探し、その情報（cubeID,nodeID）を返す関数 Arguments Type Intent Optional Attributes Name class( Plot3dMesh ), intent(in) :: self real, intent(in) :: cdn (3) Return Value type( plot3dNodeInfo ) procedure, public :: get_cubeID_contains private function get_cubeID_contains(self, cdn) 任意座標（引数）を含むcubeをメッシュの中から探してそのIDを返す関数 Arguments Type Intent Optional Attributes Name class( Plot3dMesh ), intent(in) :: self real, intent(in) :: cdn (3) Return Value integer","tags":"","loc":"type\\plot3dmesh.html"},{"title":"EC_Scalar_t – Droplets Simulation ","text":"type, public :: EC_Scalar_t Inherited by type~~ec_scalar_t~~InheritedByGraph type~ec_scalar_t EC_Scalar_t type~scf_grid_t scf_grid_t type~scf_grid_t->type~ec_scalar_t EC_Scalars Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables name abbreviated_name ndata data Components Type Visibility Attributes Name Initial character, public, allocatable :: name character, public, allocatable :: abbreviated_name integer(kind=4), public :: ndata real(kind=4), public, allocatable :: data (:)","tags":"","loc":"type\\ec_scalar_t.html"},{"title":"EC_Vector_t – Droplets Simulation ","text":"type, public :: EC_Vector_t Inherited by type~~ec_vector_t~~InheritedByGraph type~ec_vector_t EC_Vector_t type~scf_grid_t scf_grid_t type~scf_grid_t->type~ec_vector_t EC_Vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables name abbreviated_name ndata x y z Components Type Visibility Attributes Name Initial character, public, allocatable :: name character, public, allocatable :: abbreviated_name integer(kind=4), public :: ndata real(kind=4), public, allocatable :: x (:) real(kind=4), public, allocatable :: y (:) real(kind=4), public, allocatable :: z (:)","tags":"","loc":"type\\ec_vector_t.html"},{"title":"FC_Scalar_t – Droplets Simulation ","text":"type, public :: FC_Scalar_t Inherited by type~~fc_scalar_t~~InheritedByGraph type~fc_scalar_t FC_Scalar_t type~scf_grid_t scf_grid_t type~scf_grid_t->type~fc_scalar_t FC_Scalars Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables name abbreviated_name ndata face_num face_flag data Components Type Visibility Attributes Name Initial character, public, allocatable :: name character, public, allocatable :: abbreviated_name integer(kind=4), public :: ndata integer(kind=4), public, allocatable :: face_num (:) integer(kind=4), public, allocatable :: face_flag (:) real(kind=4), public, allocatable :: data (:)","tags":"","loc":"type\\fc_scalar_t.html"},{"title":"FC_Vector_t – Droplets Simulation ","text":"type, public :: FC_Vector_t Inherited by type~~fc_vector_t~~InheritedByGraph type~fc_vector_t FC_Vector_t type~scf_grid_t scf_grid_t type~scf_grid_t->type~fc_vector_t FC_Vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables name abbreviated_name ndata face_num face_flag x y z Components Type Visibility Attributes Name Initial character, public, allocatable :: name character, public, allocatable :: abbreviated_name integer(kind=4), public :: ndata integer(kind=4), public, allocatable :: face_num (:) integer(kind=4), public, allocatable :: face_flag (:) real(kind=4), public, allocatable :: x (:) real(kind=4), public, allocatable :: y (:) real(kind=4), public, allocatable :: z (:)","tags":"","loc":"type\\fc_vector_t.html"},{"title":"data_name_list_t – Droplets Simulation ","text":"type, public :: data_name_list_t Contents Variables name abbreviated_name Components Type Visibility Attributes Name Initial character, public, allocatable :: name character, public, allocatable :: abbreviated_name","tags":"","loc":"type\\data_name_list_t.html"},{"title":"content_t – Droplets Simulation ","text":"type, public :: content_t Inherited by type~~content_t~2~~InheritedByGraph type~content_t~2 content_t type~scf_grid_t scf_grid_t type~scf_grid_t->type~content_t~2 face2vertices, mainCell, cell2faces, node, face Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables vertexIDs faceIDs adjacentCellIDs boundFaceID center coordinate Components Type Visibility Attributes Name Initial integer, public, allocatable :: vertexIDs (:) integer, public, allocatable :: faceIDs (:) integer, public, allocatable :: adjacentCellIDs (:) integer, public, allocatable :: boundFaceID (:) real(kind=4), public :: center (3) real(kind=4), public :: coordinate (3)","tags":"","loc":"type\\content_t~2.html"},{"title":"scf_grid_t – Droplets Simulation ","text":"type, public :: scf_grid_t Inherits type~~scf_grid_t~~InheritsGraph type~scf_grid_t scf_grid_t type~content_t~2 content_t type~scf_grid_t->type~content_t~2 face2vertices, mainCell, cell2faces, node, face type~fc_vector_t FC_Vector_t type~scf_grid_t->type~fc_vector_t FC_Vectors type~ec_vector_t EC_Vector_t type~scf_grid_t->type~ec_vector_t EC_Vectors type~ec_scalar_t EC_Scalar_t type~scf_grid_t->type~ec_scalar_t EC_Scalars type~fc_scalar_t FC_Scalar_t type~scf_grid_t->type~fc_scalar_t FC_Scalars Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables node face Type-Bound Procedures read_SCF_file get_fph_element_count get_fph_vertex_count get_fph_face_count get_fph_2d_array_of_point_coords get_fph_2d_array_of_cell_coords get_face2vertices get_face2cells get_cell2faces get_cell_offsets get_fph_boundFaceIDs get_fph_faceCenter get_fph_boundFaceCenter output_fph_cell2face output_fph_boundFace output_fph_vtk get_cell2boundFace get_fph_adjacentCellIDs output_fph_adjacentCell search_fph_vector_data Components Type Visibility Attributes Name Initial type( content_t ), public, allocatable :: node (:) type( content_t ), public, allocatable :: face (:) Type-Bound Procedures procedure, public :: read_SCF_file public subroutine read_SCF_file (this, filename) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this character, intent(in) :: filename procedure, public :: get_fph_element_count public function get_fph_element_count (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_fph_vertex_count public function get_fph_vertex_count (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_fph_face_count public function get_fph_face_count (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_fph_2d_array_of_point_coords public subroutine get_fph_2d_array_of_point_coords (this, points) 節点座標を2次元配列で出力する. Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this real(kind=4), intent(inout), allocatable :: points (:,:) procedure, public :: get_fph_2d_array_of_cell_coords public subroutine get_fph_2d_array_of_cell_coords (this, cells) 要素中心座標を2次元配列で出力する. Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this real(kind=4), intent(inout), allocatable :: cells (:,:) procedure, public :: get_face2vertices public subroutine get_face2vertices (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this procedure, public :: get_face2cells public subroutine get_face2cells (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this procedure, public :: get_cell2faces public subroutine get_cell2faces (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this procedure, public :: get_cell_offsets public subroutine get_cell_offsets (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this procedure, public :: get_fph_boundFaceIDs public subroutine get_fph_boundFaceIDs (this, num_boundFaces) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this integer, intent(out) :: num_boundFaces procedure, public :: get_fph_faceCenter public subroutine get_fph_faceCenter (this, face_center) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this real(kind=4), intent(out), allocatable :: face_center (:,:) procedure, public :: get_fph_boundFaceCenter public subroutine get_fph_boundFaceCenter (this, bound_center) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this real(kind=4), intent(inout), allocatable :: bound_center (:,:) procedure, public :: output_fph_cell2face public subroutine output_fph_cell2face (this, dir) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this character, intent(in) :: dir procedure, public :: output_fph_boundFace public subroutine output_fph_boundFace (this, dir) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this character, intent(in) :: dir procedure, public :: output_fph_vtk public subroutine output_fph_vtk (this, dir) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this character, intent(in) :: dir procedure, public :: get_cell2boundFace public subroutine get_cell2boundFace (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this procedure, public :: get_fph_adjacentCellIDs public subroutine get_fph_adjacentCellIDs (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this procedure, public :: output_fph_adjacentCell public subroutine output_fph_adjacentCell (this, dir) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this character, intent(in) :: dir procedure, public :: search_fph_vector_data public subroutine search_fph_vector_data (this, key, vector) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this character, intent(in) :: key real(kind=4), intent(inout), allocatable :: vector (:,:)","tags":"","loc":"type\\scf_grid_t.html"},{"title":"sctregion_t – Droplets Simulation ","text":"type, public :: sctregion_t Inherited by type~~sctregion_t~~InheritedByGraph type~sctregion_t sctregion_t type~sct_grid_t sct_grid_t type~sct_grid_t->type~sctregion_t region Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents None","tags":"","loc":"type\\sctregion_t.html"},{"title":"sct_data_name_list_t – Droplets Simulation ","text":"type, public :: sct_data_name_list_t スカラーorベクトルデータの名前だけを取り出す. 構造体の配列にして使用する.\nregion用に使うことも出来る. その場合abbreviatedは使わない.\n異なる文字長の配列が実装できなかったのでこれで代用する. Contents None","tags":"","loc":"type\\sct_data_name_list_t.html"},{"title":"sct_grid_t – Droplets Simulation ","text":"type, public :: sct_grid_t SC/TETRA メッシュクラス. \n必要最低限の変数のみ保持. 変数名はフォーマットに準拠. メッシュそのものを取り扱うのでメモリ圧迫する可能性大. \nソルバ内で使う場合はサブルーチンのローカル変数として扱う方が無難(自動開放されるはず) Inherits type~~sct_grid_t~~InheritsGraph type~sct_grid_t sct_grid_t type~sctregion_t sctregion_t type~sct_grid_t->type~sctregion_t region type~ls_scalar_t LS_Scalar_t type~sct_grid_t->type~ls_scalar_t scalars type~ls_vector_t LS_Vector_t type~sct_grid_t->type~ls_vector_t vectors Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures includes_topology is_fld_file print_self read_SCT_file extract_original_cell_vertices extract_cell_vertices extract_ordered_cell_vertices get_2d_array_of_point_coords get_cell_types get_element_count get_vertex_count get_tetrahedron_count get_wedge_count get_pyramid_count get_hexahedron_count get_region_count get_region_namelist extract_face2vertices_on_region search_scalar_data search_vector_data get_data_titles Type-Bound Procedures procedure, public :: includes_topology private function includes_topology(this) 格子ファイルがトポロジを含むか. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value logical procedure, public :: is_fld_file private function is_fld_file(this) ファイルがFLDか. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value logical procedure, public :: print_self private subroutine print_self(this, unit) Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this integer, intent(in) :: unit procedure, public :: read_SCT_file private subroutine read_SCT_file(this, filename) SCTファイルを開き，データを取得する. 事実上のコンストラクタ. \n既に別のファイルを開いていた場合，そのデータを破棄して開く. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(inout) :: this character, intent(in) :: filename procedure, public :: extract_original_cell_vertices private subroutine extract_original_cell_vertices(this, cell2vertices) Sc/Tetraで出力されたセル-頂点関係の配列をそのまま出力する. \nセルの種類毎に並んでいないのが特徴.  頂点番号は1から始まる. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this integer, intent(inout), allocatable :: cell2vertices (:,:) 頂点配列. 1st arg: vertex count, 2nd arg: cell number procedure, public :: extract_cell_vertices private subroutine extract_cell_vertices(this, tetras, pyramids, wedges, hexas) afdet solver との互換性のため, セルタイプごとの頂点配列を出力する. \n頂点配列にはセル毎の頂点のインデックスが格納される. 頂点番号は1から始まる. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this integer, intent(inout), optional allocatable :: tetras (:,:) integer, intent(inout), optional allocatable :: pyramids (:,:) integer, intent(inout), optional allocatable :: wedges (:,:) integer, intent(inout), optional allocatable :: hexas (:,:) procedure, public :: extract_ordered_cell_vertices private subroutine extract_ordered_cell_vertices(this, cell2vertices) セルの種類毎に並んだ格子全体の頂点配列を作成する. \nセルはtetra→pyramid→wedge→hexaの順に並べられる. 頂点番号は1から始まる. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this integer, intent(inout), allocatable :: cell2vertices (:,:) procedure, public :: get_2d_array_of_point_coords private subroutine get_2d_array_of_point_coords(this, xyz) 節点座標を2次元配列で出力する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this real(kind=8), intent(inout), allocatable :: xyz (:,:) procedure, public :: get_cell_types private subroutine get_cell_types(this, celltypes, conversion) セルタイプ配列を出力する. \nextract_original_cell_verticesで出力したセル-節点配列に対して有効. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this integer, intent(inout), allocatable :: celltypes (:) セルタイプ配列 character, intent(in), optional :: conversion セルタイプ番号をvtk, xdmfいずれかに変換する. procedure, public :: get_element_count private function get_element_count(this) 要素数を取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_vertex_count private function get_vertex_count(this) 節点数を取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_tetrahedron_count private function get_tetrahedron_count(this) 格子に含まれるテトラ格子数を取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_wedge_count private function get_wedge_count(this) 格子に含まれるプリズム格子数を取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_pyramid_count private function get_pyramid_count(this) 格子に含まれるピラミッド格子数を取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_hexahedron_count private function get_hexahedron_count(this) 格子に含まれるヘキサ格子数を取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_region_count private function get_region_count(this) 領域の個数. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this Return Value integer procedure, public :: get_region_namelist private subroutine get_region_namelist(this, name_list) Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this type( sct_data_name_list_t ), intent(inout), allocatable :: name_list (:) procedure, public :: extract_face2vertices_on_region private subroutine extract_face2vertices_on_region(this, region_num, cell2vertices, face2vertices) 任意のregionを構成する頂点配列を取得する. 体積領域は無視する. \ncell2verticesはoriginalの物でなければならない. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this integer, intent(in) :: region_num region番号. integer, intent(in), allocatable :: cell2vertices (:,:) 並べ替えのされていないセル-頂点配列. integer, intent(inout), allocatable :: face2vertices (:,:) regionを構成する面-頂点配列. procedure, public :: search_scalar_data private subroutine search_scalar_data(this, key, scalar) .fldに含まれるスカラー場データを取得する.\nkeyにタイトル名を入れて検索する. 該当しない場合含まれるデータ一覧を表示. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this character, intent(in) :: key 取り出したいデータのSC/TETRAでの名称. real(kind=8), intent(inout), allocatable :: scalar (:) procedure, public :: search_vector_data private subroutine search_vector_data(this, key, vector) .fldに含まれるベクトル場データを取得する.\nkeyにタイトル名を入れて検索する. 該当しない場合含まれるデータ一覧を表示. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this character, intent(in) :: key 取り出したいデータのSC/TETRAでの名称. real(kind=8), intent(inout), allocatable :: vector (:,:) procedure, public :: get_data_titles private subroutine get_data_titles(this, titles, data_type) .fldに含まれるデータのタイトルを取得する. Arguments Type Intent Optional Attributes Name class( sct_grid_t ), intent(in) :: this type( sct_data_name_list_t ), intent(inout), allocatable :: titles (:) character, intent(in) :: data_type","tags":"","loc":"type\\sct_grid_t.html"},{"title":"content_t – Droplets Simulation ","text":"type, public :: content_t コンテンツ構造体\n実数とIDをメンバに持つ Inherited by type~~content_t~~InheritedByGraph type~content_t content_t type~heaptree HeapTree type~heaptree->type~content_t node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables originID value Components Type Visibility Attributes Name Initial integer, public :: originID real, public :: value","tags":"","loc":"type\\content_t.html"},{"title":"HeapTree – Droplets Simulation ","text":"type, public :: HeapTree ヒープ木クラス\n実体は単なる配列だがツリー構造を表現している\n要素 i に注目すると、親ノードは要素 i/2(小数切り捨て) であり、子ノードは要素 2i, 2i + 1 である Inherits type~~heaptree~~InheritsGraph type~heaptree HeapTree type~content_t content_t type~heaptree->type~content_t node Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables totalHeaplification rebuild_tree Components Type Visibility Attributes Name Initial procedure, public :: totalHeaplification procedure, public :: rebuild_tree","tags":"","loc":"type\\heaptree.html"},{"title":"DateAndTime – Droplets Simulation ","text":"type, public :: DateAndTime Inherited by type~~dateandtime~~InheritedByGraph type~dateandtime DateAndTime type~timekeeper TimeKeeper type~timekeeper->type~dateandtime startDAT Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures string Type-Bound Procedures procedure, public :: string => DateAndTime2string private function DateAndTime2string(self) result(str) Arguments Type Intent Optional Attributes Name class( DateAndTime ), intent(in) :: self Return Value character,allocatable","tags":"","loc":"type\\dateandtime.html"},{"title":"TimeKeeper – Droplets Simulation ","text":"type, public :: TimeKeeper Inherits type~~timekeeper~~InheritsGraph type~timekeeper TimeKeeper type~dateandtime DateAndTime type~timekeeper->type~dateandtime startDAT Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables startCPUtime lastLapCPUtime startDAT startDateAndTime erapsedTime lapTime Components Type Visibility Attributes Name Initial real, public :: startCPUtime real, public :: lastLapCPUtime type( DateAndTime ), public :: startDAT procedure, public :: startDateAndTime procedure, public :: erapsedTime procedure, public :: lapTime","tags":"","loc":"type\\timekeeper.html"},{"title":"node_t – Droplets Simulation ","text":"type, public :: node_t 節点構造体（ただの座標配列） Inherited by type~~node_t~~InheritedByGraph type~node_t node_t type~flowfieldunstructuredgrid FlowFieldUnstructuredGrid type~flowfieldunstructuredgrid->type~node_t NODEs type~unstructuredgrid_invtk UnstructuredGrid_inVTK type~unstructuredgrid_invtk->type~node_t node_array type~flowfield FlowField type~flowfield->type~flowfieldunstructuredgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables coordinate Components Type Visibility Attributes Name Initial real, public :: coordinate (3)","tags":"","loc":"type\\node_t.html"},{"title":"cell_t – Droplets Simulation ","text":"type, public :: cell_t セル構造体（節点のID配列） Inherited by type~~cell_t~~InheritedByGraph type~cell_t cell_t type~cell_inflow_t cell_inFlow_t type~cell_inflow_t->type~cell_t type~cell_invtk_t cell_inVTK_t type~cell_invtk_t->type~cell_t type~flowfieldunstructuredgrid FlowFieldUnstructuredGrid type~flowfieldunstructuredgrid->type~cell_inflow_t CELLs type~unstructuredgrid_invtk UnstructuredGrid_inVTK type~unstructuredgrid_invtk->type~cell_invtk_t cell_array type~flowfield FlowField type~flowfield->type~flowfieldunstructuredgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nodeID Components Type Visibility Attributes Name Initial integer, public, allocatable :: nodeID (:)","tags":"","loc":"type\\cell_t.html"},{"title":"FlowFieldUnstructuredGrid – Droplets Simulation ","text":"type, public :: FlowFieldUnstructuredGrid 流れ場非構造格子クラス Inherits type~~flowfieldunstructuredgrid~~InheritsGraph type~flowfieldunstructuredgrid FlowFieldUnstructuredGrid type~node_t node_t type~flowfieldunstructuredgrid->type~node_t NODEs type~boundarytriangle_t boundaryTriangle_t type~flowfieldunstructuredgrid->type~boundarytriangle_t BoundFACEs, FACEs type~kdtree kdTree type~flowfieldunstructuredgrid->type~kdtree kd_tree type~cell_inflow_t cell_inFlow_t type~flowfieldunstructuredgrid->type~cell_inflow_t CELLs type~node_in_kdtree_t node_in_kdTree_t type~kdtree->type~node_in_kdtree_t node type~cell_t cell_t type~cell_inflow_t->type~cell_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~flowfieldunstructuredgrid~~InheritedByGraph type~flowfieldunstructuredgrid FlowFieldUnstructuredGrid type~flowfield FlowField type~flowfield->type~flowfieldunstructuredgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables NODEs CELLs BoundFACEs FACEs kd_tree MIN_CDN MAX_CDN num_refCellSearchFalse num_refCellSearch fph_flag set_cellCenter set_cellThreshold set_MinMaxCDN point2cellVelocity nearer_cell AdjacencySolvingProcess read_adjacency read_boundaries solve_adjacencyOnFlowFieldUnstructuredGrid output_boundaries output_adjacency boundary_setting output_STL read_cell2face Type-Bound Procedures nearcell_check nearest_cell nearest_search_kdTree nearest_search_exact get_movementVectorOfBoundarySurface get_flowVelocityInCELL get_allOfCellCenters get_cellCenterOf get_MinMaxOfGrid get_cellVerticesOf get_info read_FPH read_FLD read_INP read_array read_VTK updateWithFlowFieldFile setupWithFlowFieldFile search_refCELL adhesionCheckOnBound get_nearerSearchFalseRate get_num_nearerSearchFalse Components Type Visibility Attributes Name Initial type( node_t ), public, allocatable :: NODEs (:) 節点配列 type(cell_inFlow_t), public, allocatable :: CELLs (:) セル配列 type(boundaryTriangle_t), public, allocatable :: BoundFACEs (:) 境界面配列 type(boundaryTriangle_t), public, allocatable :: FACEs (:) type( kdTree ), public :: kd_tree kd-tree（近傍セル探索用） real, public :: MIN_CDN (3) 座標の最小値(xyz) real, public :: MAX_CDN (3) 座標の最大値(xyz) integer, public :: num_refCellSearchFalse = 0 参照セル探索結果が悪いと判断された回数 integer, public :: num_refCellSearch = 0 参照セル探索が行われた回数 logical, public :: fph_flag = .false. procedure, public :: set_cellCenter procedure, public :: set_cellThreshold procedure, public :: set_MinMaxCDN procedure, public :: point2cellVelocity procedure, public :: nearer_cell procedure, public :: AdjacencySolvingProcess procedure, public :: read_adjacency procedure, public :: read_boundaries procedure, public :: solve_adjacencyOnFlowFieldUnstructuredGrid procedure, public :: output_boundaries procedure, public :: output_adjacency procedure, public :: boundary_setting procedure, public :: output_STL procedure, public :: read_cell2face Type-Bound Procedures procedure, public :: nearcell_check private function nearcell_check(self, X, NCN) result(isNear) 近傍セル探索の結果が妥当かどうかをチェック Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self real, intent(in) :: X (3) 探索対象座標 integer, intent(in) :: NCN 近傍探索結果セルID Return Value logical procedure, public :: nearest_cell private function nearest_cell(self, X) result(nearestCellID) 最近傍セル探索 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self real, intent(in) :: X (3) 探索対象座標 Return Value integer Note 厳密探索かkdツリー探索かはここで切り替える procedure, public :: nearest_search_kdTree private function nearest_search_kdTree(self, X) result(nearestCellID) kdツリーによる最近傍セル探索 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self real, intent(in) :: X (3) 探索対象座標 Return Value integer procedure, public :: nearest_search_exact private function nearest_search_exact(self, X) result(nearestCellID) 厳密最近傍セル探索 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self real, intent(in) :: X (3) 探索対象座標 Return Value integer procedure, public :: get_movementVectorOfBoundarySurface private function get_movementVectorOfBoundarySurface(self, ID) result(vector) 指定IDにおける境界面の移動量ベクトルを返す Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real(3) procedure, public :: get_flowVelocityInCELL private function get_flowVelocityInCELL(self, ID) result(velocity) 指定IDにおけるセルの流速を返す Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real(3) procedure, public :: get_allOfCellCenters private function get_allOfCellCenters(self) result(centers) 全セルの重心座標を２次元配列で返す Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self Return Value real,allocatable, (:,:) procedure, public :: get_cellCenterOf private function get_cellCenterOf(self, ID) result(center) 指定IDにおけるセル重心 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real(3) procedure, public :: get_MinMaxOfGrid private subroutine get_MinMaxOfGrid(self, MIN_CDN, MAX_CDN) 節点群の座標最大最小を返す Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self real, intent(out) :: MIN_CDN (3) real, intent(out) :: MAX_CDN (3) procedure, public :: get_cellVerticesOf private function get_cellVerticesOf(self, ID) result(vertices) 指定IDのセルにおける頂点座標配列を返す\n２次元配列：（xyz、頂点） Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self integer, intent(in) :: ID Return Value real,allocatable, (:,:) procedure, public :: get_info => get_gridInformation private function get_gridInformation(self, name) result(info) 節点数もしくはセル数を取得 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self character, intent(in) :: name 'node' or 'cell' Return Value integer procedure, public :: read_FPH private subroutine read_FPH(self, FNAME, findTopology, findVelocity) FPHファイルから流れ場を取得する Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME ファイル名 logical, intent(in) :: findTopology トポロジー情報を取得するフラグ logical, intent(in) :: findVelocity 流速情報を取得するフラグ procedure, public :: read_FLD private subroutine read_FLD(self, FNAME, findTopology, findVelocity) FLDファイルから流れ場を取得する Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME ファイル名 logical, intent(in) :: findTopology トポロジー情報を取得するフラグ logical, intent(in) :: findVelocity 流速情報を取得するフラグ procedure, public :: read_INP private subroutine read_INP(self, FNAME) INPファイルを読み込み、節点データを要素データに変換する Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME procedure, public :: read_array => read_Array private subroutine read_Array(self, FNAME) 独自フォーマットArrayファイルから、流速を読み込む Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME procedure, public :: read_VTK private subroutine read_VTK(self, FNAME, meshOnly) VTKファイルから流れ場を取得する Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME ファイル名 logical, intent(in) :: meshOnly メッシュだけ読み込み、流速などは無視するフラグ procedure, public :: updateWithFlowFieldFile private subroutine updateWithFlowFieldFile(self, FNAME) 流れ場ファイルを読み込み、流れ場を更新する\nあくまで既存の流れ場の更新目的であり、セル数の異なるメッシュは想定していない\nセル重心の算出も行う Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME procedure, public :: setupWithFlowFieldFile private subroutine setupWithFlowFieldFile(self, FNAME, meshFile) 流れ場ファイルの読み込み\nVTK, INP, FLDに対応\n独自フォーマットのArrayにも対応\nセル重心の算出も行う Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self character, intent(in) :: FNAME character, intent(in), optional :: meshFile procedure, public :: search_refCELL private subroutine search_refCELL(self, X, reference_cell, stat) 参照セル探索\n主に近傍探索が呼ばれるが、探索が芳しくない場合は最近傍探索が呼ばれる Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self real, intent(in) :: X (3) 探索対象座標 integer, intent(inout) :: reference_cell 参照セル logical, optional :: stat procedure, public :: adhesionCheckOnBound private subroutine adhesionCheckOnBound(self, position, radius, cellID, stat) 境界面への飛沫付着判定 Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ), intent(in) :: self double precision, intent(in) :: position (3) 飛沫座標 double precision, intent(in) :: radius 飛沫半径 integer, intent(in) :: cellID 判定対象セルID integer, intent(out) :: stat 付着が起こらなければゼロ、起これば付着面の境界面IDが返る procedure, public :: get_nearerSearchFalseRate private function get_nearerSearchFalseRate(self) result(num_nearerSearchFalseRate) 近傍セル探索の結果が悪いと判断された比率を返す Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self Return Value real procedure, public :: get_num_nearerSearchFalse private function get_num_nearerSearchFalse(self) result(num_nearerSearchFalse) 近傍セル探索の結果が悪いと判断された回数を返す Arguments Type Intent Optional Attributes Name class( FlowFieldUnstructuredGrid ) :: self Return Value integer","tags":"","loc":"type\\flowfieldunstructuredgrid.html"},{"title":"virusDroplet_t – Droplets Simulation ","text":"type, public :: virusDroplet_t ウイルス飛沫構造体 Contents Variables position velocity coalesID refCellID adhesBoundID stop_droplet isEvaporating evaporation get_radius Type-Bound Procedures isFloating coalescenceID Components Type Visibility Attributes Name Initial double precision, public :: position (3) double precision, public :: velocity (3) = 0.d0 integer, public :: coalesID = 0 integer, public :: refCellID = 0 integer, public :: adhesBoundID = 0 procedure, public :: stop_droplet procedure, public :: isEvaporating procedure, public :: evaporation procedure, public :: get_radius Type-Bound Procedures procedure, public :: isFloating => isDropletFloating private function isDropletFloating(self) 飛沫が浮遊しているか否かを返す Arguments Type Intent Optional Attributes Name class( virusDroplet_t ), intent(in) :: self Return Value logical procedure, public :: coalescenceID => dropletCoalescneceID private function dropletCoalescneceID(self) 合体飛沫の合体先のIDを返す Arguments Type Intent Optional Attributes Name class( virusDroplet_t ), intent(in) :: self Return Value integer","tags":"","loc":"type\\virusdroplet_t.html"},{"title":"UnstructuredGrid_inVTK – Droplets Simulation ","text":"type, public :: UnstructuredGrid_inVTK Inherits type~~unstructuredgrid_invtk~~InheritsGraph type~unstructuredgrid_invtk UnstructuredGrid_inVTK type~node_t node_t type~unstructuredgrid_invtk->type~node_t node_array type~cell_invtk_t cell_inVTK_t type~unstructuredgrid_invtk->type~cell_invtk_t cell_array type~cell_t cell_t type~cell_invtk_t->type~cell_t Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables node_array cell_array get_numCell get_numNode get_nodeCoordinate get_cellVertices set_nodeCoordinate set_cellVertices Type-Bound Procedures read output Components Type Visibility Attributes Name Initial type( node_t ), public, allocatable :: node_array (:) type(cell_inVTK_t), public, allocatable :: cell_array (:) procedure, public :: get_numCell procedure, public :: get_numNode procedure, public :: get_nodeCoordinate procedure, public :: get_cellVertices procedure, public :: set_nodeCoordinate procedure, public :: set_cellVertices Type-Bound Procedures procedure, public :: read => read_UnstructuredGrid_inVTK private subroutine read_UnstructuredGrid_inVTK(self, FNAME, action, cellScalar, cellVector) Arguments Type Intent Optional Attributes Name class( UnstructuredGrid_inVTK ) :: self character, intent(in) :: FNAME character, intent(in), optional :: action real, intent(out), optional allocatable :: cellScalar (:) real, intent(out), optional allocatable :: cellVector (:,:) procedure, public :: output => output_UnstructuredGrid_inVTK private subroutine output_UnstructuredGrid_inVTK(self, FNAME, cellScalar, cellVector, scalarName, vectorName) Arguments Type Intent Optional Attributes Name class( UnstructuredGrid_inVTK ) :: self character, intent(in) :: FNAME real, intent(in), optional :: cellScalar (:) real, intent(in), optional :: cellVector (:,:) character, intent(in), optional :: scalarName character, intent(in), optional :: vectorName","tags":"","loc":"type\\unstructuredgrid_invtk.html"},{"title":"output_countCSV – Droplets Simulation","text":"subroutine output_countCSV() Arguments None Called by proc~~output_countcsv~~CalledByGraph proc~output_countcsv output_countCSV program~boxflowfield boxFlowField program~boxflowfield->proc~output_countcsv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\output_countcsv.html"},{"title":"output_boxVTK – Droplets Simulation","text":"subroutine output_boxVTK() Uses VTK_operator_m proc~~output_boxvtk~~UsesGraph proc~output_boxvtk output_boxVTK module~vtk_operator_m VTK_operator_m proc~output_boxvtk->module~vtk_operator_m module~unstructuredelement_m unstructuredElement_m module~vtk_operator_m->module~unstructuredelement_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~output_boxvtk~~CallsGraph proc~output_boxvtk output_boxVTK proc~unstructuredgrid_invtk_ UnstructuredGrid_inVTK_ proc~output_boxvtk->proc~unstructuredgrid_invtk_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~output_boxvtk~~CalledByGraph proc~output_boxvtk output_boxVTK program~boxflowfield boxFlowField program~boxflowfield->proc~output_boxvtk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\output_boxvtk.html"},{"title":"output_nodeInfo – Droplets Simulation","text":"subroutine output_nodeInfo() 対応する節点情報をアスキーファイルで出力するサブルーチン Arguments None Called by proc~~output_nodeinfo~~CalledByGraph proc~output_nodeinfo output_nodeInfo proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~output_nodeinfo program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\output_nodeinfo.html"},{"title":"search_nodeInfo – Droplets Simulation","text":"subroutine search_nodeInfo() Uses unstructuredElement_m terminalControler_m timeKeeper_m proc~~search_nodeinfo~~UsesGraph proc~search_nodeinfo search_nodeInfo module~unstructuredelement_m unstructuredElement_m proc~search_nodeinfo->module~unstructuredelement_m module~terminalcontroler_m terminalControler_m proc~search_nodeinfo->module~terminalcontroler_m module~timekeeper_m timeKeeper_m proc~search_nodeinfo->module~timekeeper_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. 非構造格子に対応する節点情報を探すサブルーチン Arguments None Calls proc~~search_nodeinfo~~CallsGraph proc~search_nodeinfo search_nodeInfo proc~timekeeper_ TimeKeeper_ proc~search_nodeinfo->proc~timekeeper_ proc~get_cellcenters get_cellCenters proc~search_nodeinfo->proc~get_cellcenters proc~set_formattc set_formatTC proc~search_nodeinfo->proc~set_formattc interface~print_progress print_progress proc~search_nodeinfo->interface~print_progress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~search_nodeinfo~~CalledByGraph proc~search_nodeinfo search_nodeInfo proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~search_nodeinfo program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\search_nodeinfo.html"},{"title":"read_nodeInfo – Droplets Simulation","text":"subroutine read_nodeInfo(success) Uses array_m proc~~read_nodeinfo~~UsesGraph proc~read_nodeinfo read_nodeInfo module~array_m array_m proc~read_nodeinfo->module~array_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. 節点情報対応付けファイルを読み込むサブルーチン Arguments Type Intent Optional Attributes Name logical, intent(out) :: success Called by proc~~read_nodeinfo~~CalledByGraph proc~read_nodeinfo read_nodeInfo proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~read_nodeinfo program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\read_nodeinfo.html"},{"title":"solve_correspondence – Droplets Simulation","text":"subroutine solve_correspondence() 格子と節点の対応付けを解決するサブルーチン Arguments None Calls proc~~solve_correspondence~~CallsGraph proc~solve_correspondence solve_correspondence proc~read_nodeinfo read_nodeInfo proc~solve_correspondence->proc~read_nodeinfo proc~search_nodeinfo search_nodeInfo proc~solve_correspondence->proc~search_nodeinfo proc~output_nodeinfo output_nodeInfo proc~solve_correspondence->proc~output_nodeinfo proc~timekeeper_ TimeKeeper_ proc~search_nodeinfo->proc~timekeeper_ proc~get_cellcenters get_cellCenters proc~search_nodeinfo->proc~get_cellcenters proc~set_formattc set_formatTC proc~search_nodeinfo->proc~set_formattc interface~print_progress print_progress proc~search_nodeinfo->interface~print_progress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~solve_correspondence~~CalledByGraph proc~solve_correspondence solve_correspondence program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\solve_correspondence.html"},{"title":"RateOfInfection – Droplets Simulation","text":"elemental function RateOfInfection(volume) 1分間あたりの感染確率を計算（もとの資料では1時間あたりの感染確率だが、1分間あたりに換算） Arguments Type Intent Optional Attributes Name real, intent(in) :: volume Return Value real Called by proc~~rateofinfection~~CalledByGraph proc~rateofinfection RateOfInfection program~dropletcount dropletCount program~dropletcount->proc~rateofinfection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\rateofinfection.html"},{"title":"output_countCSV – Droplets Simulation","text":"subroutine output_countCSV() Arguments None Called by proc~~output_countcsv~2~~CalledByGraph proc~output_countcsv~2 output_countCSV program~dropletcount dropletCount program~dropletcount->proc~output_countcsv~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\output_countcsv~2.html"},{"title":"output_boxVTK – Droplets Simulation","text":"subroutine output_boxVTK() Uses VTK_operator_m proc~~output_boxvtk~2~~UsesGraph proc~output_boxvtk~2 output_boxVTK module~vtk_operator_m VTK_operator_m proc~output_boxvtk~2->module~vtk_operator_m module~unstructuredelement_m unstructuredElement_m module~vtk_operator_m->module~unstructuredelement_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~output_boxvtk~2~~CallsGraph proc~output_boxvtk~2 output_boxVTK proc~unstructuredgrid_invtk_ UnstructuredGrid_inVTK_ proc~output_boxvtk~2->proc~unstructuredgrid_invtk_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~output_boxvtk~2~~CalledByGraph proc~output_boxvtk~2 output_boxVTK program~dropletcount dropletCount program~dropletcount->proc~output_boxvtk~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\output_boxvtk~2.html"},{"title":"solve_BoundaryAndAdjacency – Droplets Simulation","text":"public subroutine solve_BoundaryAndAdjacency(cellVertices, cellBoundFaces, triangleBoundFaceVertices, adjacentCellIDArray) 境界面と隣接関係を、それぞれ配列に格納 Arguments Type Intent Optional Attributes Name integer, intent(in) :: cellVertices (:,:) セルの頂点ID配列（頂点ID,セルID） integer, intent(out), allocatable :: cellBoundFaces (:,:) セルの境界面ID配列（境界面ID,セルID） integer, intent(out), allocatable :: triangleBoundFaceVertices (:,:) 境界面の頂点ID配列（頂点ID,境界面ID） integer, intent(out), allocatable :: adjacentCellIDArray (:,:) セルの隣接セルID配列（隣接セルID,セルID） Contents None","tags":"","loc":"proc\\solve_boundaryandadjacency.html"},{"title":"mean_2dArray – Droplets Simulation","text":"public function mean_2dArray(array) result(mean) Arguments Type Intent Optional Attributes Name real, intent(in) :: array (:,:) Return Value real(size(array,dim=2)) Contents None","tags":"","loc":"proc\\mean_2darray.html"},{"title":"FisherYates_shuffle – Droplets Simulation","text":"public function FisherYates_shuffle(a) result(b) フィッシャー・イェーツのシャッフル\n参考：https://programming-place.net/ppp/contents/algorithm/other/002.html Arguments Type Intent Optional Attributes Name real, intent(in) :: a (:) Return Value real(size(a)) Called by proc~~fisheryates_shuffle~~CalledByGraph proc~fisheryates_shuffle FisherYates_shuffle proc~test_sort test_sort proc~test_sort->proc~fisheryates_shuffle program~sort_test sort_test program~sort_test->proc~test_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\fisheryates_shuffle.html"},{"title":"output_2dArray_asBinary – Droplets Simulation","text":"public subroutine output_2dArray_asBinary(fname, array) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname real, intent(in) :: array (:,:) Called by proc~~output_2darray_asbinary~~CalledByGraph proc~output_2darray_asbinary output_2dArray_asBinary program~cube2usg CUBE2USG program~cube2usg->proc~output_2darray_asbinary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\output_2darray_asbinary.html"},{"title":"read_2dArray_asBinary – Droplets Simulation","text":"public subroutine read_2dArray_asBinary(fname, array) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname real, intent(out), allocatable :: array (:,:) Contents None","tags":"","loc":"proc\\read_2darray_asbinary.html"},{"title":"read_1dArray_real – Droplets Simulation","text":"public subroutine read_1dArray_real(fname, array) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname real, intent(out), allocatable :: array (:) Contents None","tags":"","loc":"proc\\read_1darray_real.html"},{"title":"get_box_array – Droplets Simulation","text":"public function get_box_array(dir, num_Flag) result(new_box_array) Uses simpleFile_reader proc~~get_box_array~~UsesGraph proc~get_box_array get_box_array module~simplefile_reader simpleFile_reader proc~get_box_array->module~simplefile_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character, intent(in) :: dir integer, intent(in) :: num_Flag Return Value type( boxCounter ),allocatable,(:) Calls proc~~get_box_array~~CallsGraph proc~get_box_array get_box_array interface~read_csv read_CSV proc~get_box_array->interface~read_csv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_box_array~~CalledByGraph proc~get_box_array get_box_array program~boxflowfield boxFlowField program~boxflowfield->proc~get_box_array program~dropletcount dropletCount program~dropletcount->proc~get_box_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_box_array.html"},{"title":"get_FlagID – Droplets Simulation","text":"public function get_FlagID(self) result(id_array) Arguments Type Intent Optional Attributes Name class( boxCounter ) :: self Return Value integer,allocatable,(:) Contents None","tags":"","loc":"proc\\get_flagid.html"},{"title":"add_Flag – Droplets Simulation","text":"public subroutine add_Flag(self, id_array) Arguments Type Intent Optional Attributes Name class( boxCounter ) :: self integer, intent(in) :: id_array (:) Contents None","tags":"","loc":"proc\\add_flag.html"},{"title":"case_check – Droplets Simulation","text":"public subroutine case_check(caseName_array) Uses simpleFile_reader proc~~case_check~~UsesGraph proc~case_check case_check module~simplefile_reader simpleFile_reader proc~case_check->module~simplefile_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. case名をキーボードから取得する。\nTXTファイルを指定すると、それを全行読み込んで配列に格納。 Arguments Type Intent Optional Attributes Name character, intent(out), allocatable :: caseName_array (:) Calls proc~~case_check~~CallsGraph proc~case_check case_check proc~read_textrecord read_textRecord proc~case_check->proc~read_textrecord Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~case_check~~CalledByGraph proc~case_check case_check program~dropletcount dropletCount program~dropletcount->proc~case_check program~translate translate program~translate->proc~case_check program~main MAIN program~main->proc~case_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\case_check.html"},{"title":"read_condition – Droplets Simulation","text":"public function read_condition(dir) result(self) 条件ファイルを読み込み、結果を構造体で返す。\nこのサブルーチン実装当時、構造体をそのままnamelistにできることを知らず、わざわざ変数ひとつひとつ定義した。\n現在ここを変えると進行中のプロジェクト（オフィス飛沫計算など）に影響が出るおそれがあり、触れない。\nいつか修正したい。 Arguments Type Intent Optional Attributes Name character, intent(in) :: dir Return Value type( conditionValue_t ) Called by proc~~read_condition~~CalledByGraph proc~read_condition read_condition program~dropletcount dropletCount program~dropletcount->proc~read_condition Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\read_condition.html"},{"title":"BasicParameter_ – Droplets Simulation","text":"public function BasicParameter_(delta_t, L_represent, U_represent) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: delta_t double precision, intent(in) :: L_represent double precision, intent(in) :: U_represent Return Value type( BasicParameter ) Called by proc~~basicparameter_~~CalledByGraph proc~basicparameter_ BasicParameter_ proc~dropletequationsolver_ DropletEquationSolver_ proc~dropletequationsolver_->proc~basicparameter_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\basicparameter_.html"},{"title":"DropletEquationSolver_ – Droplets Simulation","text":"public function DropletEquationSolver_(delta_t, L_represent, U_represent, direction_g, Temperature, RelativeHumidity) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: delta_t double precision, intent(in) :: L_represent double precision, intent(in) :: U_represent double precision, intent(in) :: direction_g (3) real, intent(in) :: Temperature real, intent(in) :: RelativeHumidity Return Value type( DropletEquationSolver ) Calls proc~~dropletequationsolver_~~CallsGraph proc~dropletequationsolver_ DropletEquationSolver_ proc~basicparameter_ BasicParameter_ proc~dropletequationsolver_->proc~basicparameter_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\dropletequationsolver_.html"},{"title":"DropletGenerator_ – Droplets Simulation","text":"public function DropletGenerator_(equation, radiusDistributionFile, positionDir, generationRate) Arguments Type Intent Optional Attributes Name type( DropletEquationSolver ), target :: equation character, intent(in) :: radiusDistributionFile character, intent(in) :: positionDir integer, intent(in) :: generationRate Return Value type( DropletGenerator ) Contents None","tags":"","loc":"proc\\dropletgenerator_.html"},{"title":"read_basicSettingOnSimulation – Droplets Simulation","text":"public subroutine read_basicSettingOnSimulation() シミュレーションの基礎的な設定ファイルを読み込む Arguments None Called by proc~~read_basicsettingonsimulation~~CalledByGraph proc~read_basicsettingonsimulation read_basicSettingOnSimulation program~main MAIN program~main->proc~read_basicsettingonsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\read_basicsettingonsimulation.html"},{"title":"RunDropletsSimulation – Droplets Simulation","text":"public subroutine RunDropletsSimulation(case_name) 飛沫運動シミュレーションの実行 Arguments Type Intent Optional Attributes Name character, intent(in) :: case_name ケースディレクトリ名 Calls proc~~rundropletssimulation~~CallsGraph proc~rundropletssimulation RunDropletsSimulation proc~survival_check survival_check proc~rundropletssimulation->proc~survival_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rundropletssimulation~~CalledByGraph proc~rundropletssimulation RunDropletsSimulation program~main MAIN program~main->proc~rundropletssimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\rundropletssimulation.html"},{"title":"FlowField_ – Droplets Simulation","text":"public function FlowField_(time, PATH2FlowFile, DeltaT, OFFSET, outputINTERVAL, LoopHead, LoopTail, meshFile) result(flow_field) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: time 現在無次元時刻 character, intent(in) :: PATH2FlowFile double precision, intent(in) :: DeltaT 流体計算の時間間隔 integer, intent(in) :: OFFSET integer, intent(in) :: outputINTERVAL integer, intent(in) :: LoopHead integer, intent(in) :: LoopTail character, intent(in), optional :: meshFile Return Value type( FlowField ) Calls proc~~flowfield_~~CallsGraph proc~flowfield_ FlowField_ proc~flowfieldunstructuredgrid_withmeshfile FlowFieldUnstructuredGrid_withMeshFile proc~flowfield_->proc~flowfieldunstructuredgrid_withmeshfile proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ proc~flowfield_->proc~flowfieldunstructuredgrid_ proc~get_dirfrompath get_DirFromPath proc~flowfieldunstructuredgrid_withmeshfile->proc~get_dirfrompath proc~flowfieldunstructuredgrid_->proc~get_dirfrompath Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\flowfield_.html"},{"title":"volume_tetra – Droplets Simulation","text":"public function volume_tetra(vertices) result(volume) テトラの体積計算。 Arguments Type Intent Optional Attributes Name real, intent(in) :: vertices (3,4) Return Value real Calls proc~~volume_tetra~~CallsGraph proc~volume_tetra volume_tetra interface~cross_product cross_product proc~volume_tetra->interface~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~volume_tetra~~CalledByGraph proc~volume_tetra volume_tetra proc~insidejudgment_tetra insideJudgment_tetra proc~insidejudgment_tetra->proc~volume_tetra proc~insidejudgment_tetra_check insideJudgment_tetra_check proc~insidejudgment_tetra_check->proc~volume_tetra program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->proc~insidejudgment_tetra program~cellcentercalc_test->proc~insidejudgment_tetra_check program~geometry_test geometry_test program~geometry_test->proc~insidejudgment_tetra Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\volume_tetra.html"},{"title":"insideJudgment_tetra – Droplets Simulation","text":"public function insideJudgment_tetra(vertices, point) result(isInside) 任意の点がテトラの内部にあるかどうかを判定する。\n点でテトラを分割したそれぞれの体積の和が、元々のテトラの体積を上回れば、点はテトラ外部にある。\nhttps://matcha-choco010.net/2018/03/14/point-in-tetrahedron/ Arguments Type Intent Optional Attributes Name real, intent(in) :: vertices (3,4) real, intent(in) :: point (3) Return Value logical Calls proc~~insidejudgment_tetra~~CallsGraph proc~insidejudgment_tetra insideJudgment_tetra proc~volume_tetra volume_tetra proc~insidejudgment_tetra->proc~volume_tetra interface~cross_product cross_product proc~volume_tetra->interface~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~insidejudgment_tetra~~CalledByGraph proc~insidejudgment_tetra insideJudgment_tetra program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->proc~insidejudgment_tetra program~geometry_test geometry_test program~geometry_test->proc~insidejudgment_tetra Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\insidejudgment_tetra.html"},{"title":"insideJudgment_tetra_check – Droplets Simulation","text":"public subroutine insideJudgment_tetra_check(vertices, point, vol_sum, volume) テトラの内外判定の内部処理確認用サブルーチン Arguments Type Intent Optional Attributes Name real, intent(in) :: vertices (3,4) real, intent(in) :: point (3) real, intent(out) :: vol_sum 分割体積和 real, intent(out) :: volume テトラ体積 Calls proc~~insidejudgment_tetra_check~~CallsGraph proc~insidejudgment_tetra_check insideJudgment_tetra_check proc~volume_tetra volume_tetra proc~insidejudgment_tetra_check->proc~volume_tetra interface~cross_product cross_product proc~volume_tetra->interface~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~insidejudgment_tetra_check~~CalledByGraph proc~insidejudgment_tetra_check insideJudgment_tetra_check program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->proc~insidejudgment_tetra_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\insidejudgment_tetra_check.html"},{"title":"kdTree_ – Droplets Simulation","text":"public function kdTree_(xyz_origin) Uses terminalControler_m proc~~kdtree_~~UsesGraph proc~kdtree_ kdTree_ module~terminalcontroler_m terminalControler_m proc~kdtree_->module~terminalcontroler_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real, intent(in) :: xyz_origin (:,:) Return Value type( kdTree ) Calls proc~~kdtree_~~CallsGraph proc~kdtree_ kdTree_ proc~real2content real2content proc~kdtree_->proc~real2content proc~set_formattc set_formatTC proc~kdtree_->proc~set_formattc interface~print_progress print_progress proc~kdtree_->interface~print_progress proc~merge_sort merge_sort proc~kdtree_->proc~merge_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~kdtree_~~CalledByGraph proc~kdtree_ kdTree_ program~kdtree_test kdTree_test program~kdtree_test->proc~kdtree_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\kdtree_.html"},{"title":"replace_str – Droplets Simulation","text":"public function replace_str(str, from, to) Arguments Type Intent Optional Attributes Name character, intent(in) :: str character(len=1), intent(in) :: from character(len=1), intent(in) :: to Return Value character Called by proc~~replace_str~~CalledByGraph proc~replace_str replace_str proc~make_directory make_directory proc~make_directory->proc~replace_str program~kdtree_test kdTree_test program~kdtree_test->proc~make_directory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\replace_str.html"},{"title":"make_directory – Droplets Simulation","text":"public subroutine make_directory(path) Arguments Type Intent Optional Attributes Name character, intent(in) :: path Calls proc~~make_directory~~CallsGraph proc~make_directory make_directory proc~replace_str replace_str proc~make_directory->proc~replace_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~make_directory~~CalledByGraph proc~make_directory make_directory program~kdtree_test kdTree_test program~kdtree_test->proc~make_directory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\make_directory.html"},{"title":"get_DirFromPath – Droplets Simulation","text":"public subroutine get_DirFromPath(path, directory, filename) Arguments Type Intent Optional Attributes Name character, intent(in) :: path character, intent(out), allocatable :: directory character, intent(out), optional allocatable :: filename Called by proc~~get_dirfrompath~~CalledByGraph proc~get_dirfrompath get_DirFromPath proc~flowfieldunstructuredgrid_withmeshfile FlowFieldUnstructuredGrid_withMeshFile proc~flowfieldunstructuredgrid_withmeshfile->proc~get_dirfrompath proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ proc~flowfieldunstructuredgrid_->proc~get_dirfrompath proc~flowfield_ FlowField_ proc~flowfield_->proc~flowfieldunstructuredgrid_withmeshfile proc~flowfield_->proc~flowfieldunstructuredgrid_ program~boxflowfield boxFlowField program~boxflowfield->proc~flowfieldunstructuredgrid_withmeshfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_dirfrompath.html"},{"title":"read_plot3d_multigrid – Droplets Simulation","text":"public function read_plot3d_multigrid(fName) result(mesh) メッシュファイル（.g）を読み込んでメッシュクラスを返す関数 Arguments Type Intent Optional Attributes Name character, intent(in) :: fName Return Value type( Plot3dMesh ) Called by proc~~read_plot3d_multigrid~~CalledByGraph proc~read_plot3d_multigrid read_plot3d_multigrid program~cube2usg CUBE2USG program~cube2usg->proc~read_plot3d_multigrid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\read_plot3d_multigrid.html"},{"title":"open_binary_sequential_ – Droplets Simulation","text":"public function open_binary_sequential_(unit, filename) result(is_opened) バイナリファイルをシーケンシャル形式で開く. 開けない場合.false. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: unit 装置番号. character, intent(in) :: filename Return Value logical Called by proc~~open_binary_sequential_~~CalledByGraph proc~open_binary_sequential_ open_binary_sequential_ proc~read_scf_file read_SCF_file proc~read_scf_file->proc~open_binary_sequential_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\open_binary_sequential_.html"},{"title":"get_fph_element_count – Droplets Simulation","text":"public function get_fph_element_count(this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc\\get_fph_element_count.html"},{"title":"get_fph_vertex_count – Droplets Simulation","text":"public function get_fph_vertex_count(this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc\\get_fph_vertex_count.html"},{"title":"get_fph_face_count – Droplets Simulation","text":"public function get_fph_face_count(this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this Return Value integer Contents None","tags":"","loc":"proc\\get_fph_face_count.html"},{"title":"append2list_int – Droplets Simulation","text":"public function append2list_int(list, element, first_flag) result(after_list) Arguments Type Intent Optional Attributes Name integer, intent(in) :: list (:) integer, intent(in) :: element logical, intent(inout) :: first_flag Return Value integer,allocatable,(:) Called by proc~~append2list_int~~CalledByGraph proc~append2list_int append2list_int proc~get_cell2faces get_cell2faces proc~get_cell2faces->proc~append2list_int proc~get_fph_boundfaceids get_fph_boundFaceIDs proc~get_fph_boundfaceids->proc~append2list_int proc~get_cell2boundface get_cell2boundFace proc~get_cell2boundface->proc~append2list_int proc~get_fph_adjacentcellids get_fph_adjacentCellIDs proc~get_fph_adjacentcellids->proc~append2list_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\append2list_int.html"},{"title":"read_SCF_file – Droplets Simulation","text":"public subroutine read_SCF_file(this, filename) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this character, intent(in) :: filename Calls proc~~read_scf_file~~CallsGraph proc~read_scf_file read_SCF_file proc~destructor destructor proc~read_scf_file->proc~destructor proc~read_fph_header_data read_FPH_Header_data proc~read_scf_file->proc~read_fph_header_data proc~read_fph_main_data read_FPH_Main_data proc~read_scf_file->proc~read_fph_main_data proc~open_binary_sequential_ open_binary_sequential_ proc~read_scf_file->proc~open_binary_sequential_ proc~get_data_float64_ get_data_float64_ proc~read_fph_header_data->proc~get_data_float64_ proc~get_data_int32_~2 get_data_int32_ proc~read_fph_header_data->proc~get_data_int32_~2 proc~get_data_array_float64_ get_data_array_float64_ proc~read_fph_main_data->proc~get_data_array_float64_ proc~ec_scalar_reader EC_Scalar_reader proc~read_fph_main_data->proc~ec_scalar_reader proc~get_data_char_ get_data_char_ proc~read_fph_main_data->proc~get_data_char_ proc~fc_vector_reader FC_Vector_reader proc~read_fph_main_data->proc~fc_vector_reader proc~read_fph_main_data->proc~get_data_int32_~2 proc~get_data_array_int32_ get_data_array_int32_ proc~read_fph_main_data->proc~get_data_array_int32_ proc~ec_vector_reader EC_Vector_reader proc~read_fph_main_data->proc~ec_vector_reader proc~fc_scalar_reader FC_Scalar_reader proc~read_fph_main_data->proc~fc_scalar_reader proc~ec_scalar_reader->proc~get_data_array_float64_ proc~ec_scalar_reader->proc~get_data_char_ proc~ec_scalar_reader->proc~get_data_int32_~2 proc~fc_vector_reader->proc~get_data_array_float64_ proc~fc_vector_reader->proc~get_data_char_ proc~fc_vector_reader->proc~get_data_int32_~2 proc~fc_vector_reader->proc~get_data_array_int32_ proc~ignore_data_ ignore_data_ proc~fc_vector_reader->proc~ignore_data_ proc~ec_vector_reader->proc~get_data_array_float64_ proc~ec_vector_reader->proc~get_data_char_ proc~ec_vector_reader->proc~get_data_int32_~2 proc~ec_vector_reader->proc~ignore_data_ proc~fc_scalar_reader->proc~get_data_array_float64_ proc~fc_scalar_reader->proc~get_data_char_ proc~fc_scalar_reader->proc~get_data_int32_~2 proc~fc_scalar_reader->proc~get_data_array_int32_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\read_scf_file.html"},{"title":"read_FPH_Header_data – Droplets Simulation","text":"public subroutine read_FPH_Header_data(unit, NCYC, TIME) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer(kind=4), intent(inout) :: NCYC real(kind=4), intent(inout) :: TIME Calls proc~~read_fph_header_data~~CallsGraph proc~read_fph_header_data read_FPH_Header_data proc~get_data_int32_~2 get_data_int32_ proc~read_fph_header_data->proc~get_data_int32_~2 proc~get_data_float64_ get_data_float64_ proc~read_fph_header_data->proc~get_data_float64_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_fph_header_data~~CalledByGraph proc~read_fph_header_data read_FPH_Header_data proc~read_scf_file read_SCF_file proc~read_scf_file->proc~read_fph_header_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\read_fph_header_data.html"},{"title":"read_FPH_Main_data – Droplets Simulation","text":"public subroutine read_FPH_Main_data(unit, CAN_X, CAN_Y, CAN_Z, CCE_X, CCE_Y, CCE_Z, EC_Scalars, EC_Vectors, FC_Scalars, FC_Vectors, EC_Scalar_cnt, EC_Vector_cnt, FC_Scalar_cnt, FC_Vector_cnt, NODES, NFACE, NELEM, NDTOT, IE1, IE2, NDNUM, IDNO) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit real(kind=4), intent(inout), allocatable :: CAN_X (:) real(kind=4), intent(inout), allocatable :: CAN_Y (:) real(kind=4), intent(inout), allocatable :: CAN_Z (:) real(kind=4), intent(inout), allocatable :: CCE_X (:) real(kind=4), intent(inout), allocatable :: CCE_Y (:) real(kind=4), intent(inout), allocatable :: CCE_Z (:) type( EC_Scalar_t ), intent(inout), allocatable :: EC_Scalars (:) type( EC_Vector_t ), intent(inout), allocatable :: EC_Vectors (:) type( FC_Scalar_t ), intent(inout), allocatable :: FC_Scalars (:) type( FC_Vector_t ), intent(inout), allocatable :: FC_Vectors (:) integer, intent(inout) :: EC_Scalar_cnt integer, intent(inout) :: EC_Vector_cnt integer, intent(inout) :: FC_Scalar_cnt integer, intent(inout) :: FC_Vector_cnt integer, intent(inout) :: NODES integer, intent(inout) :: NFACE integer, intent(inout) :: NELEM integer, intent(inout) :: NDTOT integer, intent(inout), allocatable :: IE1 (:) integer, intent(inout), allocatable :: IE2 (:) integer, intent(inout), allocatable :: NDNUM (:) integer, intent(inout), allocatable :: IDNO (:) Calls proc~~read_fph_main_data~~CallsGraph proc~read_fph_main_data read_FPH_Main_data proc~get_data_array_float64_ get_data_array_float64_ proc~read_fph_main_data->proc~get_data_array_float64_ proc~ec_scalar_reader EC_Scalar_reader proc~read_fph_main_data->proc~ec_scalar_reader proc~fc_vector_reader FC_Vector_reader proc~read_fph_main_data->proc~fc_vector_reader proc~get_data_char_ get_data_char_ proc~read_fph_main_data->proc~get_data_char_ proc~get_data_int32_~2 get_data_int32_ proc~read_fph_main_data->proc~get_data_int32_~2 proc~get_data_array_int32_ get_data_array_int32_ proc~read_fph_main_data->proc~get_data_array_int32_ proc~ec_vector_reader EC_Vector_reader proc~read_fph_main_data->proc~ec_vector_reader proc~fc_scalar_reader FC_Scalar_reader proc~read_fph_main_data->proc~fc_scalar_reader proc~ec_scalar_reader->proc~get_data_array_float64_ proc~ec_scalar_reader->proc~get_data_char_ proc~ec_scalar_reader->proc~get_data_int32_~2 proc~fc_vector_reader->proc~get_data_array_float64_ proc~fc_vector_reader->proc~get_data_char_ proc~fc_vector_reader->proc~get_data_int32_~2 proc~fc_vector_reader->proc~get_data_array_int32_ proc~ignore_data_ ignore_data_ proc~fc_vector_reader->proc~ignore_data_ proc~ec_vector_reader->proc~get_data_array_float64_ proc~ec_vector_reader->proc~get_data_char_ proc~ec_vector_reader->proc~get_data_int32_~2 proc~ec_vector_reader->proc~ignore_data_ proc~fc_scalar_reader->proc~get_data_array_float64_ proc~fc_scalar_reader->proc~get_data_char_ proc~fc_scalar_reader->proc~get_data_int32_~2 proc~fc_scalar_reader->proc~get_data_array_int32_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_fph_main_data~~CalledByGraph proc~read_fph_main_data read_FPH_Main_data proc~read_scf_file read_SCF_file proc~read_scf_file->proc~read_fph_main_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\read_fph_main_data.html"},{"title":"EC_Scalar_reader – Droplets Simulation","text":"public subroutine EC_Scalar_reader(scalar, unit, is_end) Arguments Type Intent Optional Attributes Name type( EC_Scalar_t ) :: scalar integer(kind=4), intent(in) :: unit logical, intent(out) :: is_end Calls proc~~ec_scalar_reader~~CallsGraph proc~ec_scalar_reader EC_Scalar_reader proc~get_data_char_ get_data_char_ proc~ec_scalar_reader->proc~get_data_char_ proc~get_data_array_float64_ get_data_array_float64_ proc~ec_scalar_reader->proc~get_data_array_float64_ proc~get_data_int32_~2 get_data_int32_ proc~ec_scalar_reader->proc~get_data_int32_~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ec_scalar_reader~~CalledByGraph proc~ec_scalar_reader EC_Scalar_reader proc~read_fph_main_data read_FPH_Main_data proc~read_fph_main_data->proc~ec_scalar_reader proc~read_scf_file read_SCF_file proc~read_scf_file->proc~read_fph_main_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\ec_scalar_reader.html"},{"title":"EC_Vector_reader – Droplets Simulation","text":"public subroutine EC_Vector_reader(vector, unit, is_end) Arguments Type Intent Optional Attributes Name type( EC_Vector_t ) :: vector integer(kind=4), intent(in) :: unit logical, intent(out) :: is_end Calls proc~~ec_vector_reader~~CallsGraph proc~ec_vector_reader EC_Vector_reader proc~ignore_data_ ignore_data_ proc~ec_vector_reader->proc~ignore_data_ proc~get_data_array_float64_ get_data_array_float64_ proc~ec_vector_reader->proc~get_data_array_float64_ proc~get_data_char_ get_data_char_ proc~ec_vector_reader->proc~get_data_char_ proc~get_data_int32_~2 get_data_int32_ proc~ec_vector_reader->proc~get_data_int32_~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ec_vector_reader~~CalledByGraph proc~ec_vector_reader EC_Vector_reader proc~read_fph_main_data read_FPH_Main_data proc~read_fph_main_data->proc~ec_vector_reader proc~read_scf_file read_SCF_file proc~read_scf_file->proc~read_fph_main_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\ec_vector_reader.html"},{"title":"FC_Scalar_reader – Droplets Simulation","text":"public subroutine FC_Scalar_reader(scalar, unit, is_end) Arguments Type Intent Optional Attributes Name type( FC_Scalar_t ) :: scalar integer(kind=4), intent(in) :: unit logical, intent(out) :: is_end Calls proc~~fc_scalar_reader~~CallsGraph proc~fc_scalar_reader FC_Scalar_reader proc~get_data_char_ get_data_char_ proc~fc_scalar_reader->proc~get_data_char_ proc~get_data_array_float64_ get_data_array_float64_ proc~fc_scalar_reader->proc~get_data_array_float64_ proc~get_data_array_int32_ get_data_array_int32_ proc~fc_scalar_reader->proc~get_data_array_int32_ proc~get_data_int32_~2 get_data_int32_ proc~fc_scalar_reader->proc~get_data_int32_~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fc_scalar_reader~~CalledByGraph proc~fc_scalar_reader FC_Scalar_reader proc~read_fph_main_data read_FPH_Main_data proc~read_fph_main_data->proc~fc_scalar_reader proc~read_scf_file read_SCF_file proc~read_scf_file->proc~read_fph_main_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\fc_scalar_reader.html"},{"title":"FC_Vector_reader – Droplets Simulation","text":"public subroutine FC_Vector_reader(vector, unit, is_end) Arguments Type Intent Optional Attributes Name type( FC_Vector_t ) :: vector integer(kind=4), intent(in) :: unit logical, intent(out) :: is_end Calls proc~~fc_vector_reader~~CallsGraph proc~fc_vector_reader FC_Vector_reader proc~get_data_array_float64_ get_data_array_float64_ proc~fc_vector_reader->proc~get_data_array_float64_ proc~get_data_char_ get_data_char_ proc~fc_vector_reader->proc~get_data_char_ proc~ignore_data_ ignore_data_ proc~fc_vector_reader->proc~ignore_data_ proc~get_data_array_int32_ get_data_array_int32_ proc~fc_vector_reader->proc~get_data_array_int32_ proc~get_data_int32_~2 get_data_int32_ proc~fc_vector_reader->proc~get_data_int32_~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fc_vector_reader~~CalledByGraph proc~fc_vector_reader FC_Vector_reader proc~read_fph_main_data read_FPH_Main_data proc~read_fph_main_data->proc~fc_vector_reader proc~read_scf_file read_SCF_file proc~read_scf_file->proc~read_fph_main_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\fc_vector_reader.html"},{"title":"get_data_int32_ – Droplets Simulation","text":"public subroutine get_data_int32_(unit, retval) Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: unit integer(kind=4), intent(inout) :: retval Called by proc~~get_data_int32_~2~~CalledByGraph proc~get_data_int32_~2 get_data_int32_ proc~ec_scalar_reader EC_Scalar_reader proc~ec_scalar_reader->proc~get_data_int32_~2 proc~fc_vector_reader FC_Vector_reader proc~fc_vector_reader->proc~get_data_int32_~2 proc~read_fph_main_data read_FPH_Main_data proc~read_fph_main_data->proc~get_data_int32_~2 proc~read_fph_main_data->proc~ec_scalar_reader proc~read_fph_main_data->proc~fc_vector_reader proc~ec_vector_reader EC_Vector_reader proc~read_fph_main_data->proc~ec_vector_reader proc~fc_scalar_reader FC_Scalar_reader proc~read_fph_main_data->proc~fc_scalar_reader proc~read_fph_header_data read_FPH_Header_data proc~read_fph_header_data->proc~get_data_int32_~2 proc~ec_vector_reader->proc~get_data_int32_~2 proc~fc_scalar_reader->proc~get_data_int32_~2 proc~read_scf_file read_SCF_file proc~read_scf_file->proc~read_fph_main_data proc~read_scf_file->proc~read_fph_header_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_data_int32_~2.html"},{"title":"get_data_float64_ – Droplets Simulation","text":"public subroutine get_data_float64_(unit, retval) Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: unit real(kind=4), intent(inout) :: retval Called by proc~~get_data_float64_~~CalledByGraph proc~get_data_float64_ get_data_float64_ proc~read_fph_header_data read_FPH_Header_data proc~read_fph_header_data->proc~get_data_float64_ proc~read_scf_file read_SCF_file proc~read_scf_file->proc~read_fph_header_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_data_float64_.html"},{"title":"get_data_array_int32_ – Droplets Simulation","text":"public subroutine get_data_array_int32_(unit, ret_array, ret_array_size) 整数型配列の読み込み Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: unit integer(kind=4), intent(out), allocatable :: ret_array (:) integer(kind=4), intent(in) :: ret_array_size Called by proc~~get_data_array_int32_~~CalledByGraph proc~get_data_array_int32_ get_data_array_int32_ proc~read_fph_main_data read_FPH_Main_data proc~read_fph_main_data->proc~get_data_array_int32_ proc~fc_vector_reader FC_Vector_reader proc~read_fph_main_data->proc~fc_vector_reader proc~fc_scalar_reader FC_Scalar_reader proc~read_fph_main_data->proc~fc_scalar_reader proc~fc_vector_reader->proc~get_data_array_int32_ proc~fc_scalar_reader->proc~get_data_array_int32_ proc~read_scf_file read_SCF_file proc~read_scf_file->proc~read_fph_main_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_data_array_int32_.html"},{"title":"get_data_array_float64_ – Droplets Simulation","text":"public subroutine get_data_array_float64_(unit, ret_array, ret_array_size) 倍精度実数型配列の読み込み Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: unit real(kind=4), intent(out), allocatable :: ret_array (:) integer(kind=4), intent(in) :: ret_array_size Called by proc~~get_data_array_float64_~~CalledByGraph proc~get_data_array_float64_ get_data_array_float64_ proc~read_fph_main_data read_FPH_Main_data proc~read_fph_main_data->proc~get_data_array_float64_ proc~ec_scalar_reader EC_Scalar_reader proc~read_fph_main_data->proc~ec_scalar_reader proc~fc_vector_reader FC_Vector_reader proc~read_fph_main_data->proc~fc_vector_reader proc~fc_scalar_reader FC_Scalar_reader proc~read_fph_main_data->proc~fc_scalar_reader proc~ec_vector_reader EC_Vector_reader proc~read_fph_main_data->proc~ec_vector_reader proc~ec_scalar_reader->proc~get_data_array_float64_ proc~fc_vector_reader->proc~get_data_array_float64_ proc~fc_scalar_reader->proc~get_data_array_float64_ proc~ec_vector_reader->proc~get_data_array_float64_ proc~read_scf_file read_SCF_file proc~read_scf_file->proc~read_fph_main_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_data_array_float64_.html"},{"title":"ignore_data_ – Droplets Simulation","text":"public subroutine ignore_data_(unit) データを読み飛ばす処理 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: unit Called by proc~~ignore_data_~~CalledByGraph proc~ignore_data_ ignore_data_ proc~ec_vector_reader EC_Vector_reader proc~ec_vector_reader->proc~ignore_data_ proc~fc_vector_reader FC_Vector_reader proc~fc_vector_reader->proc~ignore_data_ proc~read_fph_main_data read_FPH_Main_data proc~read_fph_main_data->proc~ec_vector_reader proc~read_fph_main_data->proc~fc_vector_reader proc~read_scf_file read_SCF_file proc~read_scf_file->proc~read_fph_main_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\ignore_data_.html"},{"title":"get_data_char_ – Droplets Simulation","text":"public subroutine get_data_char_(unit, byte, ret_char) 文字列（バイト数指定） Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: unit integer(kind=4), intent(in) :: byte character, intent(inout), allocatable :: ret_char Called by proc~~get_data_char_~~CalledByGraph proc~get_data_char_ get_data_char_ proc~read_fph_main_data read_FPH_Main_data proc~read_fph_main_data->proc~get_data_char_ proc~ec_scalar_reader EC_Scalar_reader proc~read_fph_main_data->proc~ec_scalar_reader proc~fc_vector_reader FC_Vector_reader proc~read_fph_main_data->proc~fc_vector_reader proc~fc_scalar_reader FC_Scalar_reader proc~read_fph_main_data->proc~fc_scalar_reader proc~ec_vector_reader EC_Vector_reader proc~read_fph_main_data->proc~ec_vector_reader proc~ec_scalar_reader->proc~get_data_char_ proc~fc_vector_reader->proc~get_data_char_ proc~fc_scalar_reader->proc~get_data_char_ proc~ec_vector_reader->proc~get_data_char_ proc~read_scf_file read_SCF_file proc~read_scf_file->proc~read_fph_main_data Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_data_char_.html"},{"title":"destructor – Droplets Simulation","text":"public subroutine destructor(this) Arguments Type Intent Optional Attributes Name type( scf_grid_t ), intent(inout) :: this Called by proc~~destructor~~CalledByGraph proc~destructor destructor proc~read_scf_file read_SCF_file proc~read_scf_file->proc~destructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\destructor.html"},{"title":"get_fph_2d_array_of_point_coords – Droplets Simulation","text":"public subroutine get_fph_2d_array_of_point_coords(this, points) 節点座標を2次元配列で出力する. Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this real(kind=4), intent(inout), allocatable :: points (:,:) Calls proc~~get_fph_2d_array_of_point_coords~~CallsGraph proc~get_fph_2d_array_of_point_coords get_fph_2d_array_of_point_coords proc~packing_vector_into_2darray_ packing_vector_into_2Darray_ proc~get_fph_2d_array_of_point_coords->proc~packing_vector_into_2darray_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_fph_2d_array_of_point_coords.html"},{"title":"get_fph_2d_array_of_cell_coords – Droplets Simulation","text":"public subroutine get_fph_2d_array_of_cell_coords(this, cells) 要素中心座標を2次元配列で出力する. Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this real(kind=4), intent(inout), allocatable :: cells (:,:) Calls proc~~get_fph_2d_array_of_cell_coords~~CallsGraph proc~get_fph_2d_array_of_cell_coords get_fph_2d_array_of_cell_coords proc~packing_vector_into_2darray_ packing_vector_into_2Darray_ proc~get_fph_2d_array_of_cell_coords->proc~packing_vector_into_2darray_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_fph_2d_array_of_cell_coords.html"},{"title":"get_face2vertices – Droplets Simulation","text":"public subroutine get_face2vertices(this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this Contents None","tags":"","loc":"proc\\get_face2vertices.html"},{"title":"get_cell_offsets – Droplets Simulation","text":"public subroutine get_cell_offsets(this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this Contents None","tags":"","loc":"proc\\get_cell_offsets.html"},{"title":"get_face2cells – Droplets Simulation","text":"public subroutine get_face2cells(this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this Contents None","tags":"","loc":"proc\\get_face2cells.html"},{"title":"get_cell2faces – Droplets Simulation","text":"public subroutine get_cell2faces(this) Uses terminalControler_m proc~~get_cell2faces~~UsesGraph proc~get_cell2faces get_cell2faces module~terminalcontroler_m terminalControler_m proc~get_cell2faces->module~terminalcontroler_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this Calls proc~~get_cell2faces~~CallsGraph proc~get_cell2faces get_cell2faces proc~set_formattc set_formatTC proc~get_cell2faces->proc~set_formattc interface~print_progress print_progress proc~get_cell2faces->interface~print_progress proc~append2list_int append2list_int proc~get_cell2faces->proc~append2list_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_cell2faces.html"},{"title":"get_fph_boundFaceIDs – Droplets Simulation","text":"public subroutine get_fph_boundFaceIDs(this, num_boundFaces) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this integer, intent(out) :: num_boundFaces Calls proc~~get_fph_boundfaceids~~CallsGraph proc~get_fph_boundfaceids get_fph_boundFaceIDs proc~append2list_int append2list_int proc~get_fph_boundfaceids->proc~append2list_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_fph_boundfaceids.html"},{"title":"get_fph_faceCenter – Droplets Simulation","text":"public subroutine get_fph_faceCenter(this, face_center) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this real(kind=4), intent(out), allocatable :: face_center (:,:) Contents None","tags":"","loc":"proc\\get_fph_facecenter.html"},{"title":"get_fph_boundFaceCenter – Droplets Simulation","text":"public subroutine get_fph_boundFaceCenter(this, bound_center) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this real(kind=4), intent(inout), allocatable :: bound_center (:,:) Contents None","tags":"","loc":"proc\\get_fph_boundfacecenter.html"},{"title":"output_fph_cell2face – Droplets Simulation","text":"public subroutine output_fph_cell2face(this, dir) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this character, intent(in) :: dir Contents None","tags":"","loc":"proc\\output_fph_cell2face.html"},{"title":"output_fph_boundFace – Droplets Simulation","text":"public subroutine output_fph_boundFace(this, dir) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this character, intent(in) :: dir Contents None","tags":"","loc":"proc\\output_fph_boundface.html"},{"title":"get_cell2boundFace – Droplets Simulation","text":"public subroutine get_cell2boundFace(this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this Calls proc~~get_cell2boundface~~CallsGraph proc~get_cell2boundface get_cell2boundFace proc~append2list_int append2list_int proc~get_cell2boundface->proc~append2list_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_cell2boundface.html"},{"title":"get_fph_adjacentCellIDs – Droplets Simulation","text":"public subroutine get_fph_adjacentCellIDs(this) Uses terminalControler_m proc~~get_fph_adjacentcellids~~UsesGraph proc~get_fph_adjacentcellids get_fph_adjacentCellIDs module~terminalcontroler_m terminalControler_m proc~get_fph_adjacentcellids->module~terminalcontroler_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this Calls proc~~get_fph_adjacentcellids~~CallsGraph proc~get_fph_adjacentcellids get_fph_adjacentCellIDs proc~set_formattc set_formatTC proc~get_fph_adjacentcellids->proc~set_formattc interface~print_progress print_progress proc~get_fph_adjacentcellids->interface~print_progress proc~append2list_int append2list_int proc~get_fph_adjacentcellids->proc~append2list_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_fph_adjacentcellids.html"},{"title":"output_fph_adjacentCell – Droplets Simulation","text":"public subroutine output_fph_adjacentCell(this, dir) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this character, intent(in) :: dir Contents None","tags":"","loc":"proc\\output_fph_adjacentcell.html"},{"title":"output_fph_vtk – Droplets Simulation","text":"public subroutine output_fph_vtk(this, dir) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this character, intent(in) :: dir Contents None","tags":"","loc":"proc\\output_fph_vtk.html"},{"title":"search_fph_vector_data – Droplets Simulation","text":"public subroutine search_fph_vector_data(this, key, vector) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this character, intent(in) :: key real(kind=4), intent(inout), allocatable :: vector (:,:) Calls proc~~search_fph_vector_data~~CallsGraph proc~search_fph_vector_data search_fph_vector_data proc~packing_vector_into_2darray_ packing_vector_into_2Darray_ proc~search_fph_vector_data->proc~packing_vector_into_2darray_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\search_fph_vector_data.html"},{"title":"packing_vector_into_2Darray_ – Droplets Simulation","text":"public subroutine packing_vector_into_2Darray_(array, x, y, z) 実数のベクトル配列を2次元配列に詰め直す Arguments Type Intent Optional Attributes Name real(kind=4), intent(out), allocatable :: array (:,:) real(kind=4), intent(in) :: x (:) real(kind=4), intent(in) :: y (:) real(kind=4), intent(in) :: z (:) Called by proc~~packing_vector_into_2darray_~~CalledByGraph proc~packing_vector_into_2darray_ packing_vector_into_2Darray_ proc~get_fph_2d_array_of_point_coords get_fph_2d_array_of_point_coords proc~get_fph_2d_array_of_point_coords->proc~packing_vector_into_2darray_ proc~get_fph_2d_array_of_cell_coords get_fph_2d_array_of_cell_coords proc~get_fph_2d_array_of_cell_coords->proc~packing_vector_into_2darray_ proc~search_fph_vector_data search_fph_vector_data proc~search_fph_vector_data->proc~packing_vector_into_2darray_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\packing_vector_into_2darray_.html"},{"title":"get_cell_data_from_cellvertices – Droplets Simulation","text":"public subroutine get_cell_data_from_cellvertices(cell_data, cell2vertices, point_data) 各セル毎の頂点配列に関連する節点中心データからセル中心データを構築する. \n値はセルを構成する節点データの算術平均として計算する. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: cell_data (:) 出力されるセル中心データ. integer, intent(in) :: cell2vertices (:,:) 頂点配列. integer, intent(in) :: point_data (:) 任意の節点データ. Contents None","tags":"","loc":"proc\\get_cell_data_from_cellvertices.html"},{"title":"read_textRecord – Droplets Simulation","text":"public subroutine read_textRecord(filename, array) TXTファイルを、全行読み込む。\n1行あたりの文字数は引数に依存。 Arguments Type Intent Optional Attributes Name character, intent(in) :: filename ファイル名（パス） character, intent(out), allocatable :: array (:) 文字列配列\n要素数はallocatableだが、1要素あたりの文字数は予め指定 Called by proc~~read_textrecord~~CalledByGraph proc~read_textrecord read_textRecord proc~case_check case_check proc~case_check->proc~read_textrecord program~cube2usg CUBE2USG program~cube2usg->proc~read_textrecord program~dropletcount dropletCount program~dropletcount->proc~case_check program~translate translate program~translate->proc~case_check program~main MAIN program~main->proc~case_check Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\read_textrecord.html"},{"title":"read_CSV – Droplets Simulation","text":"public interface read_CSV CSV読込手続き Called by interface~~read_csv~~CalledByGraph interface~read_csv read_CSV proc~get_box_array get_box_array proc~get_box_array->interface~read_csv program~boxflowfield boxFlowField program~boxflowfield->proc~get_box_array program~dropletcount dropletCount program~dropletcount->proc~get_box_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures read_csv_dble read_csv_int read_csv_char Module Procedures private subroutine read_csv_dble(filename, matrix, column, header) Arguments Type Intent Optional Attributes Name character, intent(in) :: filename double precision, intent(inout), allocatable :: matrix (:,:) integer, intent(in), optional :: column logical, optional :: header private subroutine read_csv_int(filename, matrix, column, header) Arguments Type Intent Optional Attributes Name character, intent(in) :: filename integer, intent(inout), allocatable :: matrix (:,:) integer, intent(in), optional :: column logical, optional :: header private subroutine read_csv_char(filename, matrix, column, header) Arguments Type Intent Optional Attributes Name character, intent(in) :: filename character, intent(inout), allocatable :: matrix (:,:) integer, intent(in), optional :: column logical, optional :: header","tags":"","loc":"interface\\read_csv.html"},{"title":"heap_sort – Droplets Simulation","text":"public function heap_sort(array_origin) result(array_sorted) ヒープソート Arguments Type Intent Optional Attributes Name type( content_t ), intent(in) :: array_origin (:) Return Value type( content_t )(size(array_origin)) Called by proc~~heap_sort~~CalledByGraph proc~heap_sort heap_sort proc~test_sort test_sort proc~test_sort->proc~heap_sort program~sort_test sort_test program~sort_test->proc~test_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\heap_sort.html"},{"title":"real2content – Droplets Simulation","text":"public function real2content(real_array) result(content_array) 実数型配列をコンテンツ配列に変換する Arguments Type Intent Optional Attributes Name real, intent(in) :: real_array (:) Return Value type( content_t ),allocatable,(:) Called by proc~~real2content~~CalledByGraph proc~real2content real2content proc~kdtree_ kdTree_ proc~kdtree_->proc~real2content proc~test_sort test_sort proc~test_sort->proc~real2content program~kdtree_test kdTree_test program~kdtree_test->proc~kdtree_ program~sort_test sort_test program~sort_test->proc~test_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\real2content.html"},{"title":"merge_sort – Droplets Simulation","text":"public function merge_sort(array_origin) result(array_sorted) マージソート Arguments Type Intent Optional Attributes Name type( content_t ), intent(in) :: array_origin (:) Return Value type( content_t )(size(array_origin)) Called by proc~~merge_sort~~CalledByGraph proc~merge_sort merge_sort proc~kdtree_ kdTree_ proc~kdtree_->proc~merge_sort proc~test_sort test_sort proc~test_sort->proc~merge_sort program~kdtree_test kdTree_test program~kdtree_test->proc~kdtree_ program~sort_test sort_test program~sort_test->proc~test_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\merge_sort.html"},{"title":"reset_formatTC – Droplets Simulation","text":"public subroutine reset_formatTC() Arguments None Contents None","tags":"","loc":"proc\\reset_formattc.html"},{"title":"set_formatTC – Droplets Simulation","text":"public subroutine set_formatTC(fmt_str) 進捗を表示するためのフォーマットを指定\n指定時に改行が起こる（あとで戻ってくるため） Arguments Type Intent Optional Attributes Name character, intent(in) :: fmt_str Called by proc~~set_formattc~~CalledByGraph proc~set_formattc set_formatTC proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->proc~set_formattc proc~get_cell2faces get_cell2faces proc~get_cell2faces->proc~set_formattc program~boxflowfield boxFlowField program~boxflowfield->proc~set_formattc proc~kdtree_ kdTree_ proc~kdtree_->proc~set_formattc proc~get_fph_adjacentcellids get_fph_adjacentCellIDs proc~get_fph_adjacentcellids->proc~set_formattc proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~search_nodeinfo program~kdtree_test kdTree_test program~kdtree_test->proc~kdtree_ program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\set_formattc.html"},{"title":"print_sameLine – Droplets Simulation","text":"public subroutine print_sameLine(str) Arguments Type Intent Optional Attributes Name character, intent(in) :: str Contents None","tags":"","loc":"proc\\print_sameline.html"},{"title":"print_progress – Droplets Simulation","text":"public interface print_progress 進捗を表示する Called by interface~~print_progress~~CalledByGraph interface~print_progress print_progress proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->interface~print_progress proc~get_cell2faces get_cell2faces proc~get_cell2faces->interface~print_progress program~boxflowfield boxFlowField program~boxflowfield->interface~print_progress proc~kdtree_ kdTree_ proc~kdtree_->interface~print_progress proc~get_fph_adjacentcellids get_fph_adjacentCellIDs proc~get_fph_adjacentcellids->interface~print_progress proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~search_nodeinfo program~kdtree_test kdTree_test program~kdtree_test->proc~kdtree_ program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures print_progress_int print_progress_real Module Procedures private subroutine print_progress_int(array) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) private subroutine print_progress_real(array) Arguments Type Intent Optional Attributes Name real, intent(in) :: array (:)","tags":"","loc":"interface\\print_progress.html"},{"title":"TimeKeeper_ – Droplets Simulation","text":"public function TimeKeeper_() Arguments None Return Value type( TimeKeeper ) Called by proc~~timekeeper_~~CalledByGraph proc~timekeeper_ TimeKeeper_ proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->proc~timekeeper_ proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~search_nodeinfo program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\timekeeper_.html"},{"title":"nowDateAndTime – Droplets Simulation","text":"public function nowDateAndTime() result(str) Arguments None Return Value character,allocatable Contents None","tags":"","loc":"proc\\nowdateandtime.html"},{"title":"second2HMS – Droplets Simulation","text":"public function second2HMS(seconds) result(str) Arguments Type Intent Optional Attributes Name real, intent(in) :: seconds Return Value character(len=9) Contents None","tags":"","loc":"proc\\second2hms.html"},{"title":"get_MinMaxCDN – Droplets Simulation","text":"public function get_MinMaxCDN(node) result(MinMax) 節点群の座標の最大最小を返す Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: node (:) Return Value real(3,2) Contents None","tags":"","loc":"proc\\get_minmaxcdn.html"},{"title":"get_cellCenters – Droplets Simulation","text":"public function get_cellCenters(node, cell) result(centers) すべてのセル重心を計算し、配列で返す Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: node (:) class( cell_t ), intent(in) :: cell (:) Return Value real,allocatable,(:,:) Called by proc~~get_cellcenters~~CalledByGraph proc~get_cellcenters get_cellCenters proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->proc~get_cellcenters proc~solve_correspondence solve_correspondence proc~solve_correspondence->proc~search_nodeinfo program~cube2usg CUBE2USG program~cube2usg->proc~solve_correspondence Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\get_cellcenters.html"},{"title":"FlowFieldUnstructuredGrid_ – Droplets Simulation","text":"public function FlowFieldUnstructuredGrid_(FlowFieldFile) result(grid) Uses path_operator_m proc~~flowfieldunstructuredgrid_~~UsesGraph proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ module~path_operator_m path_operator_m proc~flowfieldunstructuredgrid_->module~path_operator_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. 流れ場のコンストラクタ\n流れ場ファイルの読み込み、前処理、kd-treeの構築を行う Arguments Type Intent Optional Attributes Name character, intent(in) :: FlowFieldFile 流れ場ファイル名 Return Value type( FlowFieldUnstructuredGrid ) Calls proc~~flowfieldunstructuredgrid_~~CallsGraph proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ proc~get_dirfrompath get_DirFromPath proc~flowfieldunstructuredgrid_->proc~get_dirfrompath Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~flowfieldunstructuredgrid_~~CalledByGraph proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ proc~flowfield_ FlowField_ proc~flowfield_->proc~flowfieldunstructuredgrid_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\flowfieldunstructuredgrid_.html"},{"title":"FlowFieldUnstructuredGrid_withMeshFile – Droplets Simulation","text":"public function FlowFieldUnstructuredGrid_withMeshFile(FlowFieldFile, meshFile) result(grid) Uses path_operator_m proc~~flowfieldunstructuredgrid_withmeshfile~~UsesGraph proc~flowfieldunstructuredgrid_withmeshfile FlowFieldUnstructuredGrid_withMeshFile module~path_operator_m path_operator_m proc~flowfieldunstructuredgrid_withmeshfile->module~path_operator_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. 流れ場のコンストラクタ(meshファイルと流速データファイルが分かれている場合)\n流れ場ファイルの読み込み、前処理、kd-treeの構築を行う Arguments Type Intent Optional Attributes Name character, intent(in) :: FlowFieldFile 流速データファイル名 character, intent(in) :: meshFile メッシュファイル Return Value type( FlowFieldUnstructuredGrid ) Calls proc~~flowfieldunstructuredgrid_withmeshfile~~CallsGraph proc~flowfieldunstructuredgrid_withmeshfile FlowFieldUnstructuredGrid_withMeshFile proc~get_dirfrompath get_DirFromPath proc~flowfieldunstructuredgrid_withmeshfile->proc~get_dirfrompath Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~flowfieldunstructuredgrid_withmeshfile~~CalledByGraph proc~flowfieldunstructuredgrid_withmeshfile FlowFieldUnstructuredGrid_withMeshFile proc~flowfield_ FlowField_ proc~flowfield_->proc~flowfieldunstructuredgrid_withmeshfile program~boxflowfield boxFlowField program~boxflowfield->proc~flowfieldunstructuredgrid_withmeshfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\flowfieldunstructuredgrid_withmeshfile.html"},{"title":"norm2_squared – Droplets Simulation","text":"public function norm2_squared(a) ベクトルのL2ノルムの2乗を返す\n組み込み関数norm2より約5倍速い(かも) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) Return Value real Contents None","tags":"","loc":"proc\\norm2_squared.html"},{"title":"cross_product – Droplets Simulation","text":"public interface cross_product ベクトルの外積を返す Called by interface~~cross_product~~CalledByGraph interface~cross_product cross_product proc~volume_tetra volume_tetra proc~volume_tetra->interface~cross_product proc~insidejudgment_tetra insideJudgment_tetra proc~insidejudgment_tetra->proc~volume_tetra proc~insidejudgment_tetra_check insideJudgment_tetra_check proc~insidejudgment_tetra_check->proc~volume_tetra program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->proc~insidejudgment_tetra program~cellcentercalc_test->proc~insidejudgment_tetra_check program~geometry_test geometry_test program~geometry_test->proc~insidejudgment_tetra Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures cross_product_dble cross_product_real Module Procedures private function cross_product_dble(a, b) result(cross) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (3) double precision, intent(in) :: b (3) Return Value double precision(3) private function cross_product_real(a, b) result(cross) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) real, intent(in) :: b (3) Return Value real(3)","tags":"","loc":"interface\\cross_product.html"},{"title":"normalize_vector – Droplets Simulation","text":"public interface normalize_vector 単位ベクトルを返す Contents Module Procedures normalize_vector_dble normalize_vector_real Module Procedures private function normalize_vector_dble(a) result(normalized) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (3) Return Value double precision(3) private function normalize_vector_real(a) result(normalized) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) Return Value real(3)","tags":"","loc":"interface\\normalize_vector.html"},{"title":"dropletCounter – Droplets Simulation","text":"public function dropletCounter(droplets, name) 指定された状態にある飛沫数をカウント Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) character, intent(in) :: name キーワード（total, floating, etc.） Return Value integer Contents None","tags":"","loc":"proc\\dropletcounter.html"},{"title":"dropletIDinBox – Droplets Simulation","text":"public function dropletIDinBox(droplets, min_cdn, max_cdn, status) result(ID_array) 直方体領域内の飛沫のID配列を返す Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) double precision, intent(in) :: min_cdn (3) 直方体領域の最小座標 double precision, intent(in) :: max_cdn (3) 直方体領域の最大座標 integer, intent(in), optional :: status 状態 Return Value integer,allocatable,(:) Called by proc~~dropletidinbox~~CalledByGraph proc~dropletidinbox dropletIDinBox program~dropletcount dropletCount program~dropletcount->proc~dropletidinbox Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\dropletidinbox.html"},{"title":"dropletTotalVolume – Droplets Simulation","text":"public function dropletTotalVolume(droplets) 配列内の全飛沫の総体積（無次元）を計算 Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) Return Value doubleprecision Called by proc~~droplettotalvolume~~CalledByGraph proc~droplettotalvolume dropletTotalVolume program~dropletcount dropletCount program~dropletcount->proc~droplettotalvolume Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\droplettotalvolume.html"},{"title":"dropletIDinState – Droplets Simulation","text":"public function dropletIDinState(droplets, status) result(ID_array) 任意の状態の飛沫のID配列を返す Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) character, intent(in) :: status Return Value integer,allocatable,(:) Contents None","tags":"","loc":"proc\\dropletidinstate.html"},{"title":"read_backup – Droplets Simulation","text":"public function read_backup(fname) result(droplets) backupファイルを読み込み、飛沫配列を返す Arguments Type Intent Optional Attributes Name character, intent(in) :: fname Return Value type( virusDroplet_t ),allocatable,(:) Called by proc~~read_backup~~CalledByGraph proc~read_backup read_backup program~dropletcount dropletCount program~dropletcount->proc~read_backup program~translate translate program~translate->proc~read_backup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\read_backup.html"},{"title":"survival_check – Droplets Simulation","text":"public subroutine survival_check(droplets, time) 飛沫の不活性化判定 Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) double precision, intent(in) :: time 現在時刻（無次元） Called by proc~~survival_check~~CalledByGraph proc~survival_check survival_check proc~rundropletssimulation RunDropletsSimulation proc~rundropletssimulation->proc~survival_check program~main MAIN program~main->proc~rundropletssimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\survival_check.html"},{"title":"get_dropletsArea – Droplets Simulation","text":"public subroutine get_dropletsArea(droplets, AreaMin, AreaMax) 飛沫配列内の飛沫の座標の最大最小を返す Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) double precision, intent(out) :: AreaMin (3) double precision, intent(out) :: AreaMax (3) Contents None","tags":"","loc":"proc\\get_dropletsarea.html"},{"title":"coalescence_check – Droplets Simulation","text":"public subroutine coalescence_check(droplets, stat) 合体判定 Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) integer, intent(out), optional :: stat Contents None","tags":"","loc":"proc\\coalescence_check.html"},{"title":"output_backup – Droplets Simulation","text":"public subroutine output_backup(droplets, fname) backupファイルの出力。\n配列をループ使わずそのまま書き出すほうが多分ファイルサイズ効率が良いので、いつか修正したい。 Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) character, intent(in) :: fname Called by proc~~output_backup~~CalledByGraph proc~output_backup output_backup program~translate translate program~translate->proc~output_backup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\output_backup.html"},{"title":"output_droplet_VTK – Droplets Simulation","text":"public subroutine output_droplet_VTK(droplets, fname, deadline) VTK形式でファイル出力 Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) character, intent(in) :: fname logical, optional :: deadline Called by proc~~output_droplet_vtk~~CalledByGraph proc~output_droplet_vtk output_droplet_VTK program~translate translate program~translate->proc~output_droplet_vtk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\output_droplet_vtk.html"},{"title":"output_droplet_CSV – Droplets Simulation","text":"public subroutine output_droplet_CSV(droplets, fname, time, initial) CSV形式で時系列データ出力 Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) character, intent(in) :: fname double precision, intent(in) :: time logical, intent(in) :: initial Contents None","tags":"","loc":"proc\\output_droplet_csv.html"},{"title":"set_initialRadius – Droplets Simulation","text":"public subroutine set_initialRadius(droplets, radius) 飛沫の初期半径を配列からセットする Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) double precision, intent(in) :: radius (:) Contents None","tags":"","loc":"proc\\set_initialradius.html"},{"title":"set_radiusLowerLimit – Droplets Simulation","text":"public subroutine set_radiusLowerLimit(droplets, lowerLimitRatio) 飛沫の蒸発限界半径をセットする Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) double precision, intent(in) :: lowerLimitRatio 限界半径と初期半径の比 Contents None","tags":"","loc":"proc\\set_radiuslowerlimit.html"},{"title":"set_virusDeadline – Droplets Simulation","text":"public subroutine set_virusDeadline(droplets, deadline) 飛沫の寿命を配列からセットする Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) double precision, intent(in) :: deadline (:) Contents None","tags":"","loc":"proc\\set_virusdeadline.html"},{"title":"set_dropletStatus – Droplets Simulation","text":"public subroutine set_dropletStatus(droplets, status, ID) 飛沫の状態を一気にセットする\n特定のIDの飛沫だけセットしたい場合は、ID配列を引数に渡す Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) character, intent(in) :: status integer, intent(in), optional :: ID (:) Contents None","tags":"","loc":"proc\\set_dropletstatus.html"},{"title":"UnstructuredGrid_inVTK_ – Droplets Simulation","text":"public function UnstructuredGrid_inVTK_(cdn, vertices, types) Arguments Type Intent Optional Attributes Name real, intent(in) :: cdn (:,:) integer, intent(in) :: vertices (:,:) integer, intent(in) :: types (:) Return Value type( UnstructuredGrid_inVTK ) Called by proc~~unstructuredgrid_invtk_~~CalledByGraph proc~unstructuredgrid_invtk_ UnstructuredGrid_inVTK_ proc~output_boxvtk output_boxVTK proc~output_boxvtk->proc~unstructuredgrid_invtk_ proc~output_boxvtk~2 output_boxVTK proc~output_boxvtk~2->proc~unstructuredgrid_invtk_ program~boxflowfield boxFlowField program~boxflowfield->proc~output_boxvtk program~dropletcount dropletCount program~dropletcount->proc~output_boxvtk~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\unstructuredgrid_invtk_.html"},{"title":"plane_equation – Droplets Simulation","text":"function plane_equation(x, y) result(z) テスト用テトラの斜面の方程式 Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y Return Value real Called by proc~~plane_equation~~CalledByGraph proc~plane_equation plane_equation program~geometry_test geometry_test program~geometry_test->proc~plane_equation Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\plane_equation.html"},{"title":"test – Droplets Simulation","text":"subroutine test() 乱数で発生させた点に対して、kdTreeによる探索結果と、厳密なnearest探索結果が一致するかどうかをテスト Arguments None Called by proc~~test~~CalledByGraph proc~test test program~kdtree_test kdTree_test program~kdtree_test->proc~test Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\test.html"},{"title":"test_sort – Droplets Simulation","text":"subroutine test_sort(array_correct, sort_mode) 正解配列（ソート済み配列）を引数に取り、それをシャッフルしたのちにソートを行う\n正解配列とソート後の配列を比較し、ソートが機能しているかを検証 Arguments Type Intent Optional Attributes Name real, intent(in) :: array_correct (:) character, intent(in) :: sort_mode Calls proc~~test_sort~~CallsGraph proc~test_sort test_sort proc~fisheryates_shuffle FisherYates_shuffle proc~test_sort->proc~fisheryates_shuffle proc~real2content real2content proc~test_sort->proc~real2content proc~merge_sort merge_sort proc~test_sort->proc~merge_sort proc~heap_sort heap_sort proc~test_sort->proc~heap_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_sort~~CalledByGraph proc~test_sort test_sort program~sort_test sort_test program~sort_test->proc~test_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc\\test_sort.html"},{"title":"adjacencySolver_m – Droplets Simulation","text":"セルの隣接関係解決モジュール Contents Variables None Subroutines solve_BoundaryAndAdjacency Variables Type Visibility Attributes Name Initial integer, public, parameter :: None = -1 整数配列中の欠損値の表現 Subroutines public subroutine solve_BoundaryAndAdjacency (cellVertices, cellBoundFaces, triangleBoundFaceVertices, adjacentCellIDArray) 境界面と隣接関係を、それぞれ配列に格納 Arguments Type Intent Optional Attributes Name integer, intent(in) :: cellVertices (:,:) セルの頂点ID配列（頂点ID,セルID） integer, intent(out), allocatable :: cellBoundFaces (:,:) セルの境界面ID配列（境界面ID,セルID） integer, intent(out), allocatable :: triangleBoundFaceVertices (:,:) 境界面の頂点ID配列（頂点ID,境界面ID） integer, intent(out), allocatable :: adjacentCellIDArray (:,:) セルの隣接セルID配列（隣接セルID,セルID）","tags":"","loc":"module\\adjacencysolver_m.html"},{"title":"array_m – Droplets Simulation","text":"Used by module~~array_m~~UsedByGraph module~array_m array_m proc~read_nodeinfo read_nodeInfo proc~read_nodeinfo->module~array_m program~cube2usg CUBE2USG program~cube2usg->module~array_m program~sort_test sort_test program~sort_test->module~array_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions mean_2dArray FisherYates_shuffle Subroutines output_2dArray_asBinary read_2dArray_asBinary read_1dArray_real Functions public function mean_2dArray (array) result(mean) Arguments Type Intent Optional Attributes Name real, intent(in) :: array (:,:) Return Value real(size(array,dim=2)) public function FisherYates_shuffle (a) result(b) フィッシャー・イェーツのシャッフル\n参考：https://programming-place.net/ppp/contents/algorithm/other/002.html Arguments Type Intent Optional Attributes Name real, intent(in) :: a (:) Return Value real(size(a)) Subroutines public subroutine output_2dArray_asBinary (fname, array) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname real, intent(in) :: array (:,:) public subroutine read_2dArray_asBinary (fname, array) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname real, intent(out), allocatable :: array (:,:) public subroutine read_1dArray_real (fname, array) Arguments Type Intent Optional Attributes Name character, intent(in) :: fname real, intent(out), allocatable :: array (:)","tags":"","loc":"module\\array_m.html"},{"title":"boxCounter_m – Droplets Simulation","text":"Used by module~~boxcounter_m~~UsedByGraph module~boxcounter_m boxCounter_m program~boxflowfield boxFlowField program~boxflowfield->module~boxcounter_m program~dropletcount dropletCount program~dropletcount->module~boxcounter_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types boxCounter Functions get_box_array get_FlagID Subroutines add_Flag Derived Types type, public :: boxCounter Components Type Visibility Attributes Name Initial real, public :: center (3) real, public :: width (3) real, public :: min_cdn (3) real, public :: max_cdn (3) logical, public, allocatable :: Flag (:) procedure, public :: add_Flag procedure, public :: get_FlagID Functions public function get_box_array (dir, num_Flag) result(new_box_array) Arguments Type Intent Optional Attributes Name character, intent(in) :: dir integer, intent(in) :: num_Flag Return Value type( boxCounter ),allocatable, (:) public function get_FlagID (self) result(id_array) Arguments Type Intent Optional Attributes Name class( boxCounter ) :: self Return Value integer,allocatable, (:) Subroutines public subroutine add_Flag (self, id_array) Arguments Type Intent Optional Attributes Name class( boxCounter ) :: self integer, intent(in) :: id_array (:)","tags":"","loc":"module\\boxcounter_m.html"},{"title":"caseName_m – Droplets Simulation","text":"Used by module~~casename_m~~UsedByGraph module~casename_m caseName_m program~dropletcount dropletCount program~dropletcount->module~casename_m program~translate translate program~translate->module~casename_m program~main MAIN program~main->module~casename_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines case_check Subroutines public subroutine case_check (caseName_array) case名をキーボードから取得する。\nTXTファイルを指定すると、それを全行読み込んで配列に格納。 Arguments Type Intent Optional Attributes Name character, intent(out), allocatable :: caseName_array (:)","tags":"","loc":"module\\casename_m.html"},{"title":"conditionValue_m – Droplets Simulation","text":"飛沫計算用の諸条件を取り扱う Used by module~~conditionvalue_m~~UsedByGraph module~conditionvalue_m conditionValue_m program~boxflowfield boxFlowField program~boxflowfield->module~conditionvalue_m program~dropletcount dropletCount program~dropletcount->module~conditionvalue_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types conditionValue_t Functions read_condition Derived Types type, public :: conditionValue_t 条件値クラス\n条件指定ファイル（namelist）を読み込んだ結果を格納する\n飛沫計算用の諸条件をまとめた構造体 Components Type Visibility Attributes Name Initial double precision, public :: dt double precision, public :: L double precision, public :: U double precision, public :: direction_g (3) character, public, allocatable :: initialDistributionFName integer, public :: restart integer, public :: stepEnd integer, public :: outputInterval integer, public :: num_drop integer, public :: periodicGeneration real, public :: T real, public :: RH character, public, allocatable :: path2FlowFile character, public, allocatable :: meshFile double precision, public :: DT_FLOW integer, public :: OFFSET integer, public :: INTERVAL_FLOW integer, public :: LoopHead integer, public :: LoopTail procedure, public :: isInitialDistributionSpecified 飛沫初期分布ファイルが指定されたか否かを返す procedure, public :: isMeshFileSpecified メッシュファイルが別途指定されたか否かを返す Functions public function read_condition (dir) result(self) 条件ファイルを読み込み、結果を構造体で返す。\nこのサブルーチン実装当時、構造体をそのままnamelistにできることを知らず、わざわざ変数ひとつひとつ定義した。\n現在ここを変えると進行中のプロジェクト（オフィス飛沫計算など）に影響が出るおそれがあり、触れない。\nいつか修正したい。 Arguments Type Intent Optional Attributes Name character, intent(in) :: dir Return Value type( conditionValue_t )","tags":"","loc":"module\\conditionvalue_m.html"},{"title":"dropletEquation_m – Droplets Simulation","text":"飛沫の方程式モジュール Used by module~~dropletequation_m~~UsedByGraph module~dropletequation_m dropletEquation_m module~dropletgenerator_m dropletGenerator_m module~dropletgenerator_m->module~dropletequation_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~dropletequation_m module~dropletmotionsimulation->module~dropletgenerator_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types BasicParameter DropletEquationSolver Functions BasicParameter_ DropletEquationSolver_ Derived Types type, public :: BasicParameter 基礎変数クラス\n時間間隔や代表値を格納 Components Type Visibility Attributes Name Initial double precision, public :: dt double precision, public :: L double precision, public :: U double precision, public :: Re procedure, public :: TimeStep2RealTime Type-Bound Procedures procedure, public :: repValue => representativeValue type, public, extends( BasicParameter ) :: DropletEquationSolver 飛沫方程式ソルバクラス\n蒸発方程式や運動方程式を解くメソッドを保持 Components Type Visibility Attributes Name Initial double precision, public :: dt double precision, public :: L double precision, public :: U double precision, public :: Re procedure, public :: TimeStep2RealTime double precision, public :: coeff_drdt 半径変化率の無次元係数 double precision, public :: G (3) 無次元重力加速度 real, public :: T real, public :: RH double precision, public :: minimumRadiusRatio double precision, public, allocatable :: minimumRadiusMatrix (:,:) procedure, public :: set_gravity_acceleration procedure, public :: set_dropletEnvironment procedure, public :: dropletEnvironment procedure, public :: set_coeff_drdt procedure, public :: set_minimumRadiusRatio procedure, public :: next_position procedure, public :: next_velocity procedure, public :: get_radiusLowerLimitRatio procedure, public :: solve_motionEquation Type-Bound Procedures procedure, public :: repValue => representativeValue procedure, public :: evaporationEq => evaporationEquation Functions public function BasicParameter_ (delta_t, L_represent, U_represent) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: delta_t double precision, intent(in) :: L_represent double precision, intent(in) :: U_represent Return Value type( BasicParameter ) public function DropletEquationSolver_ (delta_t, L_represent, U_represent, direction_g, Temperature, RelativeHumidity) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: delta_t double precision, intent(in) :: L_represent double precision, intent(in) :: U_represent double precision, intent(in) :: direction_g (3) real, intent(in) :: Temperature real, intent(in) :: RelativeHumidity Return Value type( DropletEquationSolver )","tags":"","loc":"module\\dropletequation_m.html"},{"title":"dropletGenerator_m – Droplets Simulation","text":"Uses dropletEquation_m virusDroplet_m module~~dropletgenerator_m~~UsesGraph module~dropletgenerator_m dropletGenerator_m module~dropletequation_m dropletEquation_m module~dropletgenerator_m->module~dropletequation_m module~virusdroplet_m virusDroplet_m module~dropletgenerator_m->module~virusdroplet_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~dropletgenerator_m~~UsedByGraph module~dropletgenerator_m dropletGenerator_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~dropletgenerator_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types SequentialArray DropletGenerator Functions DropletGenerator_ Derived Types type, public :: SequentialArray Components Type Visibility Attributes Name Initial procedure, public :: set_SequentialArray Type-Bound Procedures procedure, public :: get_value => get_valueFromSequentialArray procedure, public :: get_valueArray => get_valueArrayFromSequentialArray type, public :: DropletGenerator Components Type Visibility Attributes Name Initial type( DropletEquationSolver ), public, pointer :: equation type(placementBox), public, allocatable :: pBox_array (:) type( SequentialArray ), public :: initialRadiusArray type( SequentialArray ), public :: deadlineArray integer, public :: generateRate = 0 procedure, public :: set_dropletPlacementBox procedure, public :: calc_initialPosition Type-Bound Procedures procedure, public :: generateDroplet procedure, public :: periodicGeneration => dropletPeriodicGeneration Functions public function DropletGenerator_ (equation, radiusDistributionFile, positionDir, generationRate) Arguments Type Intent Optional Attributes Name type( DropletEquationSolver ), target :: equation character, intent(in) :: radiusDistributionFile character, intent(in) :: positionDir integer, intent(in) :: generationRate Return Value type( DropletGenerator )","tags":"","loc":"module\\dropletgenerator_m.html"},{"title":"dropletMotionSimulation – Droplets Simulation","text":"飛沫運動シミュレーションモジュール Uses virusDroplet_m flow_field_m timeKeeper_m dropletEquation_m dropletGenerator_m module~~dropletmotionsimulation~~UsesGraph module~dropletmotionsimulation dropletMotionSimulation module~dropletgenerator_m dropletGenerator_m module~dropletmotionsimulation->module~dropletgenerator_m module~timekeeper_m timeKeeper_m module~dropletmotionsimulation->module~timekeeper_m module~dropletequation_m dropletEquation_m module~dropletmotionsimulation->module~dropletequation_m module~virusdroplet_m virusDroplet_m module~dropletmotionsimulation->module~virusdroplet_m module~flow_field_m flow_field_m module~dropletmotionsimulation->module~flow_field_m module~dropletgenerator_m->module~dropletequation_m module~dropletgenerator_m->module~virusdroplet_m module~unstructuredgrid_m unstructuredGrid_m module~flow_field_m->module~unstructuredgrid_m module~kdtree_m kdTree_m module~unstructuredgrid_m->module~kdtree_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~vector_m vector_m module~unstructuredgrid_m->module~vector_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~dropletmotionsimulation~~UsedByGraph module~dropletmotionsimulation dropletMotionSimulation program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines read_basicSettingOnSimulation RunDropletsSimulation Subroutines public subroutine read_basicSettingOnSimulation () シミュレーションの基礎的な設定ファイルを読み込む Arguments None public subroutine RunDropletsSimulation (case_name) 飛沫運動シミュレーションの実行 Arguments Type Intent Optional Attributes Name character, intent(in) :: case_name ケースディレクトリ名","tags":"","loc":"module\\dropletmotionsimulation.html"},{"title":"flow_field_m – Droplets Simulation","text":"Uses unstructuredGrid_m module~~flow_field_m~~UsesGraph module~flow_field_m flow_field_m module~unstructuredgrid_m unstructuredGrid_m module~flow_field_m->module~unstructuredgrid_m module~kdtree_m kdTree_m module~unstructuredgrid_m->module~kdtree_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~vector_m vector_m module~unstructuredgrid_m->module~vector_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~flow_field_m~~UsedByGraph module~flow_field_m flow_field_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~flow_field_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types FlowField Functions FlowField_ Derived Types type, public, extends( FlowFieldUnstructuredGrid ) :: FlowField Components Type Visibility Attributes Name Initial type( node_t ), public, allocatable :: NODEs (:) 節点配列 type(cell_inFlow_t), public, allocatable :: CELLs (:) セル配列 type(boundaryTriangle_t), public, allocatable :: BoundFACEs (:) 境界面配列 type(boundaryTriangle_t), public, allocatable :: FACEs (:) type( kdTree ), public :: kd_tree kd-tree（近傍セル探索用） real, public :: MIN_CDN (3) 座標の最小値(xyz) real, public :: MAX_CDN (3) 座標の最大値(xyz) integer, public :: num_refCellSearchFalse = 0 参照セル探索結果が悪いと判断された回数 integer, public :: num_refCellSearch = 0 参照セル探索が行われた回数 logical, public :: fph_flag = .false. procedure, public :: set_cellCenter procedure, public :: set_cellThreshold procedure, public :: set_MinMaxCDN procedure, public :: point2cellVelocity procedure, public :: nearer_cell procedure, public :: AdjacencySolvingProcess procedure, public :: read_adjacency procedure, public :: read_boundaries procedure, public :: solve_adjacencyOnFlowFieldUnstructuredGrid procedure, public :: output_boundaries procedure, public :: output_adjacency procedure, public :: boundary_setting procedure, public :: output_STL procedure, public :: read_cell2face integer, public :: INTERVAL 気流ファイル出力間隔 integer, public :: LoopHead 流れ場ファイルのループの先頭 integer, public :: LoopTail 流れ場ファイルのループの末尾 integer, public :: OFFSET 流れ場と飛沫の間の時間ステップオフセット double precision, public :: DT 流体計算の時間間隔 integer, public :: STEP 時間ステップ integer, public :: NextUpdate 次に流れ場更新を行うべき時間ステップ character, public, allocatable :: FullFileName デフォルトの流れ場ファイル名 character, public, allocatable :: FileNameFormat 流れ場ファイルのファイル名のフォーマット文字列 procedure, public :: set_FileNameFormat procedure, public :: calc_NextUpdate procedure, public :: get_FileNumber procedure, public :: clamp_STEP Type-Bound Procedures procedure, public :: nearcell_check procedure, public :: nearest_cell procedure, public :: nearest_search_kdTree procedure, public :: nearest_search_exact procedure, public :: get_movementVectorOfBoundarySurface procedure, public :: get_flowVelocityInCELL procedure, public :: get_allOfCellCenters procedure, public :: get_cellCenterOf procedure, public :: get_MinMaxOfGrid procedure, public :: get_cellVerticesOf procedure, public :: get_info => get_gridInformation procedure, public :: read_FPH procedure, public :: read_FLD procedure, public :: read_INP procedure, public :: read_array => read_Array procedure, public :: read_VTK procedure, public :: updateWithFlowFieldFile procedure, public :: setupWithFlowFieldFile procedure, public :: search_refCELL procedure, public :: adhesionCheckOnBound procedure, public :: get_nearerSearchFalseRate procedure, public :: get_num_nearerSearchFalse procedure, public :: update => update_FlowField procedure, public :: isUpdateTiming procedure, public :: get_defaultFlowFileName procedure, public :: set_time => set_timeSTEPinFLOW procedure, public :: get_requiredFileName => get_requiredFlowFieldFileName Functions public function FlowField_ (time, PATH2FlowFile, DeltaT, OFFSET, outputINTERVAL, LoopHead, LoopTail, meshFile) result(flow_field) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: time 現在無次元時刻 character, intent(in) :: PATH2FlowFile double precision, intent(in) :: DeltaT 流体計算の時間間隔 integer, intent(in) :: OFFSET integer, intent(in) :: outputINTERVAL integer, intent(in) :: LoopHead integer, intent(in) :: LoopTail character, intent(in), optional :: meshFile Return Value type( FlowField )","tags":"","loc":"module\\flow_field_m.html"},{"title":"geometry_m – Droplets Simulation","text":"Uses vector_m module~~geometry_m~~UsesGraph module~geometry_m geometry_m module~vector_m vector_m module~geometry_m->module~vector_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~geometry_m~~UsedByGraph module~geometry_m geometry_m program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->module~geometry_m program~geometry_test geometry_test program~geometry_test->module~geometry_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions volume_tetra insideJudgment_tetra Subroutines insideJudgment_tetra_check Functions public function volume_tetra (vertices) result(volume) テトラの体積計算。 Arguments Type Intent Optional Attributes Name real, intent(in) :: vertices (3,4) Return Value real public function insideJudgment_tetra (vertices, point) result(isInside) 任意の点がテトラの内部にあるかどうかを判定する。\n点でテトラを分割したそれぞれの体積の和が、元々のテトラの体積を上回れば、点はテトラ外部にある。\nhttps://matcha-choco010.net/2018/03/14/point-in-tetrahedron/ Arguments Type Intent Optional Attributes Name real, intent(in) :: vertices (3,4) real, intent(in) :: point (3) Return Value logical Subroutines public subroutine insideJudgment_tetra_check (vertices, point, vol_sum, volume) テトラの内外判定の内部処理確認用サブルーチン Arguments Type Intent Optional Attributes Name real, intent(in) :: vertices (3,4) real, intent(in) :: point (3) real, intent(out) :: vol_sum 分割体積和 real, intent(out) :: volume テトラ体積","tags":"","loc":"module\\geometry_m.html"},{"title":"kdTree_m – Droplets Simulation","text":"kd-treeモジュール Uses sort_m module~~kdtree_m~~UsesGraph module~kdtree_m kdTree_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~kdtree_m~~UsedByGraph module~kdtree_m kdTree_m module~unstructuredgrid_m unstructuredGrid_m module~unstructuredgrid_m->module~kdtree_m program~kdtree_test kdTree_test program~kdtree_test->module~kdtree_m program~kdtree_test->module~unstructuredgrid_m module~flow_field_m flow_field_m module~flow_field_m->module~unstructuredgrid_m program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->module~unstructuredgrid_m program~boxflowfield boxFlowField program~boxflowfield->module~unstructuredgrid_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~flow_field_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types kdTree Functions kdTree_ Derived Types type, public :: kdTree Components Type Visibility Attributes Name Initial type(node_in_kdTree_t), public, allocatable :: node (:) procedure, public :: set_relation procedure, public :: saveAsDOT procedure, public :: saveAsTXT procedure, public :: read_kdTree Type-Bound Procedures procedure, public :: search => search_kdTree Functions public function kdTree_ (xyz_origin) Arguments Type Intent Optional Attributes Name real, intent(in) :: xyz_origin (:,:) Return Value type( kdTree )","tags":"","loc":"module\\kdtree_m.html"},{"title":"path_operator_m – Droplets Simulation","text":"Used by module~~path_operator_m~~UsedByGraph module~path_operator_m path_operator_m proc~flowfieldunstructuredgrid_withmeshfile FlowFieldUnstructuredGrid_withMeshFile proc~flowfieldunstructuredgrid_withmeshfile->module~path_operator_m program~kdtree_test kdTree_test program~kdtree_test->module~path_operator_m proc~flowfieldunstructuredgrid_ FlowFieldUnstructuredGrid_ proc~flowfieldunstructuredgrid_->module~path_operator_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions replace_str Subroutines make_directory get_DirFromPath Functions public function replace_str (str, from, to) Arguments Type Intent Optional Attributes Name character, intent(in) :: str character(len=1), intent(in) :: from character(len=1), intent(in) :: to Return Value character Subroutines public subroutine make_directory (path) Arguments Type Intent Optional Attributes Name character, intent(in) :: path public subroutine get_DirFromPath (path, directory, filename) Arguments Type Intent Optional Attributes Name character, intent(in) :: path character, intent(out), allocatable :: directory character, intent(out), optional allocatable :: filename","tags":"","loc":"module\\path_operator_m.html"},{"title":"plot3d_operator – Droplets Simulation","text":"CUBE出力ファイル形式：Plot3Dを取り扱うためのモジュール Used by module~~plot3d_operator~~UsedByGraph module~plot3d_operator plot3d_operator program~cube2usg CUBE2USG program~cube2usg->module~plot3d_operator Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types cube_inP3D plot3dNodeInfo Plot3dMesh Functions read_plot3d_multigrid Derived Types type, public :: cube_inP3D cube（Plot3D形式における立方体）構造体 Components Type Visibility Attributes Name Initial procedure, public :: areaOfCube procedure, public :: nearest_nodeID Type-Bound Procedures procedure, public :: isIncluded type, public :: plot3dNodeInfo 節点情報構造体 Components Type Visibility Attributes Name Initial integer, public :: cubeID integer, public :: nodeID (3) type, public :: Plot3dMesh Plot3Dメッシュクラス Components Type Visibility Attributes Name Initial type( cube_inP3D ), public, allocatable :: cubes (:) cube配列 procedure, public :: areaOfMesh Type-Bound Procedures procedure, public :: get_cubeShape procedure, public :: get_velocity procedure, public :: get_numCube procedure, public :: read_plot3d_function procedure, public :: nearestNodeInfo procedure, public :: get_cubeID_contains Functions public function read_plot3d_multigrid (fName) result(mesh) メッシュファイル（.g）を読み込んでメッシュクラスを返す関数 Arguments Type Intent Optional Attributes Name character, intent(in) :: fName Return Value type( Plot3dMesh )","tags":"","loc":"module\\plot3d_operator.html"},{"title":"SCF_file_reader_m – Droplets Simulation","text":"Contents Variables MissingValueSize EC_Scalar_HeadName EC_Vector_HeadName FC_Scalar_HeadName FC_Vector_HeadName OverlapEndLabel EC_Scalar_DataSize EC_Vector_DataSize FC_Scalar_DataSize FC_Vector_DataSize Derived Types EC_Scalar_t EC_Vector_t FC_Scalar_t FC_Vector_t data_name_list_t content_t scf_grid_t Functions open_binary_sequential_ get_fph_element_count get_fph_vertex_count get_fph_face_count append2list_int Subroutines read_SCF_file read_FPH_Header_data read_FPH_Main_data EC_Scalar_reader EC_Vector_reader FC_Scalar_reader FC_Vector_reader get_data_int32_ get_data_float64_ get_data_array_int32_ get_data_array_float64_ ignore_data_ get_data_char_ destructor get_fph_2d_array_of_point_coords get_fph_2d_array_of_cell_coords get_face2vertices get_cell_offsets get_face2cells get_cell2faces get_fph_boundFaceIDs get_fph_faceCenter get_fph_boundFaceCenter output_fph_cell2face output_fph_boundFace get_cell2boundFace get_fph_adjacentCellIDs output_fph_adjacentCell output_fph_vtk search_fph_vector_data packing_vector_into_2Darray_ Variables Type Visibility Attributes Name Initial real(kind=8), public, parameter :: MissingValueSize = 1.0d20 character(len=10), public, parameter :: EC_Scalar_HeadName = 'EC_Scalar:' character(len=10), public, parameter :: EC_Vector_HeadName = 'EC_Vector:' character(len=10), public, parameter :: FC_Scalar_HeadName = 'FC_Scalar:' character(len=10), public, parameter :: FC_Vector_HeadName = 'FC_Vector:' character(len=32), public, parameter :: OverlapEndLabel = 'OverlapEnd' integer, public, parameter :: EC_Scalar_DataSize = 50 integer, public, parameter :: EC_Vector_DataSize = 50 integer, public, parameter :: FC_Scalar_DataSize = 50 integer, public, parameter :: FC_Vector_DataSize = 50 Derived Types type, public :: EC_Scalar_t Components Type Visibility Attributes Name Initial character, public, allocatable :: name character, public, allocatable :: abbreviated_name integer(kind=4), public :: ndata real(kind=4), public, allocatable :: data (:) type, public :: EC_Vector_t Components Type Visibility Attributes Name Initial character, public, allocatable :: name character, public, allocatable :: abbreviated_name integer(kind=4), public :: ndata real(kind=4), public, allocatable :: x (:) real(kind=4), public, allocatable :: y (:) real(kind=4), public, allocatable :: z (:) type, public :: FC_Scalar_t Components Type Visibility Attributes Name Initial character, public, allocatable :: name character, public, allocatable :: abbreviated_name integer(kind=4), public :: ndata integer(kind=4), public, allocatable :: face_num (:) integer(kind=4), public, allocatable :: face_flag (:) real(kind=4), public, allocatable :: data (:) type, public :: FC_Vector_t Components Type Visibility Attributes Name Initial character, public, allocatable :: name character, public, allocatable :: abbreviated_name integer(kind=4), public :: ndata integer(kind=4), public, allocatable :: face_num (:) integer(kind=4), public, allocatable :: face_flag (:) real(kind=4), public, allocatable :: x (:) real(kind=4), public, allocatable :: y (:) real(kind=4), public, allocatable :: z (:) type, public :: data_name_list_t Components Type Visibility Attributes Name Initial character, public, allocatable :: name character, public, allocatable :: abbreviated_name type, public :: content_t Components Type Visibility Attributes Name Initial integer, public, allocatable :: vertexIDs (:) integer, public, allocatable :: faceIDs (:) integer, public, allocatable :: adjacentCellIDs (:) integer, public, allocatable :: boundFaceID (:) real(kind=4), public :: center (3) real(kind=4), public :: coordinate (3) type, public :: scf_grid_t Components Type Visibility Attributes Name Initial type( content_t ), public, allocatable :: node (:) type( content_t ), public, allocatable :: face (:) Type-Bound Procedures procedure, public :: read_SCF_file procedure, public :: get_fph_element_count procedure, public :: get_fph_vertex_count procedure, public :: get_fph_face_count procedure, public :: get_fph_2d_array_of_point_coords procedure, public :: get_fph_2d_array_of_cell_coords procedure, public :: get_face2vertices procedure, public :: get_face2cells procedure, public :: get_cell2faces procedure, public :: get_cell_offsets procedure, public :: get_fph_boundFaceIDs procedure, public :: get_fph_faceCenter procedure, public :: get_fph_boundFaceCenter procedure, public :: output_fph_cell2face procedure, public :: output_fph_boundFace procedure, public :: output_fph_vtk procedure, public :: get_cell2boundFace procedure, public :: get_fph_adjacentCellIDs procedure, public :: output_fph_adjacentCell procedure, public :: search_fph_vector_data Functions public function open_binary_sequential_ (unit, filename) result(is_opened) バイナリファイルをシーケンシャル形式で開く. 開けない場合.false. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: unit 装置番号. character, intent(in) :: filename Return Value logical public function get_fph_element_count (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this Return Value integer public function get_fph_vertex_count (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this Return Value integer public function get_fph_face_count (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this Return Value integer public function append2list_int (list, element, first_flag) result(after_list) Arguments Type Intent Optional Attributes Name integer, intent(in) :: list (:) integer, intent(in) :: element logical, intent(inout) :: first_flag Return Value integer,allocatable, (:) Subroutines public subroutine read_SCF_file (this, filename) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this character, intent(in) :: filename public subroutine read_FPH_Header_data (unit, NCYC, TIME) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer(kind=4), intent(inout) :: NCYC real(kind=4), intent(inout) :: TIME public subroutine read_FPH_Main_data (unit, CAN_X, CAN_Y, CAN_Z, CCE_X, CCE_Y, CCE_Z, EC_Scalars, EC_Vectors, FC_Scalars, FC_Vectors, EC_Scalar_cnt, EC_Vector_cnt, FC_Scalar_cnt, FC_Vector_cnt, NODES, NFACE, NELEM, NDTOT, IE1, IE2, NDNUM, IDNO) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit real(kind=4), intent(inout), allocatable :: CAN_X (:) real(kind=4), intent(inout), allocatable :: CAN_Y (:) real(kind=4), intent(inout), allocatable :: CAN_Z (:) real(kind=4), intent(inout), allocatable :: CCE_X (:) real(kind=4), intent(inout), allocatable :: CCE_Y (:) real(kind=4), intent(inout), allocatable :: CCE_Z (:) type( EC_Scalar_t ), intent(inout), allocatable :: EC_Scalars (:) type( EC_Vector_t ), intent(inout), allocatable :: EC_Vectors (:) type( FC_Scalar_t ), intent(inout), allocatable :: FC_Scalars (:) type( FC_Vector_t ), intent(inout), allocatable :: FC_Vectors (:) integer, intent(inout) :: EC_Scalar_cnt integer, intent(inout) :: EC_Vector_cnt integer, intent(inout) :: FC_Scalar_cnt integer, intent(inout) :: FC_Vector_cnt integer, intent(inout) :: NODES integer, intent(inout) :: NFACE integer, intent(inout) :: NELEM integer, intent(inout) :: NDTOT integer, intent(inout), allocatable :: IE1 (:) integer, intent(inout), allocatable :: IE2 (:) integer, intent(inout), allocatable :: NDNUM (:) integer, intent(inout), allocatable :: IDNO (:) public subroutine EC_Scalar_reader (scalar, unit, is_end) Arguments Type Intent Optional Attributes Name type( EC_Scalar_t ) :: scalar integer(kind=4), intent(in) :: unit logical, intent(out) :: is_end public subroutine EC_Vector_reader (vector, unit, is_end) Arguments Type Intent Optional Attributes Name type( EC_Vector_t ) :: vector integer(kind=4), intent(in) :: unit logical, intent(out) :: is_end public subroutine FC_Scalar_reader (scalar, unit, is_end) Arguments Type Intent Optional Attributes Name type( FC_Scalar_t ) :: scalar integer(kind=4), intent(in) :: unit logical, intent(out) :: is_end public subroutine FC_Vector_reader (vector, unit, is_end) Arguments Type Intent Optional Attributes Name type( FC_Vector_t ) :: vector integer(kind=4), intent(in) :: unit logical, intent(out) :: is_end public subroutine get_data_int32_ (unit, retval) Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: unit integer(kind=4), intent(inout) :: retval public subroutine get_data_float64_ (unit, retval) Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: unit real(kind=4), intent(inout) :: retval public subroutine get_data_array_int32_ (unit, ret_array, ret_array_size) 整数型配列の読み込み Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: unit integer(kind=4), intent(out), allocatable :: ret_array (:) integer(kind=4), intent(in) :: ret_array_size public subroutine get_data_array_float64_ (unit, ret_array, ret_array_size) 倍精度実数型配列の読み込み Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: unit real(kind=4), intent(out), allocatable :: ret_array (:) integer(kind=4), intent(in) :: ret_array_size public subroutine ignore_data_ (unit) データを読み飛ばす処理 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: unit public subroutine get_data_char_ (unit, byte, ret_char) 文字列（バイト数指定） Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: unit integer(kind=4), intent(in) :: byte character, intent(inout), allocatable :: ret_char public subroutine destructor (this) Arguments Type Intent Optional Attributes Name type( scf_grid_t ), intent(inout) :: this public subroutine get_fph_2d_array_of_point_coords (this, points) 節点座標を2次元配列で出力する. Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this real(kind=4), intent(inout), allocatable :: points (:,:) public subroutine get_fph_2d_array_of_cell_coords (this, cells) 要素中心座標を2次元配列で出力する. Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this real(kind=4), intent(inout), allocatable :: cells (:,:) public subroutine get_face2vertices (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this public subroutine get_cell_offsets (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this public subroutine get_face2cells (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this public subroutine get_cell2faces (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this public subroutine get_fph_boundFaceIDs (this, num_boundFaces) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this integer, intent(out) :: num_boundFaces public subroutine get_fph_faceCenter (this, face_center) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this real(kind=4), intent(out), allocatable :: face_center (:,:) public subroutine get_fph_boundFaceCenter (this, bound_center) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this real(kind=4), intent(inout), allocatable :: bound_center (:,:) public subroutine output_fph_cell2face (this, dir) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this character, intent(in) :: dir public subroutine output_fph_boundFace (this, dir) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this character, intent(in) :: dir public subroutine get_cell2boundFace (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this public subroutine get_fph_adjacentCellIDs (this) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this public subroutine output_fph_adjacentCell (this, dir) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(inout) :: this character, intent(in) :: dir public subroutine output_fph_vtk (this, dir) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this character, intent(in) :: dir public subroutine search_fph_vector_data (this, key, vector) Arguments Type Intent Optional Attributes Name class( scf_grid_t ), intent(in) :: this character, intent(in) :: key real(kind=4), intent(inout), allocatable :: vector (:,:) public subroutine packing_vector_into_2Darray_ (array, x, y, z) 実数のベクトル配列を2次元配列に詰め直す Arguments Type Intent Optional Attributes Name real(kind=4), intent(out), allocatable :: array (:,:) real(kind=4), intent(in) :: x (:) real(kind=4), intent(in) :: y (:) real(kind=4), intent(in) :: z (:)","tags":"","loc":"module\\scf_file_reader_m.html"},{"title":"SCT_file_reader_m – Droplets Simulation","text":"SC/TETRA 出力のファイルを読み取り，データを取り出す. 今までのconverterと異なり, 本モジュールで独立して扱えるようになっている. 並列化には対応していない. Note セルの節点の並び順はwedge以外はvtkのものと同じ. SC/TETRAでは，セル番号および節点番号は0スタートなので, fortran運用のためインデックス+1. 頂点配列(NDNO)はセルタイプ毎に並んでいない. cell2verticesのrank 1には最大で8つ(hexahedron), face2verticesには4つの値が入るが, \n  値が入っていない箇所は全て-1に統一されている. Contents Variables MissingValueSize Derived Types sctregion_t sct_data_name_list_t sct_grid_t Subroutines get_cell_data_from_cellvertices Variables Type Visibility Attributes Name Initial real(kind=8), public, parameter :: MissingValueSize = 1.0d20 SC/TETRAで規定された欠測値の大きさ. Derived Types type, public :: sctregion_t type, public :: sct_data_name_list_t スカラーorベクトルデータの名前だけを取り出す. 構造体の配列にして使用する.\nregion用に使うことも出来る. その場合abbreviatedは使わない.\n異なる文字長の配列が実装できなかったのでこれで代用する. type, public :: sct_grid_t SC/TETRA メッシュクラス. \n必要最低限の変数のみ保持. 変数名はフォーマットに準拠. メッシュそのものを取り扱うのでメモリ圧迫する可能性大. \nソルバ内で使う場合はサブルーチンのローカル変数として扱う方が無難(自動開放されるはず) Type-Bound Procedures procedure, public :: includes_topology procedure, public :: is_fld_file procedure, public :: print_self procedure, public :: read_SCT_file procedure, public :: extract_original_cell_vertices procedure, public :: extract_cell_vertices procedure, public :: extract_ordered_cell_vertices procedure, public :: get_2d_array_of_point_coords procedure, public :: get_cell_types procedure, public :: get_element_count procedure, public :: get_vertex_count procedure, public :: get_tetrahedron_count procedure, public :: get_wedge_count procedure, public :: get_pyramid_count procedure, public :: get_hexahedron_count procedure, public :: get_region_count procedure, public :: get_region_namelist procedure, public :: extract_face2vertices_on_region procedure, public :: search_scalar_data procedure, public :: search_vector_data procedure, public :: get_data_titles Subroutines public subroutine get_cell_data_from_cellvertices (cell_data, cell2vertices, point_data) 各セル毎の頂点配列に関連する節点中心データからセル中心データを構築する. \n値はセルを構成する節点データの算術平均として計算する. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: cell_data (:) 出力されるセル中心データ. integer, intent(in) :: cell2vertices (:,:) 頂点配列. integer, intent(in) :: point_data (:) 任意の節点データ.","tags":"","loc":"module\\sct_file_reader_m.html"},{"title":"simpleFile_reader – Droplets Simulation","text":"簡単なファイル（CSV、TXTなど）の読込手続き集モジュール Used by module~~simplefile_reader~~UsedByGraph module~simplefile_reader simpleFile_reader proc~get_box_array get_box_array proc~get_box_array->module~simplefile_reader program~cube2usg CUBE2USG program~cube2usg->module~simplefile_reader proc~case_check case_check proc~case_check->module~simplefile_reader Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces read_CSV Subroutines read_textRecord Interfaces public interface read_CSV CSV読込手続き private subroutine read_csv_dble(filename, matrix, column, header) Arguments Type Intent Optional Attributes Name character, intent(in) :: filename double precision, intent(inout), allocatable :: matrix (:,:) integer, intent(in), optional :: column logical, optional :: header private subroutine read_csv_int(filename, matrix, column, header) Arguments Type Intent Optional Attributes Name character, intent(in) :: filename integer, intent(inout), allocatable :: matrix (:,:) integer, intent(in), optional :: column logical, optional :: header private subroutine read_csv_char(filename, matrix, column, header) Arguments Type Intent Optional Attributes Name character, intent(in) :: filename character, intent(inout), allocatable :: matrix (:,:) integer, intent(in), optional :: column logical, optional :: header Subroutines public subroutine read_textRecord (filename, array) TXTファイルを、全行読み込む。\n1行あたりの文字数は引数に依存。 Arguments Type Intent Optional Attributes Name character, intent(in) :: filename ファイル名（パス） character, intent(out), allocatable :: array (:) 文字列配列\n要素数はallocatableだが、1要素あたりの文字数は予め指定","tags":"","loc":"module\\simplefile_reader.html"},{"title":"sort_m – Droplets Simulation","text":"ソートモジュール Used by module~~sort_m~~UsedByGraph module~sort_m sort_m module~kdtree_m kdTree_m module~kdtree_m->module~sort_m program~sort_test sort_test program~sort_test->module~sort_m module~unstructuredgrid_m unstructuredGrid_m module~unstructuredgrid_m->module~kdtree_m program~kdtree_test kdTree_test program~kdtree_test->module~kdtree_m program~kdtree_test->module~unstructuredgrid_m module~flow_field_m flow_field_m module~flow_field_m->module~unstructuredgrid_m program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->module~unstructuredgrid_m program~boxflowfield boxFlowField program~boxflowfield->module~unstructuredgrid_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~flow_field_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types content_t HeapTree Functions heap_sort real2content merge_sort Derived Types type, public :: content_t コンテンツ構造体\n実数とIDをメンバに持つ Components Type Visibility Attributes Name Initial integer, public :: originID real, public :: value type, public :: HeapTree ヒープ木クラス\n実体は単なる配列だがツリー構造を表現している\n要素 i に注目すると、親ノードは要素 i/2(小数切り捨て) であり、子ノードは要素 2i, 2i + 1 である Components Type Visibility Attributes Name Initial procedure, public :: totalHeaplification procedure, public :: rebuild_tree Functions public function heap_sort (array_origin) result(array_sorted) ヒープソート Arguments Type Intent Optional Attributes Name type( content_t ), intent(in) :: array_origin (:) Return Value type( content_t )(size(array_origin)) public function real2content (real_array) result(content_array) 実数型配列をコンテンツ配列に変換する Arguments Type Intent Optional Attributes Name real, intent(in) :: real_array (:) Return Value type( content_t ),allocatable, (:) public function merge_sort (array_origin) result(array_sorted) マージソート Arguments Type Intent Optional Attributes Name type( content_t ), intent(in) :: array_origin (:) Return Value type( content_t )(size(array_origin))","tags":"","loc":"module\\sort_m.html"},{"title":"terminalControler_m – Droplets Simulation","text":"ターミナル操作を扱うモジュール Example program sample use terminalControler_m call set_formatTC ( '(\"PROGRESS [ #progress : \",i6,\" / \",i6,\" ]\")' ) do i = 1 , imax call print_progress ([ i , imax ]) end do end program sample Used by module~~terminalcontroler_m~~UsedByGraph module~terminalcontroler_m terminalControler_m proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->module~terminalcontroler_m proc~get_cell2faces get_cell2faces proc~get_cell2faces->module~terminalcontroler_m program~boxflowfield boxFlowField program~boxflowfield->module~terminalcontroler_m proc~kdtree_ kdTree_ proc~kdtree_->module~terminalcontroler_m proc~get_fph_adjacentcellids get_fph_adjacentCellIDs proc~get_fph_adjacentcellids->module~terminalcontroler_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces print_progress Subroutines reset_formatTC set_formatTC print_sameLine Interfaces public interface print_progress 進捗を表示する private subroutine print_progress_int(array) Arguments Type Intent Optional Attributes Name integer, intent(in) :: array (:) private subroutine print_progress_real(array) Arguments Type Intent Optional Attributes Name real, intent(in) :: array (:) Subroutines public subroutine reset_formatTC () Arguments None public subroutine set_formatTC (fmt_str) 進捗を表示するためのフォーマットを指定\n指定時に改行が起こる（あとで戻ってくるため） Arguments Type Intent Optional Attributes Name character, intent(in) :: fmt_str public subroutine print_sameLine (str) Arguments Type Intent Optional Attributes Name character, intent(in) :: str","tags":"","loc":"module\\terminalcontroler_m.html"},{"title":"timeKeeper_m – Droplets Simulation","text":"Used by module~~timekeeper_m~~UsedByGraph module~timekeeper_m timeKeeper_m proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->module~timekeeper_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~timekeeper_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types DateAndTime TimeKeeper Functions TimeKeeper_ nowDateAndTime second2HMS Derived Types type, public :: DateAndTime Type-Bound Procedures procedure, public :: string => DateAndTime2string type, public :: TimeKeeper Components Type Visibility Attributes Name Initial real, public :: startCPUtime real, public :: lastLapCPUtime type( DateAndTime ), public :: startDAT procedure, public :: startDateAndTime procedure, public :: erapsedTime procedure, public :: lapTime Functions public function TimeKeeper_ () Arguments None Return Value type( TimeKeeper ) public function nowDateAndTime () result(str) Arguments None Return Value character,allocatable public function second2HMS (seconds) result(str) Arguments Type Intent Optional Attributes Name real, intent(in) :: seconds Return Value character(len=9)","tags":"","loc":"module\\timekeeper_m.html"},{"title":"unstructuredElement_m – Droplets Simulation","text":"非構造要素モジュール\n非構造格子のベースとなる構造体を定義している Used by module~~unstructuredelement_m~~UsedByGraph module~unstructuredelement_m unstructuredElement_m module~vtk_operator_m VTK_operator_m module~vtk_operator_m->module~unstructuredelement_m proc~search_nodeinfo search_nodeInfo proc~search_nodeinfo->module~unstructuredelement_m module~unstructuredgrid_m unstructuredGrid_m module~unstructuredgrid_m->module~unstructuredelement_m proc~output_boxvtk~2 output_boxVTK proc~output_boxvtk~2->module~vtk_operator_m program~boxflowfield boxFlowField program~boxflowfield->module~unstructuredgrid_m proc~output_boxvtk output_boxVTK proc~output_boxvtk->module~vtk_operator_m program~cube2usg CUBE2USG program~cube2usg->module~vtk_operator_m program~kdtree_test kdTree_test program~kdtree_test->module~unstructuredgrid_m module~flow_field_m flow_field_m module~flow_field_m->module~unstructuredgrid_m program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->module~unstructuredgrid_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~flow_field_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types node_t cell_t Functions get_MinMaxCDN get_cellCenters Derived Types type, public :: node_t 節点構造体（ただの座標配列） Components Type Visibility Attributes Name Initial real, public :: coordinate (3) type, public :: cell_t セル構造体（節点のID配列） Components Type Visibility Attributes Name Initial integer, public, allocatable :: nodeID (:) Functions public function get_MinMaxCDN (node) result(MinMax) 節点群の座標の最大最小を返す Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: node (:) Return Value real(3,2) public function get_cellCenters (node, cell) result(centers) すべてのセル重心を計算し、配列で返す Arguments Type Intent Optional Attributes Name class( node_t ), intent(in) :: node (:) class( cell_t ), intent(in) :: cell (:) Return Value real,allocatable, (:,:)","tags":"","loc":"module\\unstructuredelement_m.html"},{"title":"unstructuredGrid_m – Droplets Simulation","text":"Uses kdTree_m vector_m unstructuredElement_m module~~unstructuredgrid_m~~UsesGraph module~unstructuredgrid_m unstructuredGrid_m module~kdtree_m kdTree_m module~unstructuredgrid_m->module~kdtree_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~vector_m vector_m module~unstructuredgrid_m->module~vector_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~unstructuredgrid_m~~UsedByGraph module~unstructuredgrid_m unstructuredGrid_m module~flow_field_m flow_field_m module~flow_field_m->module~unstructuredgrid_m program~kdtree_test kdTree_test program~kdtree_test->module~unstructuredgrid_m program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->module~unstructuredgrid_m program~boxflowfield boxFlowField program~boxflowfield->module~unstructuredgrid_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~flow_field_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types FlowFieldUnstructuredGrid Functions FlowFieldUnstructuredGrid_ FlowFieldUnstructuredGrid_withMeshFile Derived Types type, public :: FlowFieldUnstructuredGrid 流れ場非構造格子クラス Components Type Visibility Attributes Name Initial type( node_t ), public, allocatable :: NODEs (:) 節点配列 type(cell_inFlow_t), public, allocatable :: CELLs (:) セル配列 type(boundaryTriangle_t), public, allocatable :: BoundFACEs (:) 境界面配列 type(boundaryTriangle_t), public, allocatable :: FACEs (:) type( kdTree ), public :: kd_tree kd-tree（近傍セル探索用） real, public :: MIN_CDN (3) 座標の最小値(xyz) real, public :: MAX_CDN (3) 座標の最大値(xyz) integer, public :: num_refCellSearchFalse = 0 参照セル探索結果が悪いと判断された回数 integer, public :: num_refCellSearch = 0 参照セル探索が行われた回数 logical, public :: fph_flag = .false. procedure, public :: set_cellCenter procedure, public :: set_cellThreshold procedure, public :: set_MinMaxCDN procedure, public :: point2cellVelocity procedure, public :: nearer_cell procedure, public :: AdjacencySolvingProcess procedure, public :: read_adjacency procedure, public :: read_boundaries procedure, public :: solve_adjacencyOnFlowFieldUnstructuredGrid procedure, public :: output_boundaries procedure, public :: output_adjacency procedure, public :: boundary_setting procedure, public :: output_STL procedure, public :: read_cell2face Type-Bound Procedures procedure, public :: nearcell_check procedure, public :: nearest_cell procedure, public :: nearest_search_kdTree procedure, public :: nearest_search_exact procedure, public :: get_movementVectorOfBoundarySurface procedure, public :: get_flowVelocityInCELL procedure, public :: get_allOfCellCenters procedure, public :: get_cellCenterOf procedure, public :: get_MinMaxOfGrid procedure, public :: get_cellVerticesOf procedure, public :: get_info => get_gridInformation procedure, public :: read_FPH procedure, public :: read_FLD procedure, public :: read_INP procedure, public :: read_array => read_Array procedure, public :: read_VTK procedure, public :: updateWithFlowFieldFile procedure, public :: setupWithFlowFieldFile procedure, public :: search_refCELL procedure, public :: adhesionCheckOnBound procedure, public :: get_nearerSearchFalseRate procedure, public :: get_num_nearerSearchFalse Functions public function FlowFieldUnstructuredGrid_ (FlowFieldFile) result(grid) 流れ場のコンストラクタ\n流れ場ファイルの読み込み、前処理、kd-treeの構築を行う Arguments Type Intent Optional Attributes Name character, intent(in) :: FlowFieldFile 流れ場ファイル名 Return Value type( FlowFieldUnstructuredGrid ) public function FlowFieldUnstructuredGrid_withMeshFile (FlowFieldFile, meshFile) result(grid) 流れ場のコンストラクタ(meshファイルと流速データファイルが分かれている場合)\n流れ場ファイルの読み込み、前処理、kd-treeの構築を行う Arguments Type Intent Optional Attributes Name character, intent(in) :: FlowFieldFile 流速データファイル名 character, intent(in) :: meshFile メッシュファイル Return Value type( FlowFieldUnstructuredGrid )","tags":"","loc":"module\\unstructuredgrid_m.html"},{"title":"vector_m – Droplets Simulation","text":"ベクトル（3要素の配列）を扱うモジュール Used by module~~vector_m~~UsedByGraph module~vector_m vector_m module~unstructuredgrid_m unstructuredGrid_m module~unstructuredgrid_m->module~vector_m module~geometry_m geometry_m module~geometry_m->module~vector_m program~geometry_test geometry_test program~geometry_test->module~geometry_m program~boxflowfield boxFlowField program~boxflowfield->module~unstructuredgrid_m module~flow_field_m flow_field_m module~flow_field_m->module~unstructuredgrid_m program~kdtree_test kdTree_test program~kdtree_test->module~unstructuredgrid_m program~cellcentercalc_test cellCenterCalc_test program~cellcentercalc_test->module~unstructuredgrid_m program~cellcentercalc_test->module~geometry_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~flow_field_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces cross_product normalize_vector Functions norm2_squared Interfaces public interface cross_product ベクトルの外積を返す private function cross_product_dble(a, b) result(cross) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (3) double precision, intent(in) :: b (3) Return Value double precision(3) private function cross_product_real(a, b) result(cross) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) real, intent(in) :: b (3) Return Value real(3) public interface normalize_vector 単位ベクトルを返す private function normalize_vector_dble(a) result(normalized) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: a (3) Return Value double precision(3) private function normalize_vector_real(a) result(normalized) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) Return Value real(3) Functions public function norm2_squared (a) ベクトルのL2ノルムの2乗を返す\n組み込み関数norm2より約5倍速い(かも) Arguments Type Intent Optional Attributes Name real, intent(in) :: a (3) Return Value real","tags":"","loc":"module\\vector_m.html"},{"title":"virusDroplet_m – Droplets Simulation","text":"Used by module~~virusdroplet_m~~UsedByGraph module~virusdroplet_m virusDroplet_m module~dropletgenerator_m dropletGenerator_m module~dropletgenerator_m->module~virusdroplet_m program~dropletcount dropletCount program~dropletcount->module~virusdroplet_m program~translate translate program~translate->module~virusdroplet_m module~dropletmotionsimulation dropletMotionSimulation module~dropletmotionsimulation->module~virusdroplet_m module~dropletmotionsimulation->module~dropletgenerator_m program~main MAIN program~main->module~dropletmotionsimulation Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types virusDroplet_t Functions dropletCounter dropletIDinBox dropletTotalVolume dropletIDinState read_backup Subroutines survival_check get_dropletsArea coalescence_check output_backup output_droplet_VTK output_droplet_CSV set_initialRadius set_radiusLowerLimit set_virusDeadline set_dropletStatus Derived Types type, public :: virusDroplet_t ウイルス飛沫構造体 Components Type Visibility Attributes Name Initial double precision, public :: position (3) double precision, public :: velocity (3) = 0.d0 integer, public :: coalesID = 0 integer, public :: refCellID = 0 integer, public :: adhesBoundID = 0 procedure, public :: stop_droplet procedure, public :: isEvaporating procedure, public :: evaporation procedure, public :: get_radius Type-Bound Procedures procedure, public :: isFloating => isDropletFloating procedure, public :: coalescenceID => dropletCoalescneceID Functions public function dropletCounter (droplets, name) 指定された状態にある飛沫数をカウント Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) character, intent(in) :: name キーワード（total, floating, etc.） Return Value integer public function dropletIDinBox (droplets, min_cdn, max_cdn, status) result(ID_array) 直方体領域内の飛沫のID配列を返す Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) double precision, intent(in) :: min_cdn (3) 直方体領域の最小座標 double precision, intent(in) :: max_cdn (3) 直方体領域の最大座標 integer, intent(in), optional :: status 状態 Return Value integer,allocatable, (:) public function dropletTotalVolume (droplets) 配列内の全飛沫の総体積（無次元）を計算 Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) Return Value doubleprecision public function dropletIDinState (droplets, status) result(ID_array) 任意の状態の飛沫のID配列を返す Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) character, intent(in) :: status Return Value integer,allocatable, (:) public function read_backup (fname) result(droplets) backupファイルを読み込み、飛沫配列を返す Arguments Type Intent Optional Attributes Name character, intent(in) :: fname Return Value type( virusDroplet_t ),allocatable, (:) Subroutines public subroutine survival_check (droplets, time) 飛沫の不活性化判定 Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) double precision, intent(in) :: time 現在時刻（無次元） public subroutine get_dropletsArea (droplets, AreaMin, AreaMax) 飛沫配列内の飛沫の座標の最大最小を返す Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) double precision, intent(out) :: AreaMin (3) double precision, intent(out) :: AreaMax (3) public subroutine coalescence_check (droplets, stat) 合体判定 Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) integer, intent(out), optional :: stat public subroutine output_backup (droplets, fname) backupファイルの出力。\n配列をループ使わずそのまま書き出すほうが多分ファイルサイズ効率が良いので、いつか修正したい。 Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) character, intent(in) :: fname public subroutine output_droplet_VTK (droplets, fname, deadline) VTK形式でファイル出力 Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) character, intent(in) :: fname logical, optional :: deadline public subroutine output_droplet_CSV (droplets, fname, time, initial) CSV形式で時系列データ出力 Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) character, intent(in) :: fname double precision, intent(in) :: time logical, intent(in) :: initial public subroutine set_initialRadius (droplets, radius) 飛沫の初期半径を配列からセットする Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) double precision, intent(in) :: radius (:) public subroutine set_radiusLowerLimit (droplets, lowerLimitRatio) 飛沫の蒸発限界半径をセットする Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) double precision, intent(in) :: lowerLimitRatio 限界半径と初期半径の比 public subroutine set_virusDeadline (droplets, deadline) 飛沫の寿命を配列からセットする Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) double precision, intent(in) :: deadline (:) public subroutine set_dropletStatus (droplets, status, ID) 飛沫の状態を一気にセットする\n特定のIDの飛沫だけセットしたい場合は、ID配列を引数に渡す Arguments Type Intent Optional Attributes Name type( virusDroplet_t ) :: droplets (:) character, intent(in) :: status integer, intent(in), optional :: ID (:)","tags":"","loc":"module\\virusdroplet_m.html"},{"title":"VTK_operator_m – Droplets Simulation","text":"Uses unstructuredElement_m module~~vtk_operator_m~~UsesGraph module~vtk_operator_m VTK_operator_m module~unstructuredelement_m unstructuredElement_m module~vtk_operator_m->module~unstructuredelement_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~vtk_operator_m~~UsedByGraph module~vtk_operator_m VTK_operator_m proc~output_boxvtk output_boxVTK proc~output_boxvtk->module~vtk_operator_m program~cube2usg CUBE2USG program~cube2usg->module~vtk_operator_m proc~output_boxvtk~2 output_boxVTK proc~output_boxvtk~2->module~vtk_operator_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types UnstructuredGrid_inVTK Functions UnstructuredGrid_inVTK_ Derived Types type, public :: UnstructuredGrid_inVTK Components Type Visibility Attributes Name Initial type( node_t ), public, allocatable :: node_array (:) type(cell_inVTK_t), public, allocatable :: cell_array (:) procedure, public :: get_numCell procedure, public :: get_numNode procedure, public :: get_nodeCoordinate procedure, public :: get_cellVertices procedure, public :: set_nodeCoordinate procedure, public :: set_cellVertices Type-Bound Procedures procedure, public :: read => read_UnstructuredGrid_inVTK procedure, public :: output => output_UnstructuredGrid_inVTK Functions public function UnstructuredGrid_inVTK_ (cdn, vertices, types) Arguments Type Intent Optional Attributes Name real, intent(in) :: cdn (:,:) integer, intent(in) :: vertices (:,:) integer, intent(in) :: types (:) Return Value type( UnstructuredGrid_inVTK )","tags":"","loc":"module\\vtk_operator_m.html"},{"title":"boxFlowField – Droplets Simulation","text":"Uses conditionValue_m unstructuredGrid_m terminalControler_m boxCounter_m program~~boxflowfield~~UsesGraph program~boxflowfield boxFlowField module~conditionvalue_m conditionValue_m program~boxflowfield->module~conditionvalue_m module~terminalcontroler_m terminalControler_m program~boxflowfield->module~terminalcontroler_m module~unstructuredgrid_m unstructuredGrid_m program~boxflowfield->module~unstructuredgrid_m module~boxcounter_m boxCounter_m program~boxflowfield->module~boxcounter_m module~kdtree_m kdTree_m module~unstructuredgrid_m->module~kdtree_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~vector_m vector_m module~unstructuredgrid_m->module~vector_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~boxflowfield~~CallsGraph program~boxflowfield boxFlowField proc~flowfieldunstructuredgrid_withmeshfile FlowFieldUnstructuredGrid_withMeshFile program~boxflowfield->proc~flowfieldunstructuredgrid_withmeshfile interface~print_progress print_progress program~boxflowfield->interface~print_progress proc~set_formattc set_formatTC program~boxflowfield->proc~set_formattc proc~get_box_array get_box_array program~boxflowfield->proc~get_box_array proc~output_countcsv output_countCSV program~boxflowfield->proc~output_countcsv proc~output_boxvtk output_boxVTK program~boxflowfield->proc~output_boxvtk proc~get_dirfrompath get_DirFromPath proc~flowfieldunstructuredgrid_withmeshfile->proc~get_dirfrompath interface~read_csv read_CSV proc~get_box_array->interface~read_csv proc~unstructuredgrid_invtk_ UnstructuredGrid_inVTK_ proc~output_boxvtk->proc~unstructuredgrid_invtk_ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i_box num_box nc caseName box_array bResult mesh Derived Types boxResult_t Subroutines output_countCSV output_boxVTK Variables Type Attributes Name Initial integer :: i_box integer :: num_box integer :: nc character(len=255) :: caseName type( boxCounter ), allocatable :: box_array (:) type( boxResult_t ), allocatable :: bResult (:) type( FlowFieldUnstructuredGrid ) :: mesh Derived Types type :: boxResult_t Components Type Visibility Attributes Name Initial real, public :: flowVelocity (3) Subroutines subroutine output_countCSV () Arguments None subroutine output_boxVTK () Arguments None","tags":"","loc":"program\\boxflowfield.html"},{"title":"CUBE2USG – Droplets Simulation","text":"Uses plot3d_operator VTK_operator_m array_m simpleFile_reader program~~cube2usg~~UsesGraph program~cube2usg CUBE2USG module~plot3d_operator plot3d_operator program~cube2usg->module~plot3d_operator module~vtk_operator_m VTK_operator_m program~cube2usg->module~vtk_operator_m module~array_m array_m program~cube2usg->module~array_m module~simplefile_reader simpleFile_reader program~cube2usg->module~simplefile_reader module~unstructuredelement_m unstructuredElement_m module~vtk_operator_m->module~unstructuredelement_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. CUBE格子上の流速場をVTK非構造格子に載せるプログラム。\n非構造格子上の各格子に対して、CUBE格子上の最近傍節点を探し、対応付けを行う。\n対応する各節点における流速を配列にして、そのままバイナリファイル出力を行う。 Calls program~~cube2usg~~CallsGraph program~cube2usg CUBE2USG proc~read_textrecord read_textRecord program~cube2usg->proc~read_textrecord proc~output_2darray_asbinary output_2dArray_asBinary program~cube2usg->proc~output_2darray_asbinary proc~read_plot3d_multigrid read_plot3d_multigrid program~cube2usg->proc~read_plot3d_multigrid proc~solve_correspondence solve_correspondence program~cube2usg->proc~solve_correspondence proc~read_nodeinfo read_nodeInfo proc~solve_correspondence->proc~read_nodeinfo proc~search_nodeinfo search_nodeInfo proc~solve_correspondence->proc~search_nodeinfo proc~output_nodeinfo output_nodeInfo proc~solve_correspondence->proc~output_nodeinfo proc~timekeeper_ TimeKeeper_ proc~search_nodeinfo->proc~timekeeper_ proc~get_cellcenters get_cellCenters proc~search_nodeinfo->proc~get_cellcenters proc~set_formattc set_formatTC proc~search_nodeinfo->proc~set_formattc interface~print_progress print_progress proc~search_nodeinfo->interface~print_progress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables F_fname USG_fname casefname filename field_name caseName CorrespondenceFName fileID num_record num_cell nc nc_max velocity USG cubeMesh vtkCell2cubeNode Subroutines output_nodeInfo search_nodeInfo read_nodeInfo solve_correspondence Variables Type Attributes Name Initial character(len=100) :: F_fname character(len=100) :: USG_fname character(len=100) :: casefname character(len=50), parameter :: filename = 'name.txt' character(len=50), allocatable :: field_name (:) character(len=50), allocatable :: caseName (:) character(len=20), parameter :: CorrespondenceFName = 'vtkCell2cubeNode.txt' integer :: fileID integer :: num_record integer :: num_cell integer :: nc integer :: nc_max real, allocatable :: velocity (:,:) type( UnstructuredGrid_inVTK ) :: USG type( Plot3dMesh ) :: cubeMesh type( plot3dNodeInfo ), allocatable :: vtkCell2cubeNode (:) Subroutines subroutine output_nodeInfo () 対応する節点情報をアスキーファイルで出力するサブルーチン Arguments None subroutine search_nodeInfo () 非構造格子に対応する節点情報を探すサブルーチン Arguments None subroutine read_nodeInfo (success) 節点情報対応付けファイルを読み込むサブルーチン Arguments Type Intent Optional Attributes Name logical, intent(out) :: success subroutine solve_correspondence () 格子と節点の対応付けを解決するサブルーチン Arguments None","tags":"","loc":"program\\cube2usg.html"},{"title":"dropletCount – Droplets Simulation","text":"Uses boxCounter_m conditionValue_m virusDroplet_m caseName_m program~~dropletcount~~UsesGraph program~dropletcount dropletCount module~boxcounter_m boxCounter_m program~dropletcount->module~boxcounter_m module~virusdroplet_m virusDroplet_m program~dropletcount->module~virusdroplet_m module~conditionvalue_m conditionValue_m program~dropletcount->module~conditionvalue_m module~casename_m caseName_m program~dropletcount->module~casename_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. ボックスを通過した飛沫をカウントする。\n飛沫計算の出力ファイルを順に読み込み、各ボックスに対して内外判定を行う。\nボックス側では、通過した飛沫のIDしか見ておらず、同じIDの飛沫のダブルカウントなどは起こらない。 Calls program~~dropletcount~~CallsGraph program~dropletcount dropletCount proc~read_condition read_condition program~dropletcount->proc~read_condition proc~rateofinfection RateOfInfection program~dropletcount->proc~rateofinfection proc~read_backup read_backup program~dropletcount->proc~read_backup proc~droplettotalvolume dropletTotalVolume program~dropletcount->proc~droplettotalvolume proc~output_boxvtk~2 output_boxVTK program~dropletcount->proc~output_boxvtk~2 proc~case_check case_check program~dropletcount->proc~case_check proc~dropletidinbox dropletIDinBox program~dropletcount->proc~dropletidinbox proc~get_box_array get_box_array program~dropletcount->proc~get_box_array proc~output_countcsv~2 output_countCSV program~dropletcount->proc~output_countcsv~2 proc~unstructuredgrid_invtk_ UnstructuredGrid_inVTK_ proc~output_boxvtk~2->proc~unstructuredgrid_invtk_ proc~read_textrecord read_textRecord proc~case_check->proc~read_textrecord interface~read_csv read_CSV proc~get_box_array->interface~read_csv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables n i_box num_box caseID caseName_array caseName fname id_array mainDroplets droplets condVal box_array bResult Derived Types boxResult_t Functions RateOfInfection Subroutines output_countCSV output_boxVTK Variables Type Attributes Name Initial integer :: n integer :: i_box integer :: num_box integer :: caseID character(len=50), allocatable :: caseName_array (:) character, allocatable :: caseName character, allocatable :: fname integer, allocatable :: id_array (:) type( virusDroplet_t ), allocatable :: mainDroplets (:) type( virusDroplet_t ), allocatable :: droplets (:) type( conditionValue_t ) :: condVal type( boxCounter ), allocatable :: box_array (:) type( boxResult_t ), allocatable :: bResult (:) Derived Types type :: boxResult_t Components Type Visibility Attributes Name Initial integer, public :: num_droplet real, public :: volume real, public :: RoI Functions elemental function RateOfInfection (volume) 1分間あたりの感染確率を計算（もとの資料では1時間あたりの感染確率だが、1分間あたりに換算） Arguments Type Intent Optional Attributes Name real, intent(in) :: volume Return Value real Subroutines subroutine output_countCSV () Arguments None subroutine output_boxVTK () Arguments None","tags":"","loc":"program\\dropletcount.html"},{"title":"translate – Droplets Simulation","text":"Uses virusDroplet_m caseName_m program~~translate~~UsesGraph program~translate translate module~virusdroplet_m virusDroplet_m program~translate->module~virusdroplet_m module~casename_m caseName_m program~translate->module~casename_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. 全飛沫に対して、基準点をbefore_dGroupCenter、回転軸をrotation_axisとして、反時計回りにphi[rad]だけ回転させる。\n回転後の飛沫中心をafter_dGroupCenterに平行移動させる。 Calls program~~translate~~CallsGraph program~translate translate proc~case_check case_check program~translate->proc~case_check proc~read_backup read_backup program~translate->proc~read_backup proc~output_backup output_backup program~translate->proc~output_backup proc~output_droplet_vtk output_droplet_VTK program~translate->proc~output_droplet_vtk proc~read_textrecord read_textRecord proc~case_check->proc~read_textrecord Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables droplets caseName_array caseName fnameDecoration before_dGroupCenter after_dGroupCenter rotation_axis rotation_angle_deg i n_unit PI vec center_displacement phi Variables Type Attributes Name Initial type( virusDroplet_t ), allocatable :: droplets (:) character(len=50), allocatable :: caseName_array (:) character, allocatable :: caseName character(len=15) :: fnameDecoration double precision :: before_dGroupCenter (3) double precision :: after_dGroupCenter (3) character(len=1) :: rotation_axis double precision :: rotation_angle_deg integer :: i integer :: n_unit double precision, parameter :: PI = acos(-1.d0) double precision :: vec (3) double precision :: center_displacement (3) double precision :: phi","tags":"","loc":"program\\translate.html"},{"title":"MAIN – Droplets Simulation","text":"Uses dropletMotionSimulation caseName_m program~~main~~UsesGraph program~main MAIN module~dropletmotionsimulation dropletMotionSimulation program~main->module~dropletmotionsimulation module~casename_m caseName_m program~main->module~casename_m module~dropletgenerator_m dropletGenerator_m module~dropletmotionsimulation->module~dropletgenerator_m module~timekeeper_m timeKeeper_m module~dropletmotionsimulation->module~timekeeper_m module~dropletequation_m dropletEquation_m module~dropletmotionsimulation->module~dropletequation_m module~virusdroplet_m virusDroplet_m module~dropletmotionsimulation->module~virusdroplet_m module~flow_field_m flow_field_m module~dropletmotionsimulation->module~flow_field_m module~dropletgenerator_m->module~dropletequation_m module~dropletgenerator_m->module~virusdroplet_m module~unstructuredgrid_m unstructuredGrid_m module~flow_field_m->module~unstructuredgrid_m module~kdtree_m kdTree_m module~unstructuredgrid_m->module~kdtree_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~vector_m vector_m module~unstructuredgrid_m->module~vector_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. 流れ場ファイルを読み込み、その流れ場における飛沫の運動をシミュレーション 並列化には対応していない Calls program~~main~~CallsGraph program~main MAIN proc~read_basicsettingonsimulation read_basicSettingOnSimulation program~main->proc~read_basicsettingonsimulation proc~rundropletssimulation RunDropletsSimulation program~main->proc~rundropletssimulation proc~case_check case_check program~main->proc~case_check proc~survival_check survival_check proc~rundropletssimulation->proc~survival_check proc~read_textrecord read_textRecord proc~case_check->proc~read_textrecord Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables caseName caseID Variables Type Attributes Name Initial character(len=50), allocatable :: caseName (:) integer :: caseID","tags":"","loc":"program\\main.html"},{"title":"cellCenterCalc_test – Droplets Simulation","text":"Uses geometry_m unstructuredGrid_m program~~cellcentercalc_test~~UsesGraph program~cellcentercalc_test cellCenterCalc_test module~geometry_m geometry_m program~cellcentercalc_test->module~geometry_m module~unstructuredgrid_m unstructuredGrid_m program~cellcentercalc_test->module~unstructuredgrid_m module~vector_m vector_m module~geometry_m->module~vector_m module~unstructuredgrid_m->module~vector_m module~kdtree_m kdTree_m module~unstructuredgrid_m->module~kdtree_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~sort_m sort_m module~kdtree_m->module~sort_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. セル重心計算がうまく行っているかをテストする。\n具体的には、重心をテトラの内外判定にかけている。 Calls program~~cellcentercalc_test~~CallsGraph program~cellcentercalc_test cellCenterCalc_test proc~insidejudgment_tetra insideJudgment_tetra program~cellcentercalc_test->proc~insidejudgment_tetra proc~insidejudgment_tetra_check insideJudgment_tetra_check program~cellcentercalc_test->proc~insidejudgment_tetra_check proc~volume_tetra volume_tetra proc~insidejudgment_tetra->proc~volume_tetra proc~insidejudgment_tetra_check->proc~volume_tetra interface~cross_product cross_product proc~volume_tetra->interface~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables grid centers vertices center i imax n Variables Type Attributes Name Initial type( FlowFieldUnstructuredGrid ) :: grid real, allocatable :: centers (:,:) real, allocatable :: vertices (:,:) real :: center (3) integer :: i integer :: imax integer :: n","tags":"","loc":"program\\cellcentercalc_test.html"},{"title":"geometry_test – Droplets Simulation","text":"Uses geometry_m program~~geometry_test~~UsesGraph program~geometry_test geometry_test module~geometry_m geometry_m program~geometry_test->module~geometry_m module~vector_m vector_m module~geometry_m->module~vector_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. テトラ内外判定をテストする。\n乱数で発生させた点群に対して判定を行う。\nテスト用のテトラは単純な形状で、平面の方程式から即座に内外判定が行えるので、これと比較してテストする。 Calls program~~geometry_test~~CallsGraph program~geometry_test geometry_test proc~plane_equation plane_equation program~geometry_test->proc~plane_equation proc~insidejudgment_tetra insideJudgment_tetra program~geometry_test->proc~insidejudgment_tetra proc~volume_tetra volume_tetra proc~insidejudgment_tetra->proc~volume_tetra interface~cross_product cross_product proc~volume_tetra->interface~cross_product Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables tetra imax rand point plane_judge tetra_judge i Functions plane_equation Variables Type Attributes Name Initial real, parameter :: tetra (3,4) = reshape([0., 0., 0., 1., 0., 0., 0., 1., 0., 0., 0., 1.], shape(tetra)) integer, parameter :: imax = 10000 real :: rand (3,imax) real :: point (3) logical :: plane_judge logical :: tetra_judge integer :: i Functions function plane_equation (x, y) result(z) テスト用テトラの斜面の方程式 Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y Return Value real","tags":"","loc":"program\\geometry_test.html"},{"title":"kdTree_test – Droplets Simulation","text":"Uses kdTree_m unstructuredGrid_m path_operator_m program~~kdtree_test~~UsesGraph program~kdtree_test kdTree_test module~kdtree_m kdTree_m program~kdtree_test->module~kdtree_m module~unstructuredgrid_m unstructuredGrid_m program~kdtree_test->module~unstructuredgrid_m module~path_operator_m path_operator_m program~kdtree_test->module~path_operator_m module~sort_m sort_m module~kdtree_m->module~sort_m module~unstructuredgrid_m->module~kdtree_m module~unstructuredelement_m unstructuredElement_m module~unstructuredgrid_m->module~unstructuredelement_m module~vector_m vector_m module~unstructuredgrid_m->module~vector_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. kdTreeによる探索結果と、厳密なnearest探索結果が一致するかどうかをテスト Calls program~~kdtree_test~~CallsGraph program~kdtree_test kdTree_test proc~make_directory make_directory program~kdtree_test->proc~make_directory proc~test test program~kdtree_test->proc~test proc~kdtree_ kdTree_ program~kdtree_test->proc~kdtree_ proc~replace_str replace_str proc~make_directory->proc~replace_str proc~merge_sort merge_sort proc~kdtree_->proc~merge_sort proc~real2content real2content proc~kdtree_->proc~real2content proc~set_formattc set_formatTC proc~kdtree_->proc~set_formattc interface~print_progress print_progress proc~kdtree_->interface~print_progress Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables grid xyz kd_tree iimx vtkFName kd_treeFName output_dir existance Subroutines test Variables Type Attributes Name Initial type( FlowFieldUnstructuredGrid ) :: grid real, allocatable :: xyz (:,:) type( kdTree ) :: kd_tree integer :: iimx character, allocatable :: vtkFName character, allocatable :: kd_treeFName character(len=10), parameter :: output_dir = 'test_check' logical :: existance Subroutines subroutine test () 乱数で発生させた点に対して、kdTreeによる探索結果と、厳密なnearest探索結果が一致するかどうかをテスト Arguments None","tags":"","loc":"program\\kdtree_test.html"},{"title":"sort_test – Droplets Simulation","text":"Uses sort_m array_m program~~sort_test~~UsesGraph program~sort_test sort_test module~sort_m sort_m program~sort_test->module~sort_m module~array_m array_m program~sort_test->module~array_m Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. ヒープソートの機能テスト Calls program~~sort_test~~CallsGraph program~sort_test sort_test proc~test_sort test_sort program~sort_test->proc~test_sort proc~fisheryates_shuffle FisherYates_shuffle proc~test_sort->proc~fisheryates_shuffle proc~real2content real2content proc~test_sort->proc~real2content proc~merge_sort merge_sort proc~test_sort->proc~merge_sort proc~heap_sort heap_sort proc~test_sort->proc~heap_sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables test1 test2 test3 Subroutines test_sort Variables Type Attributes Name Initial real, parameter :: test1 (10) = [-9.0, -1.0, 0.0, 3.0, 5.0, 7.2, 14.4, 99.9, 122.5, 255.0] real, parameter :: test2 (11) = [-99.0, -9.0, -1.0, 0.0, 3.0, 5.0, 7.2, 14.4, 99.9, 122.5, 255.0] real :: test3 (10000) Subroutines subroutine test_sort (array_correct, sort_mode) 正解配列（ソート済み配列）を引数に取り、それをシャッフルしたのちにソートを行う\n正解配列とソート後の配列を比較し、ソートが機能しているかを検証 Arguments Type Intent Optional Attributes Name real, intent(in) :: array_correct (:) character, intent(in) :: sort_mode","tags":"","loc":"program\\sort_test.html"},{"title":"boxFlowField.f90 – Droplets Simulation","text":"This file depends on sourcefile~~boxflowfield.f90~~EfferentGraph sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxcounter.f90 boxCounter.f90 sourcefile~boxflowfield.f90->sourcefile~boxcounter.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~boxflowfield.f90->sourcefile~vtkmesh_operator.f90 sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~boxflowfield.f90->sourcefile~conditionvalue.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~boxflowfield.f90->sourcefile~terminalcontroler.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~boxcounter.f90->sourcefile~simplefile_reader.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~vector.f90 vector.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~array.f90 array.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~scffile_reader.f90 SCFfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~scffile_reader.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~scffile_reader.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs boxFlowField Source Code boxFlowField.f90 Source Code program boxFlowField use conditionValue_m use boxCounter_m use unstructuredGrid_m use terminalControler_m implicit none integer i_box , num_box , nc character ( 255 ) caseName type ( boxCounter ), allocatable :: box_array (:) type boxResult_t real flowVelocity ( 3 ) end type type ( boxResult_t ), allocatable :: bResult (:) type ( FlowFieldUnstructuredGrid ) mesh box_array = get_box_array ( '.' , 0 ) num_box = size ( box_array ) do nc = 1 , iargc () ! コマンドライン引数を取得 call getarg ( nc , caseName ) print * , trim ( caseName ) ! mesh = FlowFieldUnstructuredGrid_(condVal%path2FlowFile, condVal%meshFile) if ( nc == 1 ) then mesh = FlowFieldUnstructuredGrid_withMeshFile ( trim ( caseName ) // '/field_0000005125.array' , './case1.vtk' ) else call mesh % updateWithFlowFieldFile ( trim ( caseName ) // '/field_0000005125.array' ) end if allocate ( bResult ( num_box )) call set_formatTC ( '(\"BoxCellSerch [ #box : \",i6,\" / \",i6,\" ]\")' ) block integer i_cell i_cell = 1 do i_box = 1 , num_box call print_progress ([ i_box , num_box ]) ! i_cell = mesh%nearest_cell(box_array(i_box)%center) call mesh % search_refCELL ( box_array ( i_box )% center , i_cell ) bResult ( i_box )% flowVelocity = mesh % get_flowVelocityInCELL ( i_cell ) end do end block call output_countCSV call output_boxVTK deallocate ( bResult ) end do contains subroutine output_countCSV integer n_unit , i character (:), allocatable :: csvFName csvFName = trim ( caseName ) // '/BoxFlow.csv' print * , 'output: ' , csvFName open ( newunit = n_unit , file = csvFName , status = 'replace' ) write ( n_unit , '(\"x,y,z,u,v,w\")' ) do i = 1 , size ( box_array ) write ( n_unit , '(*(g0:,\",\"))' ) box_array ( i )% center , bResult ( i )% flowVelocity end do close ( n_unit ) end subroutine subroutine output_boxVTK use VTK_operator_m type ( UnstructuredGrid_inVTK ) boxMesh integer i , j , k real , parameter :: trans ( 3 , 8 ) = reshape ([ & 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 1.0 , 1.0 , 0.0 , & 0.0 , 0.0 , 1.0 , 1.0 , 0.0 , 1.0 , 0.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 ], shape ( trans )) real velArray ( 3 , size ( box_array )) real , allocatable :: xyz (:,:) integer , allocatable :: vertices (:,:), types (:) allocate ( xyz ( 3 , num_box * 8 )) allocate ( vertices ( 8 , num_box ), types ( num_box )) do i = 1 , num_box do j = 1 , 8 k = j + 8 * ( i - 1 ) xyz (:, k ) = box_array ( i )% min_cdn (:) + box_array ( i )% width (:) * trans (:, j ) vertices ( j , i ) = k end do types ( i ) = 11 end do do i = 1 , num_box velArray (:, i ) = bResult ( i )% flowVelocity end do boxMesh = UnstructuredGrid_inVTK_ ( xyz , vertices , types ) call boxMesh % output ( trim ( caseName ) // '/BoxFlow.vtk' , cellVector = velArray , vectorName = 'VEL' ) end subroutine end program boxFlowField","tags":"","loc":"sourcefile\\boxflowfield.f90.html"},{"title":"CUBE2USG.f90 – Droplets Simulation","text":"This file depends on sourcefile~~cube2usg.f90~~EfferentGraph sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~timekeeper.f90 timeKeeper.f90 sourcefile~cube2usg.f90->sourcefile~timekeeper.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~cube2usg.f90->sourcefile~unstructuredelement.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~cube2usg.f90->sourcefile~vtkmesh_operator.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~cube2usg.f90->sourcefile~terminalcontroler.f90 sourcefile~array.f90 array.f90 sourcefile~cube2usg.f90->sourcefile~array.f90 sourcefile~plot3d_operator.f90 plot3d_operator.f90 sourcefile~cube2usg.f90->sourcefile~plot3d_operator.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~cube2usg.f90->sourcefile~simplefile_reader.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs CUBE2USG Source Code CUBE2USG.f90 Source Code !>CUBE格子上の流速場をVTK非構造格子に載せるプログラム。 !>非構造格子上の各格子に対して、CUBE格子上の最近傍節点を探し、対応付けを行う。 !>対応する各節点における流速を配列にして、そのままバイナリファイル出力を行う。 program CUBE2USG use plot3d_operator use VTK_operator_m use simpleFile_reader use array_m implicit none character ( 100 ) F_fname , USG_fname , casefname character ( 50 ), parameter :: filename = 'name.txt' character ( 50 ), allocatable :: field_name (:), caseName (:) character ( 20 ), parameter :: CorrespondenceFName = 'vtkCell2cubeNode.txt' integer fileID , num_record , num_cell , nc , nc_max real , allocatable :: velocity (:,:) type ( UnstructuredGrid_inVTK ) USG type ( Plot3dMesh ) cubeMesh type ( plot3dNodeInfo ), allocatable :: vtkCell2cubeNode (:) call read_textRecord ( filename , field_name ) num_record = size ( field_name ) print * , 'Case Name ?' read ( 5 , '(A)' ) casefname call read_textRecord ( casefname , caseName ) nc_max = size ( caseName ) print * , 'UnstructuredGRID_FileName ?' read ( 5 , * ) USG_fname call USG % read ( USG_fname ) num_cell = USG % get_numCell () cubeMesh = read_plot3d_multigrid ( 'mesh.g' ) !Gファイル読み込み do nc = 1 , nc_max do fileID = 1 , num_record F_fname = trim ( caseName ( nc )) // '/output/' // trim ( field_name ( fileID )) call cubeMesh % read_plot3d_function ( F_fname ) !Fファイル読み込み if (. not . allocated ( vtkCell2cubeNode )) call solve_correspondence if (. not . allocated ( velocity )) allocate ( velocity ( 3 , num_cell )) block integer cellID character (:), allocatable :: fname_base do cellID = 1 , num_cell velocity (:, cellID ) = cubeMesh % get_velocity ( vtkCell2cubeNode ( cellID )) end do fname_base = F_fname (: len_trim ( F_fname ) - 2 ) !流速場配列をバイナリ出力 call output_2dArray_asBinary ( fname = fname_base // '.array' , array = velocity ) !確認用に、ひとつだけVTKファイル出力 if ( fileID == 1 ) call USG % output ( fname_base // '.vtk' , cellVector = velocity , vectorName = 'Velocity' ) end block end do end do contains !>対応する節点情報をアスキーファイルで出力するサブルーチン subroutine output_nodeInfo integer n_unit , i print * , 'output: ' , CorrespondenceFName open ( newunit = n_unit , file = CorrespondenceFName , status = 'replace' , action = 'write' ) write ( n_unit , '(\"#cube \", i0)' ) cubeMesh % get_numCube () write ( n_unit , '(\"cubeshape\", 3(x, i0))' ) cubeMesh % get_cubeShape () write ( n_unit , '(\"#usgcell \", i0)' ) num_cell do i = 1 , num_cell write ( n_unit , '(i0, x, 3(x, i0))' ) vtkCell2cubeNode ( i )% cubeID , vtkCell2cubeNode ( i )% nodeID (:) end do close ( n_unit ) end subroutine !>非構造格子に対応する節点情報を探すサブルーチン subroutine search_nodeInfo use timeKeeper_m use terminalControler_m use unstructuredElement_m integer i real progress_percent , estimation , speed type ( TimeKeeper ) tk real , allocatable :: cellCenter (:,:) tk = TimeKeeper_ () print * , \"START : CUBENODE SEARCH\" call set_formatTC ( '(\"SEARCH vtkcell2cubenode [ \",f6.2,\" % ] \", f8.1, \" sec is left.\")' ) allocate ( vtkCell2cubeNode ( num_cell )) cellCenter = get_cellCenters ( USG % node_array , USG % cell_array ) do i = 1 , num_cell progress_percent = real ( i * 100 ) / real ( num_cell ) speed = real ( i ) / tk % erapsedTime () estimation = real ( num_cell - i ) / ( speed + 1.e-9 ) call print_progress ([ progress_percent , estimation ]) vtkCell2cubeNode ( i ) = cubeMesh % nearestNodeInfo ( cellCenter (:, i )) end do end subroutine !>節点情報対応付けファイルを読み込むサブルーチン subroutine read_nodeInfo ( success ) use array_m logical , intent ( out ) :: success integer n_unit , i , num_cell_ , num_cube , cubeShape ( 3 ) character dummy * 10 print * , 'read: ' , CorrespondenceFName open ( newunit = n_unit , file = CorrespondenceFName , status = 'old' , action = 'read' ) read ( n_unit , * ) dummy , num_cube read ( n_unit , * ) dummy , cubeShape read ( n_unit , * ) dummy , num_cell_ if (( num_cell_ /= num_cell ). or .( num_cube /= cubeMesh % get_numCube ()). or .& . not . all ( cubeShape == cubeMesh % get_cubeShape ())) then print * , 'SizeERROR:' , num_cell_ , num_cell , num_cube , cubeMesh % get_numCube () success = . false . return end if allocate ( vtkCell2cubeNode ( num_cell_ )) do i = 1 , num_cell_ read ( n_unit , * ) vtkCell2cubeNode ( i )% cubeID , vtkCell2cubeNode ( i )% nodeID (:) end do close ( n_unit ) success = . true . end subroutine !>格子と節点の対応付けを解決するサブルーチン subroutine solve_correspondence logical existance , success inquire ( file = CorrespondenceFName , exist = existance ) if ( existance ) then !対応付けファイルが存在すれば読み込む call read_nodeInfo ( success ) else success = . false . !なければ失敗 end if if (. not . success ) then !対応付けに失敗すれば改めて最近傍節点の探索を行う call search_nodeInfo call output_nodeInfo end if end subroutine end program CUBE2USG","tags":"","loc":"sourcefile\\cube2usg.f90.html"},{"title":"dropletCount.f90 – Droplets Simulation","text":"This file depends on sourcefile~~dropletcount.f90~~EfferentGraph sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~dropletcount.f90->sourcefile~virusdroplet.f90 sourcefile~boxcounter.f90 boxCounter.f90 sourcefile~dropletcount.f90->sourcefile~boxcounter.f90 sourcefile~casename.f90 caseName.f90 sourcefile~dropletcount.f90->sourcefile~casename.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~dropletcount.f90->sourcefile~vtkmesh_operator.f90 sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~dropletcount.f90->sourcefile~conditionvalue.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~boxcounter.f90->sourcefile~simplefile_reader.f90 sourcefile~casename.f90->sourcefile~simplefile_reader.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs dropletCount Source Code dropletCount.f90 Source Code program dropletCount !!ボックスを通過した飛沫をカウントする。 !!飛沫計算の出力ファイルを順に読み込み、各ボックスに対して内外判定を行う。 !!ボックス側では、通過した飛沫のIDしか見ておらず、同じIDの飛沫のダブルカウントなどは起こらない。 use virusDroplet_m use conditionValue_m ! use dropletEquation_m use boxCounter_m use caseName_m implicit none integer n , i_box , num_box , caseID character ( 50 ), allocatable :: caseName_array (:) character (:), allocatable :: caseName , fname integer , allocatable :: id_array (:) type ( virusDroplet_t ), allocatable :: mainDroplets (:), droplets (:) type ( conditionValue_t ) condVal ! type(BasicParameter) baseParam type ( boxCounter ), allocatable :: box_array (:) type boxResult_t integer num_droplet real volume , RoI end type type ( boxResult_t ), allocatable :: bResult (:) call case_check ( caseName_array ) !print*, 'caseName = ?' !read(5, *) caseName do caseID = 1 , size ( caseName_array ) caseName = trim ( caseName_array ( caseID )) condVal = read_condition ( caseName ) ! baseParam = BasicParameter_(condVal%dt, condVal%L, condVal%U) box_array = get_box_array ( caseName , condVal % num_drop ) num_box = size ( box_array ) do n = 0 , condVal % stepEnd , condVal % outputInterval if ( n == 0 ) then fname = caseName // '/backup/InitialDistribution.bu' else block character ( 255 ) str write ( str , '(\"' // caseName // '/backup/backup_\", i0 , \".bu\")' ) n fname = trim ( str ) end block end if mainDroplets = read_backup ( fname ) do i_box = 1 , num_box id_array = dropletIDinBox ( mainDroplets , dble ( box_array ( i_box )% min_cdn ), dble ( box_array ( i_box )% max_cdn )) call box_array ( i_box )% add_Flag ( id_array ) end do end do allocate ( bResult ( num_box )) do i_box = 1 , num_box id_array = box_array ( i_box )% get_FlagID () droplets = mainDroplets ( id_array ) bResult ( i_box )% num_droplet = size ( droplets ) bResult ( i_box )% volume = real ( dropletTotalVolume ( droplets ) * condVal % L ** 3 * 1.d6 ) !有次元化[m&#94;3]したのち、[ml]に換算 end do bResult (:)% RoI = RateOfInfection ( bResult (:)% volume ) !1分間あたりの感染確率を計算 call output_countCSV call output_boxVTK deallocate ( bResult ) end do contains subroutine output_countCSV integer n_unit , i character (:), allocatable :: csvFName csvFName = caseName // '/BoxCount.csv' print * , 'output: ' , csvFName open ( newunit = n_unit , file = csvFName , status = 'replace' ) write ( n_unit , '(\"x,y,z,num_drop,volume[ml],RoI\")' ) do i = 1 , size ( box_array ) write ( n_unit , '(*(g0:,\",\"))' ) box_array ( i )% center , bResult ( i )% num_droplet , bResult ( i )% volume , bResult ( i )% RoI end do close ( n_unit ) end subroutine subroutine output_boxVTK use VTK_operator_m type ( UnstructuredGrid_inVTK ) mesh integer i , j , k real , parameter :: trans ( 3 , 8 ) = reshape ([ & 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 , 1.0 , 1.0 , 0.0 , & 0.0 , 0.0 , 1.0 , 1.0 , 0.0 , 1.0 , 0.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 ], shape ( trans )) real , allocatable :: xyz (:,:) integer , allocatable :: vertices (:,:), types (:) allocate ( xyz ( 3 , num_box * 8 )) allocate ( vertices ( 8 , num_box ), types ( num_box )) do i = 1 , num_box do j = 1 , 8 k = j + 8 * ( i - 1 ) xyz (:, k ) = box_array ( i )% min_cdn (:) + box_array ( i )% width (:) * trans (:, j ) vertices ( j , i ) = k end do types ( i ) = 11 end do mesh = UnstructuredGrid_inVTK_ ( xyz , vertices , types ) call mesh % output ( caseName // '/Box.vtk' , cellScalar = bResult (:)% RoI , scalarName = 'RoI' ) end subroutine !>1分間あたりの感染確率を計算（もとの資料では1時間あたりの感染確率だが、1分間あたりに換算） elemental real function RateOfInfection ( volume ) real , intent ( in ) :: volume RateOfInfection = 1. - exp ( - volume * 1.e7 / ( 90 0. / 6 0. )) end function end program dropletCount","tags":"","loc":"sourcefile\\dropletcount.f90.html"},{"title":"initial_translate.f90 – Droplets Simulation","text":"This file depends on sourcefile~~initial_translate.f90~~EfferentGraph sourcefile~initial_translate.f90 initial_translate.f90 sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~initial_translate.f90->sourcefile~virusdroplet.f90 sourcefile~casename.f90 caseName.f90 sourcefile~initial_translate.f90->sourcefile~casename.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~casename.f90->sourcefile~simplefile_reader.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs translate Source Code initial_translate.f90 Source Code program translate !!author: Hikaru Konishi !!全飛沫に対して、基準点をbefore_dGroupCenter、回転軸をrotation_axisとして、反時計回りにphi[rad]だけ回転させる。 !!回転後の飛沫中心をafter_dGroupCenterに平行移動させる。 use virusDroplet_m use caseName_m implicit none type ( virusDroplet_t ), allocatable :: droplets (:) namelist / initial_translate_setting / fnameDecoration , before_dGroupCenter , after_dGroupCenter , & rotation_axis , rotation_angle_deg character ( 50 ), allocatable :: caseName_array (:) character (:), allocatable :: caseName character ( 15 ) fnameDecoration double precision before_dGroupCenter ( 3 ), after_dGroupCenter ( 3 ) character ( 1 ) rotation_axis double precision rotation_angle_deg integer i , n_unit double precision , parameter :: PI = acos ( - 1.d0 ) double precision vec ( 3 ), center_displacement ( 3 ) double precision phi ! これから移動を行いたいInitialDistribution.buのあるケース名の取得 call case_check ( caseName_array ) caseName = trim ( caseName_array ( 1 )) ! optionディレクトリのinitial_translate_setting.nmlの読み込み open ( newunit = n_unit , file = \"option\" // \"/initial_translate_setting.nml\" ) read ( n_unit , nml = initial_translate_setting ) close ( n_unit ) ! 読み込んだ値の確認 print '(*(g0:))' , \"fnameDecoration = \" , fnameDecoration print '(*(g0:,\" \"))' , \"before_dGroupCenter = \" , before_dGroupCenter print '(*(g0:,\" \"))' , \"after_dGroupCenter = \" , after_dGroupCenter print '(*(g0:))' , \"rotation_axis = \" , rotation_axis print '(*(g0:))' , \"rotation_angle_deg = \" , rotation_angle_deg ! backupファイルから飛沫の情報を取得 droplets = read_backup ( caseName // \"/backup/InitialDistribution.bu\" ) ! これから計算を行う上で必要な値の算出 phi = PI * ( rotation_angle_deg / 18 0.d0 ) ! [°]から[rad]への変換 center_displacement = after_dGroupCenter - before_dGroupCenter ! 変位量 ! 回転軸の切り替え select case ( rotation_axis ) case ( \"x\" ) ! 回転を行うループ do i = 1 , size ( droplets ) vec ( 2 ) = droplets ( i )% position ( 2 ) - before_dGroupCenter ( 2 ) vec ( 3 ) = droplets ( i )% position ( 3 ) - before_dGroupCenter ( 3 ) droplets ( i )% position ( 2 ) = cos ( phi ) * vec ( 2 ) - sin ( phi ) * vec ( 3 ) + before_dGroupCenter ( 2 ) droplets ( i )% position ( 3 ) = sin ( phi ) * vec ( 2 ) + cos ( phi ) * vec ( 3 ) + before_dGroupCenter ( 3 ) end do case ( \"y\" ) do i = 1 , size ( droplets ) vec ( 3 ) = droplets ( i )% position ( 3 ) - before_dGroupCenter ( 3 ) vec ( 1 ) = droplets ( i )% position ( 1 ) - before_dGroupCenter ( 1 ) droplets ( i )% position ( 3 ) = cos ( phi ) * vec ( 3 ) - sin ( phi ) * vec ( 1 ) + before_dGroupCenter ( 3 ) droplets ( i )% position ( 1 ) = sin ( phi ) * vec ( 3 ) + cos ( phi ) * vec ( 1 ) + before_dGroupCenter ( 1 ) end do case ( \"z\" ) do i = 1 , size ( droplets ) vec ( 1 ) = droplets ( i )% position ( 1 ) - before_dGroupCenter ( 1 ) vec ( 2 ) = droplets ( i )% position ( 2 ) - before_dGroupCenter ( 2 ) droplets ( i )% position ( 1 ) = cos ( phi ) * vec ( 1 ) - sin ( phi ) * vec ( 2 ) + before_dGroupCenter ( 1 ) droplets ( i )% position ( 2 ) = sin ( phi ) * vec ( 1 ) + cos ( phi ) * vec ( 2 ) + before_dGroupCenter ( 2 ) end do end select ! 平行移動を行うループ do i = 1 , size ( droplets ) droplets ( i )% position ( 1 ) = droplets ( i )% position ( 1 ) + center_displacement ( 1 ) droplets ( i )% position ( 2 ) = droplets ( i )% position ( 2 ) + center_displacement ( 2 ) droplets ( i )% position ( 3 ) = droplets ( i )% position ( 3 ) + center_displacement ( 3 ) end do ! ファイルの出力 call output_backup ( droplets , 'InitialDistribution_' // trim ( fnameDecoration ) // '.bu' ) call output_droplet_VTK ( droplets , 'InitialDistribution_' // trim ( fnameDecoration ) // '.vtk' ) end program translate","tags":"","loc":"sourcefile\\initial_translate.f90.html"},{"title":"MAIN.f90 – Droplets Simulation","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 MAIN.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 sourcefile~casename.f90 caseName.f90 sourcefile~main.f90->sourcefile~casename.f90 sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~virusdroplet.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~path_operator.f90 sourcefile~timekeeper.f90 timeKeeper.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~timekeeper.f90 sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletequation.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~conditionvalue.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~terminalcontroler.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~casename.f90->sourcefile~simplefile_reader.f90 sourcefile~dropletequation.f90->sourcefile~simplefile_reader.f90 sourcefile~vector.f90 vector.f90 sourcefile~dropletequation.f90->sourcefile~vector.f90 sourcefile~dropletgenerator.f90->sourcefile~virusdroplet.f90 sourcefile~dropletgenerator.f90->sourcefile~dropletequation.f90 sourcefile~dropletgenerator.f90->sourcefile~simplefile_reader.f90 sourcefile~array.f90 array.f90 sourcefile~dropletgenerator.f90->sourcefile~array.f90 sourcefile~flow_field.f90->sourcefile~path_operator.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~scffile_reader.f90 SCFfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~scffile_reader.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~scffile_reader.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs MAIN Source Code MAIN.f90 Source Code PROGRAM MAIN !!author: KIYOTA OGURA, Y.Ida !!summary: !!- 流れ場ファイルを読み込み、その流れ場における飛沫の運動をシミュレーション !!- 並列化には対応していない !$ use omp_lib use dropletMotionSimulation use caseName_m implicit none character ( 50 ), allocatable :: caseName (:) integer caseID !$OMP parallel !$OMP single !$ print *, \"Num threads:\", omp_get_num_threads() !$OMP end single !$OMP end parallel call read_basicSettingOnSimulation call case_check ( caseName ) DO caseID = 1 , size ( caseName ) !実行数だけループ（通常1回） call RunDropletsSimulation ( trim ( caseName ( caseID ))) END DO END PROGRAM MAIN","tags":"","loc":"sourcefile\\main.f90.html"},{"title":"adjacency_solver.f90 – Droplets Simulation","text":"This file depends on sourcefile~~adjacency_solver.f90~~EfferentGraph sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~adjacency_solver.f90~~AfferentGraph sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules adjacencySolver_m Source Code adjacency_solver.f90 Source Code MODULE adjacencySolver_m !!セルの隣接関係解決モジュール IMPLICIT NONE private integer , parameter , public :: None = - 1 !!整数配列中の欠損値の表現 integer , parameter :: max_adjacent = 5 !想定される最大隣接セル数（プリズムは最大５つのセルと隣接） integer , parameter :: max_boundFace = 4 !想定される最大境界面数（プリズムの５つの面のうち、すべて境界面はありえないので４） !>ハーフフェイス構造体 type halfFace_t integer :: nodeID ( 4 ) = None , pairID = None , ID_sum = 0 , ownerCellID ( 2 ) = None end type public solve_BoundaryAndAdjacency contains function get_halfFaceArray ( cellVertices ) result ( halfFaceArray ) !!各セルごとにハーフフェイスをカウントし、配列に格納 integer , intent ( in ) :: cellVertices (:,:) type ( halfFace_t ), allocatable :: halfFaceArray (:) INTEGER II , JJJ , j , n , JJJMX , num_halfFace , num_cell , vertexID character ( 5 ), allocatable :: cellType (:) character ( 5 ), parameter :: tetra = 'tetra' , prism = 'prism' , pyramid = 'pyrmd' !キーワード integer , allocatable :: halfFaceVerticesID (:,:) !以下、各ハーフフェイス頂点の順番を表す配列。 !例えば、テトラは４つの頂点から構成されており、ハーフフェイスも４つ。 !１つ目のハーフフェイスは、４つの頂点のうち 1,2,3 番目のものを頂点とする。 !以降、 2,3,4, 3,4,1, 4,1,2 番目を頂点とし、４つのハーフフェイスの定義が完了する。 integer , parameter :: halfFaceVerticesID_inTetra ( 3 , 4 ) = reshape (& [ 1 , 2 , 3 , 2 , 3 , 4 , 3 , 4 , 1 , 4 , 1 , 2 ], shape ( halfFaceVerticesID_inTetra )) integer , parameter :: halfFaceVerticesID_inPrism ( 4 , 5 ) = reshape (& [ 1 , 2 , 3 , None , 4 , 5 , 6 , None , 1 , 2 , 4 , 5 , 2 , 3 , 5 , 6 , 3 , 1 , 6 , 4 ], shape ( halfFaceVerticesID_inPrism )) integer , parameter :: halfFaceVerticesID_inPyramid ( 4 , 5 ) = reshape (& [ 5 , 1 , 2 , None , 5 , 2 , 3 , None , 5 , 3 , 4 , None , 5 , 4 , 1 , None , 1 , 2 , 3 , 4 ], shape ( halfFaceVerticesID_inPyramid )) num_cell = size ( cellVertices , dim = 2 ) !cellVerticesには、(6ｘセル数)の配列が入ってきている想定 if ( num_cell <= 0 ) then print * , 'ERROR_num_cells' , num_cell error stop end if allocate ( cellType ( num_cell )) DO II = 1 , num_cell select case ( count ( cellVertices (:, II ) /= None )) !頂点数（配列内のNoneでない要素数）で場合分け case ( 4 ) !頂点数が4個：テトラ cellType ( II ) = tetra case ( 6 ) !頂点数が6個：プリズム cellType ( II ) = prism case ( 5 ) !頂点数が5個：ピラミッド cellType ( II ) = pyramid case default print * , '**CEll VERTICES ERROR**' error stop end select END DO num_halfFace = count ( cellType == tetra ) * 4 + count ( cellType == prism ) * 5 + count ( cellType == pyramid ) * 5 !半面数：テトラ数×4 (+プリズム数×5 +ピラミッド数×5) allocate ( halfFaceArray ( num_halfFace )) JJJ = 0 DO II = 1 , num_cell select case ( cellType ( II )) case ( tetra ) halfFaceVerticesID = halfFaceVerticesID_inTetra case ( prism ) halfFaceVerticesID = halfFaceVerticesID_inPrism case ( pyramid ) halfFaceVerticesID = halfFaceVerticesID_inPyramid end select !halfFaceVerticesIDは２次元配列で、（頂点、ハーフフェイス） do j = 1 , size ( halfFaceVerticesID , dim = 2 ) !ハーフフェイスの数だけループ JJJ = JJJ + 1 !ハーフフェイスの絶対IDをカウント do n = 1 , size ( halfFaceVerticesID , dim = 1 ) !あるハーフフェイスにおける頂点数だけループ vertexID = halfFaceVerticesID ( n , j ) if ( vertexID /= None ) halfFaceArray ( JJJ )% nodeID ( n ) = cellVertices ( vertexID , II ) end do halfFaceArray ( JJJ )% ownerCellID ( 1 ) = II !現在はセルIIに着目しているので、自明ながらオーナーセルもII halfFaceArray ( JJJ )% ID_sum = sum ( halfFaceArray ( JJJ )% nodeID (:)) !IDの和を格納（あとで使う） end do END DO JJJMX = JJJ if ( JJJMX == num_halfFace ) then print * , 'JJJMX / num_halfFace =' , JJJMX , '/' , num_halfFace else print * , 'JJJMX_ERROR:' , JJJMX , num_halfFace error stop end if end function subroutine check_halfFace ( halfFaceArray , num_BoundFaces ) !!各ハーフフェイスに対して相方を探す !!相方がみつかれば、相方のセルと隣接していることがわかる !!相方のいないハーフフェイスは境界面 use terminalControler_m type ( halfFace_t ), intent ( inout ) :: halfFaceArray (:) integer , intent ( out ) :: num_BoundFaces INTEGER match , width , numNode , faceID , groupID , num_group , maxID_sum , num_halfFace integer checkCounter , faceCounter , i , j , faceID1 , faceID2 , num_face , k , l integer , allocatable :: faceID_array (:) type faceGroup_t integer , allocatable :: faceID (:) end type faceGroup_t type ( faceGroup_t ), allocatable :: faceGroup (:) ! real time1, time2 ! call cpu_time(time1) print * , 'START-FACE CHECK!' !同一面の探索 num_halfFace = size ( halfFaceArray ) num_group = num_halfFace / 5000 + 1 !面グループ数（1グループ数に約5000枚面が入るようにする）（この値は経験則） allocate ( faceGroup ( num_group )) allocate ( faceID_array ( num_halfFace ), source = 0 ) maxID_sum = maxval ( halfFaceArray (:)% ID_sum ) width = maxID_sum / num_group + 1 !1グループの幅（最大節点番号和を面グループ数で割る） checkCounter = 0 call set_formatTC ( '(\"DIVIDE halfFace [ #group : \",i6,\" / \",i6,\" ]\")' ) do groupID = 1 , num_group !面をグループに分ける call print_progress ([ groupID , num_group ]) faceID_array (:) = 0 faceCounter = 1 do faceID = 1 , num_halfFace if (( halfFaceArray ( faceID )% ID_sum > ( groupID - 1 ) * width ) & . and .( halfFaceArray ( faceID )% ID_sum <= groupID * width )) then faceID_array ( faceCounter ) = faceID faceCounter = faceCounter + 1 checkCounter = checkCounter + 1 end if end do faceGroup ( groupID )% faceID = faceID_array ( 1 : faceCounter - 1 ) end do if ( checkCounter /= num_halfFace ) then print * , 'faceCounter_ERROR:' , checkCounter , num_halfFace error stop end if num_BoundFaces = 0 call set_formatTC ( '(\"CHECK halfFace [ #group : \",i6,\" / \",i6,\" ]\")' ) !$omp parallel do private(faceID1,faceID2, match, k,l, num_face,numNode) reduction(+:num_BoundFaces) do groupID = 1 , num_group call print_progress ([ groupID , num_group ]) num_face = size ( faceGroup ( groupID )% faceID ) face1 : do i = 1 , num_face faceID1 = faceGroup ( groupID )% faceID ( i ) if ( halfFaceArray ( faceID1 )% ownerCellID ( 2 ) /= None ) cycle face1 !面共有セル探索が済んでいる場合スキップ if ( halfFaceArray ( faceID1 )% nodeID ( 4 ) == None ) then numNode = 3 !三角形面 else numNode = 4 !四角形面 end if face2 : do j = i + 1 , num_face faceID2 = faceGroup ( groupID )% faceID ( j ) if ( halfFaceArray ( faceID2 )% ownerCellID ( 2 ) /= None ) cycle face2 !面共有セル探索が済んでいる場合スキップ if (( numNode == 3 ) . and . ( halfFaceArray ( faceID2 )% nodeID ( 4 ) /= None )) cycle face2 !三角形面を注目中に四角形面が現れればスキップ match = 0 do k = 1 , numNode do l = 1 , numNode if ( halfFaceArray ( faceID1 )% nodeID ( k ) == halfFaceArray ( faceID2 )% nodeID ( l )) match = match + 1 !点IDが一致すればカウント end do end do if ( match < numNode ) cycle face2 !節点数と同じ回数一致しなければスキップ（必要十分条件） !ここまでくれば同一の2面発見 halfFaceArray ( faceID1 )% ownerCellID ( 2 ) = halfFaceArray ( faceID2 )% ownerCellID ( 1 ) halfFaceArray ( faceID2 )% ownerCellID ( 2 ) = halfFaceArray ( faceID1 )% ownerCellID ( 1 ) cycle face1 !共有セルが見つかったので次の面へ end do face2 ! halfFaceArray(faceID1)%ownerCellID(2) = 0 !共有セルが見つからなかった:境界面 num_BoundFaces = num_BoundFaces + 1 !境界面カウント end do face1 end do !$omp end parallel do print * , '# Boundary Face =' , num_BoundFaces print * , 'END-FACE CHECK!' ! call cpu_time(time2) ! print*, time2 - time1 ! error stop END subroutine check_halfFace subroutine find_boundFaceInformation ( halfFaceArray , num_boundFace , cellBoundFaces , triangleBoundFaceVertices ) !!境界面のみを取り出し、配列に格納 !!四角形面であったとしても、最初の3点だけ抽出し、三角形面にして返す type ( halfFace_t ), intent ( in ) :: halfFaceArray (:) integer , intent ( in ) :: num_boundFace INTEGER II , JJJ , JB integer , intent ( out ) :: cellBoundFaces (:,:) integer , allocatable :: NoB (:) integer , allocatable , intent ( out ) :: triangleBoundFaceVertices (:,:) allocate ( NoB ( size ( cellBoundFaces , dim = 2 )), source = 0 ) allocate ( triangleBoundFaceVertices ( 3 , num_BoundFace )) JB = 0 DO JJJ = 1 , size ( halfFaceArray ) if ( halfFaceArray ( JJJ )% ownerCellID ( 2 ) /= None ) cycle !第二オーナーが存在：境界面ではない：スルー JB = JB + 1 II = halfFaceArray ( JJJ )% ownerCellID ( 1 ) !JJが属する要素番号 NoB ( II ) = NoB ( II ) + 1 !IIが所有する境界面数カウント cellBoundFaces ( NoB ( II ), II ) = JB !IIが所有する境界面番号 triangleBoundFaceVertices ( 1 : 3 , JB ) = halfFaceArray ( JJJ )% nodeID ( 1 : 3 ) !四角形面であったとしても、最初の3点だけ抽出 END DO end subroutine subroutine find_adjacentCellID ( halfFaceArray , adjacentCellIDArray ) !!隣接関係を配列に格納 type ( halfFace_t ), intent ( in ) :: halfFaceArray (:) integer , intent ( out ) :: adjacentCellIDArray (:,:) integer II , JJJ integer , allocatable :: num_adjacent (:) allocate ( num_adjacent ( size ( adjacentCellIDArray )), source = 0 ) do JJJ = 1 , size ( halfFaceArray ) if ( halfFaceArray ( JJJ )% ownerCellID ( 2 ) == None ) cycle !第２オーナーが未発見のハーフフェイス：境界面：スルー II = halfFaceArray ( JJJ )% ownerCellID ( 1 ) num_adjacent ( II ) = num_adjacent ( II ) + 1 adjacentCellIDArray ( num_adjacent ( II ), II ) = halfFaceArray ( JJJ )% ownerCellID ( 2 ) end do end subroutine subroutine solve_BoundaryAndAdjacency ( cellVertices , cellBoundFaces , triangleBoundFaceVertices , adjacentCellIDArray ) !!境界面と隣接関係を、それぞれ配列に格納 integer , intent ( in ) :: cellVertices (:,:) !!セルの頂点ID配列（頂点ID,セルID） integer , allocatable , intent ( out ) :: cellBoundFaces (:,:) !!セルの境界面ID配列（境界面ID,セルID） integer , allocatable , intent ( out ) :: triangleBoundFaceVertices (:,:) !!境界面の頂点ID配列（頂点ID,境界面ID） integer , allocatable , intent ( out ) :: adjacentCellIDArray (:,:) !!セルの隣接セルID配列（隣接セルID,セルID） type ( halfFace_t ), allocatable :: halfFaceArray (:) integer num_cell , num_BoundFace print * , '~ SolvingAdjacency is Required. ~' halfFaceArray = get_halfFaceArray ( cellVertices ) !ハーフフェイスのセッティング call check_halfFace ( halfFaceArray , num_BoundFace ) !同一面のチェック num_cell = size ( cellVertices , dim = 2 ) allocate ( cellBoundFaces ( max_boundFace , num_cell ), source = None ) allocate ( adjacentCellIDArray ( max_adjacent , num_cell ), source = None ) call find_boundFaceInformation ( halfFaceArray , num_BoundFace , cellBoundFaces , triangleBoundFaceVertices ) !境界面情報 call find_adjacentCellID ( halfFaceArray , adjacentCellIDArray ) !セル隣接情報 end subroutine END MODULE adjacencySolver_m","tags":"","loc":"sourcefile\\adjacency_solver.f90.html"},{"title":"array.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~array.f90~~AfferentGraph sourcefile~array.f90 array.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~sort_test.f90 sort_test.f90 sourcefile~sort_test.f90->sourcefile~array.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletgenerator.f90->sourcefile~array.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~array.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules array_m Source Code array.f90 Source Code module array_m implicit none contains subroutine output_2dArray_asBinary ( fname , array ) character ( * ), intent ( in ) :: fname real , intent ( in ) :: array (:,:) integer n_unit print * , 'output_bin2dArray : ' , fname open ( newunit = n_unit , file = fname , form = 'unformatted' , status = 'replace' ) write ( n_unit ) shape ( array ) write ( n_unit ) array close ( n_unit ) end subroutine subroutine read_2dArray_asBinary ( fname , array ) character ( * ), intent ( in ) :: fname real , allocatable , intent ( out ) :: array (:,:) integer n_unit , arrayShape ( 2 ) print * , 'read_bin2dArray : ' , fname open ( newunit = n_unit , file = fname , form = 'unformatted' , status = 'old' , action = 'read' ) read ( n_unit ) arrayShape (:) allocate ( array ( arrayShape ( 1 ), arrayShape ( 2 ))) read ( n_unit ) array close ( n_unit ) end subroutine subroutine read_1dArray_real ( fname , array ) character ( * ), intent ( in ) :: fname real , allocatable , intent ( out ) :: array (:) integer n_unit , size print * , 'read_1darray : ' , fname open ( newunit = n_unit , file = fname , status = 'old' , action = 'read' ) read ( n_unit , * ) size allocate ( array ( size )) read ( n_unit , * ) array close ( n_unit ) end subroutine function mean_2dArray ( array ) result ( mean ) real , intent ( in ) :: array (:,:) real mean ( size ( array , dim = 2 )) integer i do i = 1 , size ( array , dim = 1 ) mean ( i ) = sum ( array ( i , :)) / size ( array , dim = 2 ) end do end function function FisherYates_shuffle ( a ) result ( b ) !!フィッシャー・イェーツのシャッフル !!参考：https://programming-place.net/ppp/contents/algorithm/other/002.html real , intent ( in ) :: a (:) real b ( size ( a )), rand , tmp integer i , index b = a do i = size ( b ), 2 , - 1 call random_number ( rand ) index = int ( rand * ( i - 1 )) + 1 ! print *, index, i !SWAP tmp = b ( index ) b ( index ) = b ( i ) b ( i ) = tmp end do end function end module array_m","tags":"","loc":"sourcefile\\array.f90.html"},{"title":"boxCounter.f90 – Droplets Simulation","text":"This file depends on sourcefile~~boxcounter.f90~~EfferentGraph sourcefile~boxcounter.f90 boxCounter.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~boxcounter.f90->sourcefile~simplefile_reader.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~boxcounter.f90~~AfferentGraph sourcefile~boxcounter.f90 boxCounter.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~boxcounter.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~boxcounter.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules boxCounter_m Source Code boxCounter.f90 Source Code module boxCounter_m implicit none type boxCounter real center ( 3 ), width ( 3 ), min_cdn ( 3 ), max_cdn ( 3 ) logical , allocatable :: Flag (:) contains procedure add_Flag procedure get_FlagID end type contains function get_box_array ( dir , num_Flag ) result ( new_box_array ) use simpleFile_reader type ( boxCounter ), allocatable :: new_box_array (:) character ( * ), intent ( in ) :: dir integer , intent ( in ) :: num_Flag double precision , allocatable :: boxSize_mat (:,:) integer i , num_box call read_CSV ( filename = dir // '/boxList.csv' , matrix = boxSize_mat , header = . true .) num_box = size ( boxSize_mat , dim = 2 ) allocate ( new_box_array ( num_box )) do i = 1 , num_box new_box_array ( i )% center (:) = real ( boxSize_mat ( 1 : 3 , i )) new_box_array ( i )% width (:) = real ( boxSize_mat ( 4 : 6 , i )) new_box_array ( i )% min_cdn (:) = new_box_array ( i )% center (:) - new_box_array ( i )% width (:) * 0.5 new_box_array ( i )% max_cdn (:) = new_box_array ( i )% center (:) + new_box_array ( i )% width (:) * 0.5 if (( new_box_array ( i )% width ( 1 ) <= 0.d0 )& . or .( new_box_array ( i )% width ( 2 ) <= 0.d0 ). or .( new_box_array ( i )% width ( 3 ) <= 0.d0 )) then print * , 'ERROR boxSize :' , new_box_array ( i )% center (:), new_box_array ( i )% width (:) error stop end if allocate ( new_box_array ( i )% Flag ( num_Flag ), source = . false .) end do end function subroutine add_Flag ( self , id_array ) class ( boxCounter ) self integer , intent ( in ) :: id_array (:) self % Flag ( id_array ) = . true . end subroutine function get_FlagID ( self ) result ( id_array ) class ( boxCounter ) self integer , allocatable :: id_array (:) integer i , cnt , n_size n_size = count ( self % Flag ) allocate ( id_array ( n_size )) cnt = 0 do i = 1 , size ( self % Flag ) if ( self % Flag ( i )) then cnt = cnt + 1 id_array ( cnt ) = i end if end do end function end module boxCounter_m","tags":"","loc":"sourcefile\\boxcounter.f90.html"},{"title":"caseName.f90 – Droplets Simulation","text":"This file depends on sourcefile~~casename.f90~~EfferentGraph sourcefile~casename.f90 caseName.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~casename.f90->sourcefile~simplefile_reader.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~casename.f90~~AfferentGraph sourcefile~casename.f90 caseName.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~casename.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~casename.f90 sourcefile~initial_translate.f90 initial_translate.f90 sourcefile~initial_translate.f90->sourcefile~casename.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules caseName_m Source Code caseName.f90 Source Code module caseName_m implicit none contains subroutine case_check ( caseName_array ) !!case名をキーボードから取得する。 !!TXTファイルを指定すると、それを全行読み込んで配列に格納。 use simpleFile_reader character ( * ), allocatable , intent ( out ) :: caseName_array (:) character ( 255 ) caseName integer i logical existance character ( 21 ), parameter :: conditionFName = 'condition.nml' print * , 'Case Name ?' read ( 5 , '(A)' ) caseName if ( index ( caseName , '.txt' ) > 0 ) then call read_textRecord ( trim ( caseName ), caseName_array ) else caseName_array = [ caseName ] end if do i = 1 , size ( caseName_array ) inquire ( file = trim ( caseName_array ( i )) // '/' // conditionFName , exist = existance ) if (. not . existance ) then print * , 'Case:[ ' , trim ( caseName_array ( i )), ' ] is not found.' error stop end if end do end subroutine end module caseName_m","tags":"","loc":"sourcefile\\casename.f90.html"},{"title":"conditionValue.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~conditionvalue.f90~~AfferentGraph sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~conditionvalue.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~conditionvalue.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~conditionvalue.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules conditionValue_m Source Code conditionValue.f90 Source Code module conditionValue_m !!飛沫計算用の諸条件を取り扱う implicit none private !>条件値クラス !>条件指定ファイル（namelist）を読み込んだ結果を格納する type , public :: conditionValue_t !!飛沫計算用の諸条件をまとめた構造体 double precision dt , L , U , direction_g ( 3 ) character (:), allocatable :: initialDistributionFName integer restart , stepEnd , outputInterval , num_drop , periodicGeneration real T , RH character (:), allocatable :: path2FlowFile , meshFile double precision DT_FLOW integer OFFSET , INTERVAL_FLOW , LoopHead , LoopTail contains procedure isInitialDistributionSpecified !!飛沫初期分布ファイルが指定されたか否かを返す procedure isMeshFileSpecified !!メッシュファイルが別途指定されたか否かを返す end type public read_condition contains function read_condition ( dir ) result ( self ) !!条件ファイルを読み込み、結果を構造体で返す。 !!このサブルーチン実装当時、構造体をそのままnamelistにできることを知らず、わざわざ変数ひとつひとつ定義した。 !!現在ここを変えると進行中のプロジェクト（オフィス飛沫計算など）に影響が出るおそれがあり、触れない。 !!いつか修正したい。 type ( conditionValue_t ) self character ( * ), intent ( in ) :: dir integer n_unit character ( 4 ), parameter :: None = 'None' double precision delta_t , L_represent , U_represent , direction_g ( 3 ) character ( 255 ) :: initialDistributionFName integer num_restart , n_end , outputInterval , num_droplets real temperature , relativeHumidity integer :: periodicGeneration = 0 character ( 255 ) PATH2FlowFile , meshFile double precision DT_FLOW integer OFFSET , INTERVAL_FLOW , LoopHead , LoopTail character ( 21 ), parameter :: conditionFName = 'condition.nml' namelist / dropletSetting / num_restart , n_end , delta_t , outputInterval , temperature , relativeHumidity ,& num_droplets , direction_g , initialDistributionFName , periodicGeneration namelist / flowFieldSetting / PATH2FlowFile , meshFile , DT_FLOW , OFFSET , INTERVAL_FLOW , LoopHead , LoopTail ,& L_represent , U_represent initialDistributionFName = None !初期化 meshFile = None !初期化 OPEN ( newunit = n_unit , FILE = dir // '/' // conditionFName , status = 'old' , action = 'read' ) read ( n_unit , nml = dropletSetting ) read ( n_unit , nml = flowFieldSetting ) CLOSE ( n_unit ) self % dt = delta_t self % L = L_represent self % U = U_represent self % direction_g (:) = direction_g (:) if ( initialDistributionFName /= None ) self % initialDistributionFName = trim ( initialDistributionFName ) self % restart = num_restart self % stepEnd = n_end self % outputInterval = outputInterval self % num_drop = num_droplets self % T = temperature self % RH = relativeHumidity self % periodicGeneration = periodicGeneration self % PATH2FlowFile = trim ( PATH2FlowFile ) if ( meshFile /= None ) self % meshFile = trim ( meshFile ) self % DT_FLOW = DT_FLOW self % OFFSET = OFFSET self % INTERVAL_FLOW = INTERVAL_FLOW self % LoopHead = LoopHead self % LoopTail = LoopTail end function logical function isInitialDistributionSpecified ( self ) class ( conditionValue_t ), intent ( in ) :: self isInitialDistributionSpecified = allocated ( self % initialDistributionFName ) end function logical function isMeshFileSpecified ( self ) class ( conditionValue_t ), intent ( in ) :: self isMeshFileSpecified = allocated ( self % meshFile ) end function end module conditionValue_m","tags":"","loc":"sourcefile\\conditionvalue.f90.html"},{"title":"dropletEquation.f90 – Droplets Simulation","text":"This file depends on sourcefile~~dropletequation.f90~~EfferentGraph sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~vector.f90 vector.f90 sourcefile~dropletequation.f90->sourcefile~vector.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~dropletequation.f90->sourcefile~simplefile_reader.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~dropletequation.f90~~AfferentGraph sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletgenerator.f90->sourcefile~dropletequation.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletequation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dropletEquation_m Source Code dropletEquation.f90 Source Code module dropletEquation_m !!飛沫の方程式モジュール implicit none private !>基礎変数クラス !>時間間隔や代表値を格納 type , public :: BasicParameter private double precision dt !無次元時間間隔 double precision L , U , Re ! integer, public, target :: timeStep = 0   !構造体の要素はtarget属性にできないぽい contains procedure :: repValue => representativeValue procedure TimeStep2RealTime end type double precision , parameter :: Rho = 1.205d0 ! 空気の密度[kg/m3] double precision , parameter :: Mu = 1.822d-5 ! 空気の粘性係数[Pa・sec] double precision , parameter :: Rho_d = 0.99822d3 ! 飛沫（水）の密度[kg/m3] double precision , parameter :: gamma = Rho / Rho_d !密度比（空気密度 / 飛沫(水)密度） !>飛沫方程式ソルバクラス !>蒸発方程式や運動方程式を解くメソッドを保持 type , public , extends ( BasicParameter ) :: DropletEquationSolver private double precision coeff_drdt !!半径変化率の無次元係数 double precision G ( 3 ) !!無次元重力加速度 real T , RH double precision minimumRadiusRatio double precision , allocatable :: minimumRadiusMatrix (:,:) contains procedure set_gravity_acceleration , set_dropletEnvironment , dropletEnvironment procedure set_coeff_drdt , set_minimumRadiusRatio procedure next_position , next_velocity procedure get_radiusLowerLimitRatio procedure :: evaporationEq => evaporationEquation procedure solve_motionEquation end type ! double precision :: Re_d_min = 1.d2 public BasicParameter_ , DropletEquationSolver_ contains type ( BasicParameter ) function BasicParameter_ ( delta_t , L_represent , U_represent ) double precision , intent ( in ) :: delta_t , L_represent , U_represent BasicParameter_ % dt = delta_t BasicParameter_ % L = L_represent BasicParameter_ % U = U_represent print * , 'Delta_Time =' , BasicParameter_ % dt BasicParameter_ % Re = BasicParameter_ % U * BasicParameter_ % L * Rho / Mu end function type ( DropletEquationSolver ) function DropletEquationSolver_ ( delta_t , L_represent , U_represent , & direction_g , Temperature , RelativeHumidity ) double precision , intent ( in ) :: delta_t , L_represent , U_represent double precision , intent ( in ) :: direction_g ( 3 ) real , intent ( in ) :: Temperature , RelativeHumidity DropletEquationSolver_ % BasicParameter = BasicParameter_ ( delta_t , L_represent , U_represent ) call DropletEquationSolver_ % set_gravity_acceleration ( direction_g ) call DropletEquationSolver_ % set_dropletEnvironment ( Temperature , RelativeHumidity ) end function subroutine set_gravity_acceleration ( self , direction_g ) use vector_m class ( DropletEquationSolver ) self double precision , intent ( in ) :: direction_g ( 3 ) double precision , parameter :: G_dim = 9.806650d0 ! 重力加速度[m/s2] double precision norm norm = G_dim * self % L / ( self % U * self % U ) self % G (:) = norm * normalize_vector ( direction_g (:)) !無次元重力加速度 print * , 'Dimensionless Acceleration of Gravity :' print * , self % G (:) end subroutine subroutine set_dropletEnvironment ( self , Temperature , RelativeHumidity ) class ( DropletEquationSolver ) self real , intent ( in ) :: Temperature , RelativeHumidity self % T = Temperature self % RH = RelativeHumidity call self % set_coeff_drdt () !温湿度依存の係数の設定 call self % set_minimumRadiusRatio () end subroutine real function dropletEnvironment ( self , name ) class ( DropletEquationSolver ) self character ( * ), intent ( in ) :: name select case ( name ) case ( 'Temperature' ) dropletEnvironment = self % T case ( 'RelativeHumidity' ) dropletEnvironment = self % RH case default dropletEnvironment = - 1.e20 end select end function subroutine set_coeff_drdt ( self ) class ( DropletEquationSolver ) self !===================================================================================== double precision Es , TK double precision , parameter :: Rv = 46 1.51d0 ! 水蒸気の気体定数[J/(kg.K)] double precision , parameter :: T0 = 27 3.15d0 ! [K] double precision , parameter :: D = 0.2564d-4 ! 水蒸気の拡散定数[m2/s] double precision , parameter :: Lv = 2.451d6 ! 水の蒸発潜熱[J/kg] double precision , parameter :: Es0 = 6.11d2 ! 基準温度における飽和蒸気圧[Pa] !===================================================================================== TK = dble ( self % T ) + T0 ! 室温を絶対温度[K]に変換 Es = Es0 * exp (( Lv / Rv ) * ( 1.0d0 / T0 - 1.0d0 / TK )) ! 室温における飽和蒸気圧 self % coeff_drdt = - D / ( self % U * self % L ) * ( 1.0d0 - dble ( self % RH ) / 10 0.d0 ) * Es / ( Rho_d * Rv * TK ) ! dr/dt の無次元係数 print * , 'coeff_drdt=' , self % coeff_drdt end subroutine subroutine set_minimumRadiusRatio ( self ) !!湿度から、飛沫の下限半径と初期半径との比を求める。 use simpleFile_reader class ( DropletEquationSolver ) self integer i , i_max call read_CSV ( 'data/minimum_radius.csv' , self % minimumRadiusMatrix ) i_max = size ( self % minimumRadiusMatrix , dim = 2 ) i = 1 do while ( self % minimumRadiusMatrix ( 1 , i ) < self % RH ) i = i + 1 if ( i == i_max ) exit end do self % minimumRadiusRatio = self % minimumRadiusMatrix ( 2 , i ) print * , 'Dmin/D0 =' , self % minimumRadiusRatio , self % RH end subroutine double precision function get_radiusLowerLimitRatio ( self ) !!下限半径と初期半径との比を返す class ( DropletEquationSolver ), intent ( in ) :: self ! if(RH < 64) then !     minimum_radius(:) = initial_radius(:)*0.19d0 ! else if(RH < 90) then !     minimum_radius(:) = initial_radius(:)*(0.073*exp(0.014*dble(RH))) ! else if(RH == 90) then !     minimum_radius(:) = initial_radius(:)*0.28d0 ! else if(RH < 100) then !     minimum_radius(:) = initial_radius(:)*(0.0001*exp(0.0869*dble(RH))) ! else !     minimum_radius(:) = initial_radius(:) ! end if get_radiusLowerLimitRatio = self % minimumRadiusRatio end function function evaporationEquation ( self , radius ) result ( dr ) !!蒸発方程式。半径変化量を返す。 class ( DropletEquationSolver ) self double precision , intent ( in ) :: radius double precision drdt1 , dr1 , drdt2 , dr2 , r_approxi , dr !========= 飛沫半径の変化の計算　(2次精度ルンゲクッタ（ホイン）) =========================== drdt1 = self % coeff_drdt / radius dr1 = drdt1 * self % dt r_approxi = radius + dr1 drdt2 = self % coeff_drdt / r_approxi dr2 = drdt2 * self % dt dr = ( dr1 + dr2 ) * 0.5d0 end function subroutine solve_motionEquation ( self , X , V , Va , R ) !!運動方程式を解く。 !!引数の値が上書きされる。 class ( DropletEquationSolver ) self double precision , intent ( inout ) :: X ( 3 ), V ( 3 ) double precision , intent ( in ) :: Va ( 3 ), R double precision V_now ( 3 ) V_now (:) = V (:) V (:) = self % next_velocity ( V_now (:), Va (:), R ) X (:) = self % next_position ( X (:), V_now (:), V (:)) end subroutine function next_velocity ( self , vel_d , vel_a , radius_d ) result ( vel_d_next ) !!次時刻における速度を計算 class ( DropletEquationSolver ) self double precision , intent ( in ) :: vel_d ( 3 ), vel_a ( 3 ), radius_d double precision speed_r , Re_d , CD , C , vel_d_next ( 3 ) if ( radius_d <= 0.d0 ) then print * , '**ZeroRadius ERROR**' , radius_d error stop end if speed_r = norm2 ( vel_a (:) - vel_d (:)) !相対速度の大きさ Re_d = ( speed_r * 2.0d0 * radius_d ) * self % Re CD = DragCoefficient ( Re_d ) !抗力係数 C = ( 3.0d0 * CD * gamma * speed_r ) / ( 8.0d0 * radius_d ) vel_d_next (:) = ( vel_d (:) + ( self % G (:) + C * vel_a (:) ) * self % dt ) / ( 1.0d0 + C * self % dt ) end function function next_position ( self , x1 , v1 , v2 ) result ( x2 ) !!次時刻における位置を返す class ( DropletEquationSolver ) self double precision , intent ( in ) :: x1 ( 3 ), v1 ( 3 ), v2 ( 3 ) double precision x2 ( 3 ) x2 (:) = x1 (:) + ( v1 (:) + v2 (:)) * 0.5d0 * self % dt end function double precision function DragCoefficient ( Re_d ) !!球体の抗力係数を返す double precision , intent ( in ) :: Re_d !!球体周りのレイノルズ数 double precision Re_d_ ! Re_d_min = min(Re_d_min, Re_d) Re_d_ = Re_d + 1.d-16 !ゼロ割回避のため、小さな値を足す !この値は経験則でしかないが、球体周りのレイノルズ数の最小値はだいたい10のマイナス9乗 DragCoefficient = ( 2 4.d0 / Re_d_ ) * ( 1.d0 + 0.15d0 * ( Re_d_ ** 0.687d0 )) end function ! double precision function survival_rate(step) !     integer, intent(in) :: step !     double precision time !     !このへんはインフルエンザのデータ（現在不使用） !     ! if(RH == 80)then  !　相対湿度80%の時使用 !     !     survival_rate = 0.67d0*0.5102d0**(((L/U)*dt*dble(step-1))/3600.0d0) !     ! else if(RH == 50)then  !　相対湿度50%の時使用 !     !     survival_rate = 0.84d0*0.5735d0**(((L/U)*dt*dble(step-1))/3600.0d0) !     ! else if(RH == 35)then  !　相対湿度35%の時使用 !     !     survival_rate = 0.86d0*0.9240d0**(((L/U)*dt*dble(step-1))/3600.0d0) !     ! end if !     time = TimeOnSimu(step, dimension=.true.) !     !新型コロナウイルス（1.1時間で半減） !     survival_rate = 0.999825d0**(time) ! end function ! elemental double precision function virusDeadline(self, deathParameter) !     class(DropletEquationSolver), intent(in) :: self !     double precision, intent(in) :: deathParameter !     double precision, parameter :: halfLife = 3960.d0   !半減期 1.1 h ( = 3960 sec) !     double precision, parameter :: alpha = log(2.d0) / halfLife !     virusDeadline = - log(deathParameter) / alpha !     virusDeadline = virusDeadline * self%U/self%L !無次元化 ! end function double precision function representativeValue ( self , name ) class ( BasicParameter ) self character ( * ), intent ( in ) :: name ! if(L*U <= 0.d0) print*, '**WARNING** ZeroRepresentativeValue :', L, U   !代表値がゼロなら警告 select case ( name ) case ( 'length' ) representativeValue = self % L case ( 'speed' ) representativeValue = self % U case ( 'time' ) representativeValue = self % L / self % U case default print * , 'RepresentativeValueERROR : ' , name error stop end select ! print*, 'Re_d_min=', Re_d_min end function double precision function TimeStep2RealTime ( self , step , dimension ) class ( BasicParameter ) self integer , intent ( in ) :: step logical , intent ( in ) :: dimension TimeStep2RealTime = step * self % dt if ( dimension ) TimeStep2RealTime = TimeStep2RealTime * self % repValue ( 'time' ) end function ! double precision function deltaTime() !     deltaTime = dt ! end function end module dropletEquation_m","tags":"","loc":"sourcefile\\dropletequation.f90.html"},{"title":"dropletGenerator.f90 – Droplets Simulation","text":"This file depends on sourcefile~~dropletgenerator.f90~~EfferentGraph sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~dropletgenerator.f90->sourcefile~virusdroplet.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~dropletgenerator.f90->sourcefile~simplefile_reader.f90 sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~dropletgenerator.f90->sourcefile~dropletequation.f90 sourcefile~array.f90 array.f90 sourcefile~dropletgenerator.f90->sourcefile~array.f90 sourcefile~dropletequation.f90->sourcefile~simplefile_reader.f90 sourcefile~vector.f90 vector.f90 sourcefile~dropletequation.f90->sourcefile~vector.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~dropletgenerator.f90~~AfferentGraph sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dropletGenerator_m Source Code dropletGenerator.f90 Source Code module dropletGenerator_m use virusDroplet_m use dropletEquation_m implicit none private type placementBox double precision center ( 3 ), width ( 3 ) end type type SequentialArray private integer index real , allocatable :: array (:) contains procedure set_SequentialArray procedure :: get_value => get_valueFromSequentialArray procedure :: get_valueArray => get_valueArrayFromSequentialArray end type type , public :: DropletGenerator private type ( DropletEquationSolver ), pointer :: equation type ( placementBox ), allocatable :: pBox_array (:) ! double precision, allocatable :: radiusThreshold(:,:) type ( SequentialArray ) initialRadiusArray , deadlineArray integer :: generateRate = 0 contains procedure , public :: generateDroplet procedure , public :: periodicGeneration => dropletPeriodicGeneration procedure set_dropletPlacementBox procedure calc_initialPosition end type ! public BasicParameter, DropletEquationSolver, BasicParameter_, DropletEquationSolver_ public DropletGenerator_ contains type ( DropletGenerator ) function DropletGenerator_ ( & equation , radiusDistributionFile , positionDir , generationRate ) !コンストラクタ type ( DropletEquationSolver ), target :: equation character ( * ), intent ( in ) :: radiusDistributionFile character ( * ), intent ( in ) :: positionDir integer , intent ( in ) :: generationRate DropletGenerator_ % equation => equation call DropletGenerator_ % initialRadiusArray % set_SequentialArray ( 'data/' // radiusDistributionFile ) call DropletGenerator_ % deadlineArray % set_SequentialArray ( 'data/deadline.txt' ) call DropletGenerator_ % set_dropletPlacementBox ( positionDir ) DropletGenerator_ % generateRate = generationRate end function function generateDroplet ( self , num_droplet , nowTime ) result ( droplets ) class ( DropletGenerator ) self type ( virusDroplet_t ), allocatable :: droplets (:) integer , intent ( in ) :: num_droplet double precision , intent ( in ) :: nowTime double precision , allocatable :: initialRadius (:), deadline (:) if ( num_droplet <= 0 ) return allocate ( droplets ( num_droplet )) call self % calc_initialPosition ( droplets ) initialRadius = self % initialRadiusArray % get_valueArray ( num_droplet ) * 1.d-6 !マイクロメートル換算 initialRadius = initialRadius / self % equation % repValue ( 'length' ) !無次元化 call set_initialRadius ( droplets , initialRadius ) call set_radiusLowerLimit ( droplets , self % equation % get_radiusLowerLimitRatio ()) deadline = self % deadlineArray % get_valueArray ( num_droplet ) / self % equation % repValue ( 'time' ) !無次元化 deadline = deadline + nowTime call set_virusDeadline ( droplets , deadline ) if ( self % generateRate > 0 ) call set_dropletStatus ( droplets , 'nonActive' ) end function subroutine calc_initialPosition ( self , droplets ) class ( DropletGenerator ), intent ( in ) :: self type ( virusDroplet_t ), intent ( inout ) :: droplets (:) integer kx , ky , kz , num_perEdge , num_perBox , k , k_end , cnt integer i_box , num_box , num_drop double precision :: standard ( 3 ), delta ( 3 ), width ( 3 ) !, randble(3) if (. not . allocated ( self % pBox_array )) then print * , 'ERROR : InitialPositionBox is not Set.' error stop end if num_box = size ( self % pBox_array ) num_drop = size ( droplets ) num_perBox = num_drop / num_box ! print*, 'calc_initialPosition' num_perEdge = 1 do while ( num_box * (( num_perEdge + 1 ) ** 3 ) < num_drop ) num_perEdge = num_perEdge + 1 !配置帯一辺当たりの飛沫数 end do k = 1 cnt = 1 box : do i_box = 1 , num_box k_end = i_box * num_perBox if ( i_box == num_box ) k_end = num_drop width (:) = self % pBox_array ( i_box )% width (:) standard (:) = self % pBox_array ( i_box )% center (:) - 0.5d0 * self % pBox_array ( i_box )% width (:) if ( num_perEdge >= 2 ) then delta (:) = width (:) / dble ( num_perEdge - 1 ) do kx = 1 , num_perEdge do ky = 1 , num_perEdge do kz = 1 , num_perEdge droplets ( k )% position ( 1 ) = standard ( 1 ) + delta ( 1 ) * dble ( kx - 1 ) droplets ( k )% position ( 2 ) = standard ( 2 ) + delta ( 2 ) * dble ( ky - 1 ) droplets ( k )% position ( 3 ) = standard ( 3 ) + delta ( 3 ) * dble ( kz - 1 ) k = k + 1 end do end do end do end if if ( k <= k_end ) then block integer d , d_max integer :: direction ( 3 , 6 ) = reshape ([ 1 , 0 , 0 , - 1 , 0 , 0 , 0 , 1 , 0 , 0 , - 1 , 0 , 0 , 0 , 1 , 0 , 0 , - 1 ], shape ( direction )) width (:) = 0.d0 d_max = 1 placement : do ! call random_number(randble(:)) ! droplets(k)%position(:) = standard(:) + width(:)*randble(:) do d = 1 , d_max droplets ( k )% position (:) = self % pBox_array ( i_box )% center (:) + width (:) * dble ( direction (:, d )) k = k + 1 if ( k > k_end ) exit placement end do width (:) = ( width (:) + 0.5d0 * self % pBox_array ( i_box )% width (:)) * 0.5d0 d_max = 6 end do placement end block end if ! print*, 'BOX', i_box, 'has', k - cnt, 'droplets.' cnt = k end do box end subroutine subroutine set_dropletPlacementBox ( self , positionDir ) use simpleFile_reader class ( DropletGenerator ) self character ( * ), intent ( in ) :: positionDir integer i_box , num_box double precision , allocatable :: position_mat (:,:) character (:), allocatable :: fname logical existance character ( 20 ), parameter :: IniPositionFName = 'initial_position.csv' fname = positionDir // '/' // IniPositionFName inquire ( file = fname , exist = existance ) if (. not . existance ) then print * , '**Warning** ' // fname // ' is not found!' return end if call read_CSV ( fname , position_mat ) num_box = size ( position_mat , dim = 2 ) allocate ( self % pBox_array ( num_box )) do i_box = 1 , num_box self % pBox_array ( i_box )% center (:) = position_mat ( 1 : 3 , i_box ) self % pBox_array ( i_box )% width (:) = position_mat ( 4 : 6 , i_box ) end do end subroutine subroutine dropletPeriodicGeneration ( self , droplets , nowTime , stat ) class ( DropletGenerator ) self type ( virusDroplet_t ), intent ( inout ) :: droplets (:) double precision , intent ( in ) :: nowTime integer num_generated , required_generation , num_nowGenerate logical , intent ( out ) :: stat stat = . false . if ( self % generateRate == 0 ) return required_generation = int ( dble ( self % generateRate ) * nowTime * self % equation % repValue ( 'time' )) !このステップ終了までに生成されているべき数 num_generated = dropletCounter ( droplets , 'total' ) - dropletCounter ( droplets , 'nonActive' ) !今までに生成された数 if ( num_generated == size ( droplets )) return !生成され尽くした場合リターン num_nowGenerate = required_generation - num_generated !今このステップで生成されるべき数 ! print*, num_generated, required_generation, num_nowGenerate block integer generateEnd , nonActive_perBox , i_box , num_box , generate_perBox integer , allocatable :: nonActiveID_array (:) num_box = size ( self % pBox_array ) if ( num_nowGenerate >= num_box ) then nonActiveID_array = dropletIDinState ( droplets , 'nonActive' ) if ( required_generation < size ( droplets )) then nonActive_perBox = size ( nonActiveID_array ) / num_box generate_perBox = num_nowGenerate / num_box do i_box = 1 , num_box generateEnd = min ( nonActive_perBox * ( i_box - 1 ) + generate_perBox , nonActive_perBox * i_box ) call set_dropletStatus ( droplets , 'floating' , nonActiveID_array ( nonActive_perBox * ( i_box - 1 ) + 1 : generateEnd )) end do else !この時刻までに生成されているべき数が総飛沫数未満でない　＝＞　全て生成されるべき call set_dropletStatus ( droplets , 'floating' , nonActiveID_array (:)) end if stat = . true . end if end block ! print*, TimeOnSimu(), num_generated end subroutine subroutine set_SequentialArray ( self , filename ) use array_m class ( SequentialArray ) self character ( * ), intent ( in ) :: filename call read_1dArray_real ( filename , self % array ) self % index = 1 end subroutine real function get_valueFromSequentialArray ( self ) class ( SequentialArray ) self get_valueFromSequentialArray = self % array ( self % index ) self % index = self % index + 1 if ( self % index > size ( self % array )) self % index = 1 end function function get_valueArrayFromSequentialArray ( self , arraySize ) result ( array ) class ( SequentialArray ) self integer , intent ( in ) :: arraySize real , allocatable :: array (:) integer i allocate ( array ( arraySize )) do i = 1 , arraySize array ( i ) = self % get_value () end do end function subroutine check_category ( array , categories , frequency ) real , intent ( in ) :: array (:) real category_array ( size ( array )) integer frequency_array ( size ( array )) integer i , i_ctgry , num_category logical hit real , allocatable , intent ( out ) :: categories (:) integer , allocatable , intent ( out ) :: frequency (:) category_array = - 1.e20 category_array ( 1 ) = array ( 1 ) frequency_array ( 1 ) = 1 num_category = 1 do i = 2 , size ( array ) hit = . false . do i_ctgry = 1 , num_category if ( array ( i ) == category_array ( i_ctgry )) then frequency_array ( i_ctgry ) = frequency_array ( i_ctgry ) + 1 hit = . true . exit end if end do if (. not . hit ) then num_category = num_category + 1 category_array ( num_category ) = array ( i ) frequency_array ( num_category ) = 1 end if end do categories = category_array (: num_category ) frequency = frequency_array (: num_category ) end subroutine end module dropletGenerator_m","tags":"","loc":"sourcefile\\dropletgenerator.f90.html"},{"title":"dropletMotionSimulation.f90 – Droplets Simulation","text":"This file depends on sourcefile~~dropletmotionsimulation.f90~~EfferentGraph sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~virusdroplet.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~path_operator.f90 sourcefile~timekeeper.f90 timeKeeper.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~timekeeper.f90 sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletequation.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~conditionvalue.f90 conditionValue.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~conditionvalue.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~terminalcontroler.f90 sourcefile~vector.f90 vector.f90 sourcefile~dropletequation.f90->sourcefile~vector.f90 sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~dropletequation.f90->sourcefile~simplefile_reader.f90 sourcefile~dropletgenerator.f90->sourcefile~virusdroplet.f90 sourcefile~dropletgenerator.f90->sourcefile~dropletequation.f90 sourcefile~dropletgenerator.f90->sourcefile~simplefile_reader.f90 sourcefile~array.f90 array.f90 sourcefile~dropletgenerator.f90->sourcefile~array.f90 sourcefile~flow_field.f90->sourcefile~path_operator.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~scffile_reader.f90 SCFfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~scffile_reader.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~scffile_reader.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~dropletmotionsimulation.f90~~AfferentGraph sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dropletMotionSimulation Source Code dropletMotionSimulation.f90 Source Code module dropletMotionSimulation !!author: Yuta Ida !!飛沫運動シミュレーションモジュール use virusDroplet_m use dropletGenerator_m use dropletEquation_m use flow_field_m use timeKeeper_m implicit none private type ( TimeKeeper ) tK logical :: startFlag = . false . logical :: adhesionSwitch = . true . integer :: coalescenceLimit = 10000 , num_divide = 4 character (:), allocatable :: radiusDistributionFilename public RunDropletsSimulation , read_basicSettingOnSimulation contains subroutine simulationSetUp ( case_dir , droplets , dropletSolver , dropGenerator , flow_field , n_start , n_end , outputInterval ) !!シミュレーションの条件ファイルを読み込み、諸々の変数を初期化して引数として返す use virusDroplet_m use conditionValue_m character ( * ), intent ( in ) :: case_dir !!ケースディレクトリ名 type ( virusDroplet_t ), allocatable , intent ( out ) :: droplets (:) !!飛沫構造体配列 type ( DropletEquationSolver ), target , intent ( out ) :: dropletSolver !!飛沫の運動方程式クラス type ( DropletGenerator ), intent ( out ) :: dropGenerator !!飛沫発生源クラス type ( FlowField ), intent ( out ) :: flow_field !!流れ場クラス integer , intent ( out ) :: n_start , n_end integer , intent ( out ) :: outputInterval type ( conditionValue_t ) condVal call create_CaseDirectory ( case_dir ) condVal = read_condition ( case_dir ) n_end = condVal % stepEnd outputInterval = condVal % outputInterval print * , 'n_end =' , n_end print * , 'output interval =' , outputInterval dropletSolver = DropletEquationSolver_ ( & condVal % dt , condVal % L , condVal % U , & condVal % direction_g , condVal % T , condVal % RH & ) n_start = max ( condVal % restart , 0 ) dropGenerator = DropletGenerator_ ( & dropletSolver , radiusDistributionFilename , case_dir , & generationRate = condVal % periodicGeneration & ) if ( condVal % restart <= 0 ) then if ( condVal % isInitialDistributionSpecified ()) then droplets = read_backup ( case_dir // '/' // condVal % initialDistributionFName ) else droplets = dropGenerator % generateDroplet ( condVal % num_drop , dropletSolver % TimeStep2RealTime ( n_start , . false .)) end if call output_droplet_process ( case_dir = case_dir , initial = . true ., droplets = droplets , & timeStep = n_start , real_time = dropletSolver % TimeStep2RealTime ( n_start , . true .)) !この時点では、飛沫の参照セルは見つかっていない else print * , '**RESTART**' block character ( 255 ) fname write ( fname , '(\"' // case_dir // '/backup/backup_\", i0, \".bu\")' ) condVal % restart droplets = read_backup ( trim ( fname )) !ここで自動割り付け end block end if print * , 'num_droplets =' , size ( droplets ) call checkpoint if ( condVal % isMeshFileSpecified ()) then flow_field = FlowField_ ( & !流れ場の取得 dropletSolver % TimeStep2RealTime ( step = n_start , dimension = . false .), & condVal % PATH2FlowFile , condVal % DT_FLOW , condVal % OFFSET , condVal % INTERVAL_FLOW , & condVal % LoopHead , condVal % LoopTail , & condVal % meshFile & ) else flow_field = FlowField_ ( & !流れ場の取得 dropletSolver % TimeStep2RealTime ( step = n_start , dimension = . false .), & condVal % PATH2FlowFile , condVal % DT_FLOW , condVal % OFFSET , condVal % INTERVAL_FLOW , & condVal % LoopHead , condVal % LoopTail & ) end if if ( condVal % restart <= 0 ) call first_refCellSearch ( droplets , flow_field ) !ここでようやく飛沫の参照セル探索 end subroutine subroutine read_basicSettingOnSimulation !!シミュレーションの基礎的な設定ファイルを読み込む integer n_unit character ( 23 ) :: fname = 'option/basicSetting.nml' character ( 255 ) radiusDistributionFNAME namelist / basicSetting / coalescenceLimit , adhesionSwitch , num_divide , radiusDistributionFNAME print * , 'READ : ' , fname open ( newunit = n_unit , file = fname , status = 'old' , action = 'read' ) read ( n_unit , nml = basicSetting ) close ( n_unit ) radiusDistributionFilename = trim ( radiusDistributionFNAME ) end subroutine subroutine RunDropletsSimulation ( case_name ) !!飛沫運動シミュレーションの実行 character ( * ), intent ( in ) :: case_name !!ケースディレクトリ名 type ( virusDroplet_t ), allocatable :: mainDroplets (:) type ( DropletEquationSolver ), target :: dropletSolver type ( DropletGenerator ) dropGenerator type ( FlowField ) flow_field integer n , n_start , n_end , outputInterval double precision timeInSimulation integer last_coalescenceStep logical generationFlag call simulationSetUp ( case_name , mainDroplets , dropletSolver , dropGenerator , flow_field , n_start , n_end , outputInterval ) last_coalescenceStep = n_start print '(\"*******************************************\")' print '(\"            START step_loop                \")' print '(\"*******************************************\")' do n = n_start + 1 , n_end !ステップ数だけループ timeInSimulation = dropletSolver % TimeStep2RealTime ( n , . false .) call dropGenerator % periodicGeneration ( mainDroplets , timeInSimulation , generationFlag ) if ( adhesionSwitch ) call adhesion_check ( mainDroplets , flow_field ) call survival_check ( mainDroplets , timeInSimulation ) !生存率に関する処理 call coalescence_process ( mainDroplets , n , last_coalescenceStep , generationFlag ) !飛沫間の合体判定 call Calculation_Droplets ( mainDroplets , dropletSolver , flow_field ) !飛沫の運動計算 if ( mod ( n , outputInterval ) == 0 ) then block double precision real_time real_time = dropletSolver % TimeStep2RealTime ( n , . true .) call output_droplet_process ( case_dir = case_name , & initial = . false ., droplets = mainDroplets , timeStep = n , real_time = real_time ) call periodicOutput ( n , n_end , mainDroplets , real_time , flow_field % get_nearerSearchFalseRate ()) end block end if if ( n == n_end ) exit call check_FlowFieldUpdate ( timeInSimulation , flow_field , mainDroplets ) !流れ場の更新チェック end do print '(\"*******************************************\")' print '(\"             END step_loop                 \")' print '(\"*******************************************\")' call output_ResultSummary ( case_name , mainDroplets , dropletSolver , flow_field , n_start , n_end , outputInterval ) end subroutine subroutine check_FlowFieldUpdate ( time , flow_field , droplets ) !!現時点のシミュレーション時刻から流れ場の更新が必要かを判定し、必要であれば更新する !!更新時、付着飛沫の移動も行う（移動格子への考慮） double precision , intent ( in ) :: time !!現時点のシミュレーション時刻 type ( FlowField ), intent ( inout ) :: flow_field type ( virusDroplet_t ), intent ( inout ) :: droplets (:) call flow_field % set_time ( time ) if ( flow_field % isUpdateTiming ()) then call flow_field % update () !流れ場の更新 call dropletOnBoundary ( droplets , flow_field ) end if end subroutine subroutine first_refCellSearch ( droplets , flow_field ) !!飛沫の参照セル探索化 !!初期飛沫は一箇所に密集していることを利用した時間短縮機能を実装 type ( virusDroplet_t ), intent ( inout ) :: droplets (:) type ( FlowField ), intent ( inout ) :: flow_field integer j , num_drop logical success real position ( 3 ) print * , 'first_refCellSearch occured!' num_drop = size ( droplets ) j = 1 droplets ( j )% refCellID = flow_field % nearest_cell ( real ( droplets ( j )% position (:))) droplets ( j + 1 :)% refCellID = droplets ( j )% refCellID !時間短縮を図る do j = 2 , num_drop position = real ( droplets ( j )% position (:)) call flow_field % search_refCELL ( position , droplets ( j )% refCellID , stat = success ) if (. not . success ) droplets ( j + 1 :)% refCellID = droplets ( j )% refCellID end do ! call mainMesh%sort() end subroutine subroutine adhesion_check ( droplets , flow_field ) !!流れ場境界面への飛沫付着判定 use unstructuredGrid_m type ( virusDroplet_t ), intent ( inout ) :: droplets (:) type ( FlowField ), intent ( in ) :: flow_field integer i do i = 1 , size ( droplets ) if ( droplets ( i )% isFloating ()) then call flow_field % adhesionCheckOnBound ( & droplets ( i )% position , droplets ( i )% get_radius (), droplets ( i )% refCellID , & stat = droplets ( i )% adhesBoundID & ) if ( droplets ( i )% adhesBoundID >= 1 ) call droplets ( i )% stop_droplet () end if end do call area_check ( droplets , flow_field ) end subroutine subroutine area_check ( droplets , flow_field ) !!流れ場のバウンディングボックスへの飛沫付着判定 type ( virusDroplet_t ), intent ( inout ) :: droplets (:) type ( FlowField ), intent ( in ) :: flow_field logical check real areaMin ( 3 ), areaMax ( 3 ) integer i , J call flow_field % get_MinMaxOfGrid ( areaMin , areaMax ) do i = 1 , size ( droplets ) check = . false . do J = 1 , 3 if ( droplets ( i )% position ( J ) < areaMin ( J )) then droplets ( i )% position ( J ) = areaMin ( J ) check = . true . else if ( droplets ( i )% position ( J ) > areaMax ( J )) then droplets ( i )% position ( J ) = areaMax ( J ) check = . true . end if end do if ( check ) call droplets ( i )% stop_droplet () end do end subroutine subroutine dropletOnBoundary ( droplets , flow_field ) !!流れ場境界面の移動に合わせて付着飛沫も移動させる use unstructuredGrid_m type ( virusDroplet_t ), intent ( inout ) :: droplets (:) type ( FlowField ), intent ( in ) :: flow_field integer vn , JB ! print*, 'CALL:dropletOnBoundary' do vn = 1 , size ( droplets ) if ( droplets ( vn )% isFloating ()) cycle !付着していないならスルー JB = droplets ( vn )% adhesBoundID if ( JB > 0 ) then droplets ( vn )% position (:) & = droplets ( vn )% position (:) & + flow_field % get_movementVectorOfBoundarySurface ( JB ) !面重心の移動量と同じだけ移動 end if end do ! call area_check(dGroup) ! print*, 'FIN:dropletOnBoundary' end subroutine subroutine Calculation_Droplets ( droplets , dropletSolver , flow_field ) !!飛沫の運動に関する一連の処理 !!蒸発方程式、運動方程式を解いたあと、飛沫の参照セル探索を行う type ( virusDroplet_t ), intent ( inout ) :: droplets (:) type ( DropletEquationSolver ), intent ( in ) :: dropletSolver type ( FlowField ), intent ( in ) :: flow_field integer vn , targetID double precision velAir ( 3 ) real position ( 3 ) !$omp parallel do do vn = 1 , size ( droplets ) if ( droplets ( vn )% isFloating ()) then call evaporationProcess ( droplets ( vn ), dropletSolver ) !蒸発方程式関連の処理 velAir (:) = flow_field % get_flowVelocityInCELL ( droplets ( vn )% refCellID ) call dropletSolver % solve_motionEquation (& droplets ( vn )% position (:), droplets ( vn )% velocity (:), velAir (:), droplets ( vn )% get_radius ()) position = real ( droplets ( vn )% position (:)) call flow_field % search_refCELL ( position , droplets ( vn )% refCellID ) else targetID = droplets ( vn )% coalescenceID () if ( targetID > 0 ) then !合体飛沫の片割れも移動させる droplets ( vn )% position = droplets ( targetID )% position droplets ( vn )% velocity = droplets ( targetID )% velocity end if end if end do !$omp end parallel do end subroutine subroutine evaporationProcess ( droplet , dropletSolver ) !!CALCULATE droplet evaporation use virusDroplet_m type ( virusDroplet_t ), intent ( inout ) :: droplet type ( DropletEquationSolver ), intent ( in ) :: dropletSolver double precision dr if (. not . droplet % isEvaporating ()) return !半径が最小になったものを除く dr = dropletSolver % evaporationEq ( droplet % get_radius ()) !半径変化量 call droplet % evaporation ( dr ) end subroutine subroutine output_droplet_process ( case_dir , initial , droplets , timeStep , real_time ) !!飛沫情報のファイル出力 !!VTK, CSV, backupファイルを出力 character ( * ), intent ( in ) :: case_dir logical , intent ( in ) :: initial type ( virusDroplet_t ), intent ( in ) :: droplets (:) integer , intent ( in ) :: timeStep double precision , intent ( in ) :: real_time character ( 22 ), parameter :: IniDistributionFName = 'InitialDistribution.bu' character ( 255 ) fname write ( fname , '(\"' // case_dir // '/VTK/drop_\", i0, \".vtk\")' ) timeStep call output_droplet_VTK ( droplets , fname , deadline = initial ) fname = case_dir // '/particle.csv' call output_droplet_CSV ( droplets , fname , real_time , initial ) if ( initial ) then fname = case_dir // '/backup/' // IniDistributionFName else write ( fname , '(\"' // case_dir // '/backup/backup_\", i0, \".bu\")' ) timeStep end if call output_backup ( droplets , trim ( fname )) end subroutine subroutine coalescence_process ( mainDroplets , timeStep , last_coalescenceStep , generationFlag ) !!飛沫間の合体判定プロセス !!一定期間合体が起こらなければ以降は判定をオフにする機能付き（計算コスト削減のため） use terminalControler_m type ( virusDroplet_t ), intent ( inout ) :: mainDroplets (:) !!メインの飛沫構造体配列 integer , intent ( in ) :: timeStep !!時間ステップ integer , intent ( inout ) :: last_coalescenceStep !! 最後に合体が起こったときの時間ステップ logical , intent ( in ) :: generationFlag !! 飛沫が新たに発生したか否か integer numFloating , num_coalescence numFloating = dropletCounter ( mainDroplets , 'floating' ) if ( generationFlag ) last_coalescenceStep = timeStep - 1 !飛沫発生が起こったら前ステップに付着が起こったことにする（付着判定再起動のため） !最後の合体から指定ステップが経過したら、以降は合体が起こらないとみなしてリターン if (( timeStep - last_coalescenceStep ) > coalescenceLimit ) return call set_formatTC ( '(\" Coalescence_check [step:\", i10, \"/\", i10, \"]\")' ) call print_progress ([ timeStep , last_coalescenceStep + coalescenceLimit ]) ! call mainDroplet%coalescence_check(stat = num_coalescence) call divideAreaCoalescence_process ( mainDroplets = mainDroplets , num_coales = num_coalescence ) if ( num_coalescence >= 1 ) last_coalescenceStep = timeStep end subroutine subroutine divideAreaCoalescence_process ( mainDroplets , num_coales ) !!飛沫をいくつかのエリアに分割し、それぞれで別々に合体判定を行う（計算コスト削減のため） type ( virusDroplet_t ), intent ( inout ) :: mainDroplets (:) !! メインの飛沫構造体配列 integer , intent ( out ) :: num_coales !!合体が起こった回数 type ( virusDroplet_t ), allocatable :: droplets (:) integer i , j , k , id , m , stat_coales integer , allocatable :: ID_array (:) double precision AreaMin ( 3 ), AreaMax ( 3 ), width ( 3 ), delta ( 3 ), min_cdn ( 3 ), max_cdn ( 3 ) double precision , parameter :: deltaRatio = 1.d-2 num_coales = 0 if ( num_divide <= 0 ) return call get_dropletsArea ( mainDroplets , AreaMin , AreaMax ) ! AreaMin(:) = AreaMin(:) - 1.d-9 ;print*, 'AreaMin:',AreaMin ! AreaMax(:) = AreaMax(:) + 1.d-9 ;print*, 'AreaMax:',AreaMax width (:) = ( AreaMax (:) - AreaMin (:)) / dble ( num_divide ) !;print*, 'width:',width delta (:) = ( AreaMax (:) - AreaMin (:)) * deltaRatio do k = 1 , num_divide min_cdn ( 3 ) = AreaMin ( 3 ) + width ( 3 ) * dble ( k - 1 ) - delta ( 3 ) max_cdn ( 3 ) = AreaMin ( 3 ) + width ( 3 ) * dble ( k ) + delta ( 3 ) do j = 1 , num_divide min_cdn ( 2 ) = AreaMin ( 2 ) + width ( 2 ) * dble ( j - 1 ) - delta ( 2 ) max_cdn ( 2 ) = AreaMin ( 2 ) + width ( 2 ) * dble ( j ) + delta ( 2 ) do i = 1 , num_divide min_cdn ( 1 ) = AreaMin ( 1 ) + width ( 1 ) * dble ( i - 1 ) - delta ( 1 ) max_cdn ( 1 ) = AreaMin ( 1 ) + width ( 1 ) * dble ( i ) + delta ( 1 ) ID_array = dropletIDinBox ( mainDroplets , min_cdn , max_cdn , status = 0 ) ! print*, 'divide_stat :', size(ID_array), min_cdn, max_cdn droplets = mainDroplets ( ID_array ) !分割エリア内の飛沫を抽出（ここでIDが変わる） call coalescence_check ( droplets , stat = stat_coales ) !分割エリア内で合体判定 num_coales = num_coales + stat_coales block integer coalesID do m = 1 , size ( ID_array ) id = ID_array ( m ) mainDroplets ( id ) = droplets ( m ) !飛沫情報をもとのIDに格納 coalesID = droplets ( m )% coalescenceID () !合体飛沫については、合体先ID（coalesID）ももとのIDに戻す必要がある if ( coalesID > 0 ) mainDroplets ( id )% coalesID = ID_array ( coalesID ) end do end block end do end do end do end subroutine subroutine checkpoint !! 計算条件確認のためのチェックポイント character ( 1 ) input do while (. not . startFlag ) print * , 'Do you want to start the calculation? (y/n)' read ( 5 , * ) input select case ( input ) case ( 'y' ) startFlag = . true . case ( 'n' ) stop end select end do tK = TimeKeeper_ () end subroutine subroutine create_CaseDirectory ( case_dir ) !!連番ファイル出力用のディレクトリを作成 use path_operator_m character ( * ), intent ( in ) :: case_dir call make_directory ( case_dir // '/VTK' ) call make_directory ( case_dir // '/backup' ) end subroutine subroutine periodicOutput ( nowStep , endStep , droplets , real_time , nearerSearchFalseRate ) !!一定のステップ周期で飛沫情報をコンソールに出力する use terminalControler_m integer , intent ( in ) :: nowStep !!現在の時間ステップ integer , intent ( in ) :: endStep !!終了時間ステップ type ( virusDroplet_t ), intent ( in ) :: droplets (:) !!飛沫構造体配列 double precision , intent ( in ) :: real_time !!シミュレーション時刻[sec] real , intent ( in ) :: nearerSearchFalseRate !!飛沫の参照セル探索（時間短縮版）の成功率 print * , '[Start Date] ' // tk % startDateAndTime () print '(\" ** It will take\", f8.2, \" minites **\")' , real ( endStep - nowStep ) / ( 6 0. * real ( nowStep ) / tK % erapsedTime ()) print * , 'Now_Step_Time =' , real_time , '[sec]' print * , '# floating :' , dropletCounter ( droplets , 'floating' ), '/' , dropletCounter ( droplets , 'total' ) if ( nearerSearchFalseRate >= 1. ) print * , '# searchFalseRate :' , nearerSearchFalseRate , '%' print '(\"====================================================\")' call reset_formatTC end subroutine subroutine output_ResultSummary ( case_dir , droplets , dropletSolver , flow_field , n_start , n_end , outputInterval ) !!シミュレーション結果のサマリーをファイル出力 use dropletEquation_m character ( * ), intent ( in ) :: case_dir type ( virusDroplet_t ), allocatable , intent ( in ) :: droplets (:) type ( DropletEquationSolver ), target , intent ( in ) :: dropletSolver type ( FlowField ), intent ( in ) :: flow_field integer , intent ( in ) :: n_start , n_end , outputInterval integer n_unit , cnt real erapsed_time character ( 50 ) fname logical existance double precision TimeStart , TimeEnd character (:), allocatable :: startDAT , endDAT erapsed_time = tk % erapsedTime () startDAT = '[Start Date] ' // tk % startDateAndTime () endDAT = '[ END  Date] ' // nowDateAndTime () print * , startDAT print * , endDAT fname = case_dir // '/ResultSummary.txt' inquire ( file = fname , exist = existance ) cnt = 0 do while ( existance ) cnt = cnt + 1 write ( fname , '(\"' // case_dir // '/ResultSummary_\", i0, \".txt\")' ) cnt inquire ( file = fname , exist = existance ) end do TimeStart = dropletSolver % TimeStep2RealTime ( step = n_start , dimension = . true .) TimeEnd = dropletSolver % TimeStep2RealTime ( step = n_end , dimension = . true .) open ( newunit = n_unit , file = fname , status = 'new' ) write ( n_unit , * ) '*******************************************' write ( n_unit , * ) '*                                         *' write ( n_unit , * ) '*             Result Summary              *' write ( n_unit , * ) '*                                         *' write ( n_unit , * ) '*******************************************' write ( n_unit , '(A)' ) '=======================================================' write ( n_unit , * ) startDAT write ( n_unit , * ) endDAT write ( n_unit , '(A18, F15.3, 2X, A)' ) 'Erapsed Time =' , erapsed_time , '[sec]' write ( n_unit , '(A18, F15.3, 2X, A)' ) 'Cost of Calc =' , & erapsed_time / ( TimeEnd - TimeStart ), '[sec/sec]' write ( n_unit , '(A)' ) '=======================================================' write ( n_unit , '(A18, 2(F15.3,2x,A))' ) 'Time [sec] =' , TimeStart , '-' , TimeEnd write ( n_unit , '(A18, 2(I15,2x,A))' ) 'Step =' , n_start , '-' , n_end !計算回数 write ( n_unit , '(A18, I15)' ) 'OutputInterval =' , outputInterval write ( n_unit , '(A)' ) '=======================================================' write ( n_unit , '(A18, I15)' ) '#Droplets =' , dropletCounter ( droplets , 'total' ) write ( n_unit , '(A18, I15)' ) 'floating =' , dropletCounter ( droplets , 'floating' ) write ( n_unit , '(A18, I15)' ) 'death =' , dropletCounter ( droplets , 'death' ) !生存率で消滅 write ( n_unit , '(A18, I15)' ) 'coalescence =' , dropletCounter ( droplets , 'coalescence' ) !生存率で消滅 write ( n_unit , '(A18, I15)' ) 'adhesion =' , dropletCounter ( droplets , 'adhesion' ) !付着したすべてのウイルス数 write ( n_unit , '(A)' ) '=======================================================' write ( n_unit , '(A18, F18.2)' ) 'Temp [degC] =' , dropletSolver % dropletEnvironment ( 'Temperature' ) write ( n_unit , '(A18, F18.2)' ) 'RH [%] =' , dropletSolver % dropletEnvironment ( 'RelativeHumidity' ) write ( n_unit , '(A18, 2X, A)' ) 'Used FlowFile :' , flow_field % get_defaultFlowFileName () write ( n_unit , '(A18, I15,2x,A, f8.3,2x,A)' ) 'SearchFalseInfo :' , flow_field % get_num_nearerSearchFalse (), & ' (' , flow_field % get_nearerSearchFalseRate (), '%)' close ( n_unit ) end subroutine ! double precision function TimeOnSimu(dropletSolver, dimension) !     type(DropletEquationSolver), target, intent(in) :: dropletSolver !     logical, intent(in), optional :: dimension !     if(present(dimension)) then !         TimeOnSimu = dropletSolver%TimeStep2RealTime(timeStep, dimension) !     else !         TimeOnSimu = dropletSolver%TimeStep2RealTime(timeStep, .false.) !     end if ! end function ! subroutine random_set    !実行時刻に依存した乱数シードを指定する !     implicit none !     integer :: seedsize, i !     integer, allocatable :: seed(:) !     print*, 'call:random_set' !     call random_seed(size=seedsize) !シードのサイズを取得。（コンパイラごとに異なるらしい） !     allocate(seed(seedsize)) !新シード配列サイズの割り当て !     do i = 1, seedsize !         call system_clock(count=seed(i)) !時間を新シード配列に取得 !     end do !     call random_seed(put=seed(:)) !新シードを指定 ! end subroutine random_set end module dropletMotionSimulation","tags":"","loc":"sourcefile\\dropletmotionsimulation.f90.html"},{"title":"flow_field.f90 – Droplets Simulation","text":"This file depends on sourcefile~~flow_field.f90~~EfferentGraph sourcefile~flow_field.f90 flow_field.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~flow_field.f90->sourcefile~path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~vector.f90 vector.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~array.f90 array.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~scffile_reader.f90 SCFfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~scffile_reader.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~scffile_reader.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~flow_field.f90~~AfferentGraph sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules flow_field_m Source Code flow_field.f90 Source Code module flow_field_m use unstructuredGrid_m implicit none private type , public , extends ( FlowFieldUnstructuredGrid ) :: FlowField private integer INTERVAL !! 気流ファイル出力間隔 integer LoopHead !! 流れ場ファイルのループの先頭 integer LoopTail !! 流れ場ファイルのループの末尾 integer OFFSET !! 流れ場と飛沫の間の時間ステップオフセット double precision DT !! 流体計算の時間間隔 integer STEP !! 時間ステップ integer NextUpdate !! 次に流れ場更新を行うべき時間ステップ character (:), allocatable :: FullFileName !! デフォルトの流れ場ファイル名 character (:), allocatable :: FileNameFormat !! 流れ場ファイルのファイル名のフォーマット文字列 contains private procedure , public :: update => update_FlowField procedure , public :: get_defaultFlowFileName , isUpdateTiming procedure , public :: set_time => set_timeSTEPinFLOW procedure set_FileNameFormat , calc_NextUpdate , get_FileNumber , clamp_STEP procedure :: get_requiredFileName => get_requiredFlowFieldFileName end type public FlowField_ contains function FlowField_ (& time , PATH2FlowFile , DeltaT , OFFSET , outputINTERVAL , LoopHead , LoopTail , meshFile & ) result ( flow_field ) double precision , intent ( in ) :: time !! 現在無次元時刻 double precision , intent ( in ) :: DeltaT !! 流体計算の時間間隔 integer , intent ( in ) :: OFFSET , outputINTERVAL , LoopHead , LoopTail character ( * ), intent ( in ) :: PATH2FlowFile character ( * ), intent ( in ), optional :: meshFile type ( FlowField ) flow_field call flow_field % set_FileNameFormat ( PATH2FlowFile ) flow_field % INTERVAL = outputINTERVAL if ( flow_field % INTERVAL <= 0 ) then print * , 'AirFlow is Steady' else print * , 'Interval of AirFlow =' , flow_field % INTERVAL flow_field % OFFSET = OFFSET print * , 'OFFSET =' , flow_field % OFFSET flow_field % LoopHead = LoopHead flow_field % LoopTail = LoopTail if ( flow_field % LoopTail - flow_field % LoopHead > 0 ) then print * , 'Loop is from' , flow_field % LoopHead , 'to' , flow_field % LoopTail elseif ( flow_field % LoopTail - flow_field % LoopHead == 0 ) then print * , 'After' , flow_field % LoopTail , ', Checkout SteadyFlow' end if flow_field % DT = DeltaT print * , 'Delta_Time inFLOW =' , flow_field % DT call flow_field % set_time ( time ) end if if ( present ( meshFile )) then flow_field % FlowFieldUnstructuredGrid = FlowFieldUnstructuredGrid_withMeshFile (& flow_field % get_requiredFileName (), meshFile & ) else flow_field % FlowFieldUnstructuredGrid = FlowFieldUnstructuredGrid_ ( flow_field % get_requiredFileName ()) end if call flow_field % calc_NextUpdate () end function subroutine set_FileNameFormat ( self , PATH2FlowFile ) !! ファイル名から連番の位置を取得し、ファイル名のフォーマットを推論する use path_operator_m class ( FlowField ) self character ( * ), intent ( in ) :: PATH2FlowFile character (:), allocatable :: PATH2FlowDir , prefix , suffix , FileName integer i_integerPart , i_ , i_dot integer num_digit !ファイル名の整数部桁数 self % FullFileName = PATH2FlowFile call get_DirFromPath ( PATH2FlowFile , PATH2FlowDir , FileName ) i_integerPart = index ( FileName , '0' ) !ひとまず最初のゼロの位置を整数部位置とする i_ = index ( FileName , '_' , back = . true .) !アンダーバーの位置取得 if ( i_ > i_integerPart ) i_integerPart = i_ + 1 !アンダーバーの位置がゼロの位置より後ろの場合、アンダーバー以降を整数部位置とする prefix = FileName (: i_integerPart - 1 ) !ファイル名の接頭部(整数部位置の手前まで) i_dot = index ( FileName , '.' ) !ドットの位置 num_digit = i_dot - i_integerPart !ファイル名の整数部桁数(整数部位置からドットまでの文字数) suffix = FileName ( i_dot : ) block character ( 2 * ( num_digit / 10 + 1 ) + 2 ) digitsFormat if ( suffix == '.fld' . or . suffix == '.fph' ) then digitsFormat = 'i0' else write ( digitsFormat , '(\"i\", i0, \".\", i0)' ) num_digit , num_digit end if self % FileNameFormat = '(\"' // PATH2FlowDir // prefix // '\",' // trim ( digitsFormat ) // ',\"' // suffix // '\")' print * , 'self%FileNameFormat : ' , self % FileNameFormat end block end subroutine function get_requiredFlowFieldFileName ( self ) result ( FileName ) !! 現時刻ステップに対応する流れ場ファイル名を返す class ( FlowField ) self character (:), allocatable :: FileName if ( self % INTERVAL <= 0 ) then FileName = self % FullFileName else block character ( 255 ) str write ( str , self % FileNameFormat ) self % get_FileNumber () FileName = trim ( str ) end block end if end function subroutine update_FlowField ( self ) !! 流れ場を更新する class ( FlowField ) self call self % updateWithFlowFieldFile ( self % get_requiredFileName ()) call self % calc_NextUpdate () print * , \"Update_FlowField : FIN\" end subroutine logical function isUpdateTiming ( self ) !! 現在ステップが流れ場更新のタイミングかどうかを判定 class ( FlowField ) self if ( self % STEP >= self % NextUpdate . and . self % INTERVAL > 0 ) then !現在ステップが更新ステップ以降でなおかつ非定常流 isUpdateTiming = . true . else isUpdateTiming = . false . end if end function subroutine set_timeSTEPinFLOW ( self , time ) !! 流れ場に現在時刻を通知 class ( FlowField ) self DOUBLE PRECISION , intent ( in ) :: time !! 飛沫計算における時刻 self % STEP = int ( time / self % DT ) + self % OFFSET !気流計算における時刻ステップ数に相当 end subroutine subroutine calc_NextUpdate ( self ) !! 次の更新時間ステップを算出 class ( FlowField ) self integer i i = 0 do while ( i * self % INTERVAL + self % OFFSET <= self % STEP ) i = i + 1 end do self % NextUpdate = i * self % INTERVAL + self % OFFSET end subroutine function get_FileNumber ( self ) result ( FileNumber ) !! 現在時刻に対応する流れ場連番ファイル番号を計算 class ( FlowField ) self integer FileNumber FileNumber = self % OFFSET do while ( FileNumber < self % STEP ) FileNumber = FileNumber + self % INTERVAL end do FileNumber = FileNumber + self % INTERVAL !前進評価 call self % clamp_STEP ( FileNumber ) end function subroutine clamp_STEP ( self , STEP ) !! 連番ファイルをループさせる場合を想定し、ファイル番号をclamp class ( FlowField ) self integer , intent ( inout ) :: STEP integer Lamda , Delta if ( STEP >= self % LoopTail ) then Lamda = self % LoopTail - self % LoopHead if ( Lamda > 0 ) then Delta = mod ( STEP - self % LoopHead , Lamda ) STEP = self % LoopHead + Delta else if ( Lamda == 0 ) then STEP = self % LoopTail self % INTERVAL = - 1 print * , '**Checkout SteadyFlow**' end if end if end subroutine function get_defaultFlowFileName ( self ) result ( fname ) !! デフォルトの流れ場ファイル名を返す class ( FlowField ) self character (:), allocatable :: fname fname = self % FullFileName end function end module flow_field_m","tags":"","loc":"sourcefile\\flow_field.f90.html"},{"title":"geometry.f90 – Droplets Simulation","text":"This file depends on sourcefile~~geometry.f90~~EfferentGraph sourcefile~geometry.f90 geometry.f90 sourcefile~vector.f90 vector.f90 sourcefile~geometry.f90->sourcefile~vector.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~geometry.f90~~AfferentGraph sourcefile~geometry.f90 geometry.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~geometry.f90 sourcefile~geometry_test.f90 geometry_test.f90 sourcefile~geometry_test.f90->sourcefile~geometry.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules geometry_m Source Code geometry.f90 Source Code module geometry_m use vector_m implicit none private real , parameter :: delta = 1.e-6 real , parameter :: frac_1_6 = 1. / 6. public volume_tetra , insideJudgment_tetra , insideJudgment_tetra_check contains !>テトラの体積計算。 function volume_tetra ( vertices ) result ( volume ) real , intent ( in ) :: vertices ( 3 , 4 ) real volume real , dimension ( 3 ) :: a , b , c a = vertices (:, 2 ) - vertices (:, 1 ) b = vertices (:, 3 ) - vertices (:, 1 ) c = vertices (:, 4 ) - vertices (:, 1 ) volume = frac_1_6 * abs ( dot_product ( cross_product ( a , b ), c )) end function !>任意の点がテトラの内部にあるかどうかを判定する。 !>点でテトラを分割したそれぞれの体積の和が、元々のテトラの体積を上回れば、点はテトラ外部にある。 !>https://matcha-choco010.net/2018/03/14/point-in-tetrahedron/ function insideJudgment_tetra ( vertices , point ) result ( isInside ) real , intent ( in ) :: vertices ( 3 , 4 ), point ( 3 ) real volume , vol_sum logical isInside volume = volume_tetra ( vertices ) vol_sum = partitionedVolume_sum_tetra ( vertices , point ) !点がテトラの内部にあるとき、分割体積和と元々の体積は厳密に一致するはずだが、 !数値誤差のために少し条件を緩和する isInside = ( abs ( 1. - vol_sum / volume ) <= delta ) end function !>点でテトラを分割したそれぞれの体積の和を求める function partitionedVolume_sum_tetra ( vertices , point ) result ( vol_sum ) real , intent ( in ) :: vertices ( 3 , 4 ), point ( 3 ) real vol_sum , mini_vertices ( 3 , 4 ) integer i vol_sum = 0. do i = 1 , 4 mini_vertices = vertices mini_vertices (:, i ) = point vol_sum = vol_sum + volume_tetra ( mini_vertices ) end do end function subroutine insideJudgment_tetra_check ( vertices , point , vol_sum , volume ) !!テトラの内外判定の内部処理確認用サブルーチン real , intent ( in ) :: vertices ( 3 , 4 ), point ( 3 ) real , intent ( out ) :: volume !!テトラ体積 real , intent ( out ) :: vol_sum !!分割体積和 volume = volume_tetra ( vertices ) vol_sum = partitionedVolume_sum_tetra ( vertices , point ) end subroutine end module geometry_m","tags":"","loc":"sourcefile\\geometry.f90.html"},{"title":"kdTree.f90 – Droplets Simulation","text":"This file depends on sourcefile~~kdtree.f90~~EfferentGraph sourcefile~kdtree.f90 kdTree.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~kdtree.f90~~AfferentGraph sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~kdtree.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules kdTree_m Source Code kdTree.f90 Source Code module kdTree_m !!author: Shohei Kishi, Hikaru Konishi, Tatsuya Miyoshi, Yuta Ida !!kd-treeモジュール use sort_m implicit none private type :: node_in_kdTree_t private integer :: parent_ID = 0 , child_ID_1 = 0 , child_ID_2 = 0 , cell_ID = 0 integer depth integer , allocatable :: cellID_array (:) end type type , public :: kdTree private type ( node_in_kdTree_t ), allocatable :: node (:) contains procedure set_relation , saveAsDOT , saveAsTXT , read_kdTree procedure :: search => search_kdtree end type public kdTree_ contains type ( kdTree ) function kdTree_ ( xyz_origin ) use terminalControler_m real , intent ( in ) :: xyz_origin (:,:) !セル重心座標配列(3, num_cell) type ( content_t ), allocatable :: x_origin (:), y_origin (:), z_origin (:) type ( content_t ), allocatable :: array_pre (:), array_sorted (:) integer , allocatable :: leftChildIDArray (:), rightChildIDArray (:) integer centerID , i , num_node integer parentID , child1ID , child2ID integer depth , ID_counter ID_counter = 1 num_node = size ( xyz_origin , dim = 2 ) allocate ( kdTree_ % node ( num_node )) !各軸に対してコンテンツ配列に x_origin = real2content ( xyz_origin ( 1 ,:)) y_origin = real2content ( xyz_origin ( 2 ,:)) z_origin = real2content ( xyz_origin ( 3 ,:)) kdTree_ % node ( 1 )% cellID_array = x_origin (:)% originID kdTree_ % node ( 1 )% depth = 0 !最初は深さゼロ call set_formatTC ( '(\"CREATING kd-tree [ #node : \",i7,\" / \",i7,\" ]\")' ) do i = 1 , num_node call print_progress ([ i , num_node ]) parentID = i depth = kdTree_ % node ( i )% depth !各軸を切り替えながら、コンテンツ配列から要素を抽出 select case ( mod ( depth , 3 )) case ( 0 ) array_pre = x_origin ( kdTree_ % node ( i )% cellID_array ) case ( 1 ) array_pre = y_origin ( kdTree_ % node ( i )% cellID_array ) case ( 2 ) array_pre = z_origin ( kdTree_ % node ( i )% cellID_array ) end select ! array_sorted = heap_sort(array_pre) ! print '(*(i0, x))', array_sorted(:)%originID ! print '(*(g0, x))', array_sorted(:)%value array_sorted = merge_sort ( array_pre ) centerID = int ( size ( array_sorted ) / 2 ) + 1 kdTree_ % node ( i )% cell_ID = array_sorted ( centerID )% originID !ヒープソート結果の中央値 leftChildIDArray = array_sorted (: centerID - 1 )% originID !左側配列のIDだけ取り出す rightChildIDArray = array_sorted ( centerID + 1 :)% originID !右側配列のIDだけ取り出す if ( size ( leftChildIDArray ) >= 1 ) then ID_counter = ID_counter + 1 child1ID = ID_counter kdTree_ % node ( child1ID )% cellID_array = leftChildIDArray call kdTree_ % set_relation ( parentID , child1ID , 'left' ) end if if ( size ( rightChildIDArray ) >= 1 ) then ID_counter = ID_counter + 1 child2ID = ID_counter kdTree_ % node ( child2ID )% cellID_array = rightChildIDArray call kdTree_ % set_relation ( parentID , child2ID , 'right' ) end if end do ! call print_tree(kdTree, xyz_origin) end function subroutine set_relation ( self , parent_ID , child_ID , lr ) class ( kdTree ) self integer , intent ( in ) :: parent_ID , child_ID character ( * ), intent ( in ) :: lr self % node ( child_ID )% parent_ID = parent_ID self % node ( child_ID )% depth = self % node ( parent_ID )% depth + 1 select case ( lr ) case ( 'left' ) self % node ( parent_ID )% child_ID_1 = child_ID case ( 'right' ) self % node ( parent_ID )% child_ID_2 = child_ID case default print '(\"relation ERROR\")' error stop end select end subroutine !>探索サブルーチン subroutine search_kdTree ( self , xyz , droplet_position , nearest_ID ) class ( kdTree ), intent ( in ) :: self real , intent ( in ) :: xyz (:,:) real , intent ( in ) :: droplet_position ( 3 ) integer depth , switch , parentID , nextChildID , i , leftChildID , rightChildID integer , intent ( out ) :: nearest_ID real mindist logical , allocatable :: NotYetCompared (:) integer , allocatable :: cellIDarray (:) parentID = 1 do depth = self % node ( parentID )% depth switch = mod ( depth , 3 ) + 1 if ( droplet_position ( switch ) <= xyz ( switch , self % node ( parentID )% cell_ID )) then nextChildID = self % node ( parentID )% child_ID_1 else nextChildID = self % node ( parentID )% child_ID_2 end if if ( nextChildID == 0 ) then exit else parentID = nextChildID end if end do ! このnearest_IDは最近傍末端ノードのcellID nearest_ID = self % node ( parentID )% cell_ID ! 比較済みか未比較かを判別するlogical配列を用意 ! 最初はすべて比較していないのでtrueで初期化 allocate ( NotYetCompared ( size ( self % node ))) NotYetCompared (:) = . true . mindist = norm2 ( xyz (:, nearest_ID ) - droplet_position (:)) ! 末端ノードとの比較が終わったのでfalse NotYetCompared ( self % node ( parentID )% cell_ID ) = . false . do ! 注目する親ノードIDを更新 parentID = self % node ( parentID )% parent_ID depth = self % node ( parentID )% depth switch = mod ( depth , 3 ) + 1 leftChildID = self % node ( parentID )% child_ID_1 rightChildID = self % node ( parentID )% child_ID_2 ! 右もしくは左の子が存在しない場合の処理。存在しないときの子ノードIDは0となる ! self%node(0)%cell_IDは存在しないので、除外する。 if ( leftChildID == 0 . or . rightChildID == 0 ) then allocate ( cellIDarray ( 1 )) cellIDarray ( 1 ) = self % node ( parentID )% cell_ID else ! 注目している親の左の子をまだ比較していないならtrue if ( NotYetCompared ( self % node ( leftChildID )% cell_ID )) then ! 注目する親とそれに付随する左の子すべてのcellIDを返す allocate ( cellIDarray ( size ( self % node ( leftChildID )% cellID_array ) + 1 )) cellIDarray ( 1 ) = self % node ( parentID )% cell_ID cellIDarray ( 2 :) = self % node ( leftChildID )% cellID_array else ! 注目する親とそれに付随する右の子すべてのcellIDを返す allocate ( cellIDarray ( size ( self % node ( rightChildID )% cellID_array ) + 1 )) cellIDarray ( 1 ) = self % node ( parentID )% cell_ID cellIDarray ( 2 :) = self % node ( rightChildID )% cellID_array end if end if ! (末端ノード-飛沫座標)<=(末端ノードの親の注目(switch)座標-飛沫の注目(switch)座標) if ( mindist <= abs ( xyz ( switch , self % node ( parentID )% cell_ID ) - droplet_position ( switch ))) then ! 注目している親と左or右のすべての子をfalse NotYetCompared ( cellIDarray ) = . false . else do i = 1 , size ( cellIDarray ) ! (注目している親および左or右のすべての子-飛沫座標)を比較 if ( norm2 ( xyz (:, cellIDarray ( i )) - droplet_position (:)) <= mindist ) then mindist = norm2 ( xyz (:, cellIDarray ( i )) - droplet_position (:)) nearest_ID = cellIDarray ( i ) end if NotYetCompared ( cellIDarray ( i )) = . false . end do end if deallocate ( cellIDarray ) if ( parentID == 1 ) then exit end if end do deallocate ( NotYetCompared ) end subroutine subroutine saveAsDOT ( self , xyz , fname ) class ( kdTree ), intent ( in ) :: self real , intent ( in ) :: xyz (:,:) character ( * ), intent ( in ) :: fname integer n_unit integer i character ( 1 ), parameter :: dq = '\"' open ( newunit = n_unit , file = fname ) write ( n_unit , '(\"graph {\")' ) write ( n_unit , '(4x, \"node [\")' ) write ( n_unit , '(2(4x), \"shape = record,\")' ) write ( n_unit , '(4x, \"];\")' ) write ( n_unit , '()' ) ! node define do i = 1 , size ( self % node ) write ( n_unit , '(4x, i0, \"[label = \", A, \"{\", i0, \"| cell ID : \", i0, \"|\", 3(f10.5), \"}\", A, \"];\")' ) & i , dq , i , self % node ( i )% cell_ID , xyz (:, self % node ( i )% cell_ID ), dq end do write ( n_unit , '()' ) ! edge define do i = 1 , size ( self % node ) if ( self % node ( i )% child_ID_1 /= 0 ) then write ( n_unit , '(4x, i0, \" -- \", i0, \";\")' ) i , self % node ( i )% child_ID_1 end if if ( self % node ( i )% child_ID_2 /= 0 ) then write ( n_unit , '(4x, i0, \" -- \", i0, \";\")' ) i , self % node ( i )% child_ID_2 end if end do write ( n_unit , '(\"}\")' ) end subroutine subroutine saveAsTXT ( self , fname ) class ( kdTree ), intent ( in ) :: self character ( * ), intent ( in ) :: fname character ( size ( self % node )) fmt integer i , n_unit , iimx iimx = size ( self % node ) open ( newunit = n_unit , file = fname ) write ( n_unit , '(I0)' ) iimx do i = 1 , iimx write ( n_unit , '(7(1x,I0))' ) i , self % node ( i )% cell_ID , self % node ( i )% parent_ID , & self % node ( i )% child_ID_1 , self % node ( i )% child_ID_2 , self % node ( i )% depth , & size ( self % node ( i )% cellID_array ) end do write ( n_unit , '()' ) do i = 1 , size ( self % node ) write ( fmt , '(\"(\"I0\"(1x,I0))\")' ) size ( self % node ( i )% cellID_array ) write ( n_unit , fmt ) self % node ( i )% cellID_array end do close ( n_unit ) end subroutine subroutine read_kdTree ( self , fname ) class ( kdTree ), intent ( inout ) :: self character ( * ), intent ( in ) :: fname integer i , n_unit , iimx integer , allocatable :: nodeID (:), cellID_arraySize (:) open ( newunit = n_unit , file = fname ) read ( n_unit , * ) iimx allocate ( self % node ( iimx )) allocate ( nodeID ( iimx )) allocate ( cellID_arraySize ( iimx )) do i = 1 , iimx read ( n_unit , * ) nodeID ( i ), self % node ( i )% cell_ID , self % node ( i )% parent_ID , & self % node ( i )% child_ID_1 , self % node ( i )% child_ID_2 , self % node ( i )% depth , & cellID_arraySize ( i ) end do read ( n_unit , '()' ) do i = 1 , iimx allocate ( self % node ( i )% cellID_array ( cellID_arraySize ( i ))) read ( n_unit , * ) self % node ( i )% cellID_array end do close ( n_unit ) ! do i = 1, iimx !     print'(6(1x,I0))', nodeID(i), self%node(i)%cell_ID, self%node(i)%parent_ID, & !     self%node(i)%child_ID_1, self%node(i)%child_ID_2, self%node(i)%depth ! end do ! do i = 1, iimx !     print *, self%node(i)%cellID_array ! end do end subroutine end module","tags":"","loc":"sourcefile\\kdtree.f90.html"},{"title":"path_operator.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~path_operator.f90~~AfferentGraph sourcefile~path_operator.f90 path_operator.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~path_operator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~path_operator.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~path_operator.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules path_operator_m Source Code path_operator.f90 Source Code module path_operator_m implicit none character ( 7 ), parameter , private :: OS = 'Linux' contains subroutine make_directory ( path ) character ( * ), intent ( in ) :: path character (:), allocatable :: directory select case ( trim ( OS )) case ( 'Linux' ) !for_Linux directory = replace_str ( path , from = '\\', to=' / ' ) call system(' mkdir - p - v '//directory) case (' Windows ')  !for_Windows directory =  replace_str(path, from=' / ', to=' \\ ' ) call system(' md '//directory) case default print*, ' OS ERROR : ', OS error stop end select end subroutine make_directory subroutine get_DirFromPath(path, directory, filename) character(*), intent(in) :: path character(:), intent(out), allocatable :: directory character(:), intent(out), allocatable , optional :: filename character(1) delimiter integer i if(index(path, ' / ') > 0) then delimiter = ' / ' else if(index(path, ' \\ ') > 0) then delimiter = ' \\ ' else print*, ' Delimiter was not found . ' if(present(filename)) filename = path directory = '' return end if i = index(path, delimiter, back=.true.) if(present(filename)) filename = trim(path(i+1:)) directory = path(:i) print*, ' Path = ', trim(path) print*, ' Directory = ', directory if(present(filename)) print*, ' Filename = ' , filename end subroutine function replace_str ( str , from , to ) character ( * ), intent ( in ) :: str character ( 1 ), intent ( in ) :: from , to character ( len_trim ( str )) :: replace_str integer :: i , l replace_str = str l = len_trim ( str ) do i = 1 , l if ( str ( i : i ) == from ) replace_str ( i : i ) = to end do end function end module path_operator_m","tags":"","loc":"sourcefile\\path_operator.f90.html"},{"title":"plot3d_operator.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~plot3d_operator.f90~~AfferentGraph sourcefile~plot3d_operator.f90 plot3d_operator.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~plot3d_operator.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules plot3d_operator Source Code plot3d_operator.f90 Source Code !>CUBE出力ファイル形式：Plot3Dを取り扱うためのモジュール module plot3d_operator implicit none private !>エリア構造体 type area_t real , dimension ( 3 ) :: min , max !最小座標と最大座標 end type !>cube（Plot3D形式における立方体）構造体 type cube_inP3D real , allocatable :: nodes (:,:,:,:) !!節点座標配列（i,j,k, xyz） real , allocatable :: f (:,:,:,:) !!保存量配列（i,j,k, f） type ( area_t ) area contains procedure , public :: isIncluded procedure areaOfCube , nearest_nodeID !, nearer_nodeID end type !>節点情報構造体 type , public :: plot3dNodeInfo integer cubeID , nodeID ( 3 ) !節点が属するcubeID、そのcube内の節点ID（i,j,kそれぞれのIDを指定するので要素数3） end type !>Plot3Dメッシュクラス type , public :: Plot3dMesh private type ( cube_inP3D ), allocatable :: cubes (:) !!cube配列 contains procedure areaOfMesh procedure , public :: read_plot3d_function , get_numCube , get_velocity , get_cubeShape procedure , public :: get_cubeID_contains , nearestNodeInfo end type public :: read_plot3d_multigrid !Plot3Dメッシュクラスの事実上コンストラクタ contains !>メッシュファイル（.g）を読み込んでメッシュクラスを返す関数 function read_plot3d_multigrid ( fName ) result ( mesh ) character ( * ), intent ( in ) :: fName type ( Plot3dMesh ) mesh integer n_unit , i , j , k , i_cube , num_cube , xyz integer , allocatable :: ni (:), nj (:), nk (:) print * , 'READ_multigrid:' , fName open ( newunit = n_unit , form = 'unformatted' , file = fName , status = 'old' , action = 'read' ) read ( n_unit ) num_cube ; print * , 'num_cube=' , num_cube allocate ( mesh % cubes ( num_cube )) allocate ( ni ( num_cube ), nj ( num_cube ), nk ( num_cube )) read ( n_unit ) ( ni ( i_cube ), nj ( i_cube ), nk ( i_cube ), i_cube = 1 , num_cube ) print * , 'ni=' , minval ( ni (:)), maxval ( ni (:)) print * , 'nj=' , minval ( nj (:)), maxval ( ni (:)) print * , 'nk=' , minval ( nk (:)), maxval ( ni (:)) do i_cube = 1 , num_cube allocate ( mesh % cubes ( i_cube )% nodes ( ni ( i_cube ), nj ( i_cube ), nk ( i_cube ), 3 )) end do do i_cube = 1 , num_cube read ( n_unit ) (((( mesh % cubes ( i_cube )% nodes ( i , j , k , xyz ), & i = 1 , ni ( i_cube ) ), j = 1 , nj ( i_cube ) ), k = 1 , nk ( i_cube ) ), xyz = 1 , 3 ) ! (((iblank(i,j,k,i_cube), i = 1, ni(i_cube) ), j = 1, nj(i_cube) ), k = 1, nk(i_cube) ) mesh % cubes ( i_cube )% area = mesh % cubes ( i_cube )% areaOfCube () end do close ( n_unit ) block type ( area_t ) area area = mesh % areaOfMesh () print * , 'min_cdn =' , area % min print * , 'max_cdn =' , area % max end block end function !>メッシュのエリアを構造体で返す関数 type ( area_t ) function areaOfMesh ( self ) class ( Plot3dMesh ), intent ( in ) :: self integer i_cube , num_cube num_cube = size ( self % cubes ) areaOfMesh % min (:) = 1.e9 areaOfMesh % max (:) = - 1.e9 do i_cube = 1 , num_cube areaOfMesh % min ( 1 ) = min ( areaOfMesh % min ( 1 ), self % cubes ( i_cube )% area % min ( 1 )) areaOfMesh % min ( 2 ) = min ( areaOfMesh % min ( 2 ), self % cubes ( i_cube )% area % min ( 2 )) areaOfMesh % min ( 3 ) = min ( areaOfMesh % min ( 3 ), self % cubes ( i_cube )% area % min ( 3 )) areaOfMesh % max ( 1 ) = max ( areaOfMesh % max ( 1 ), self % cubes ( i_cube )% area % max ( 1 )) areaOfMesh % max ( 2 ) = max ( areaOfMesh % max ( 2 ), self % cubes ( i_cube )% area % max ( 2 )) areaOfMesh % max ( 3 ) = max ( areaOfMesh % max ( 3 ), self % cubes ( i_cube )% area % max ( 3 )) end do end function !>cubeのエリアを構造体で返す関数 type ( area_t ) function areaOfCube ( self ) class ( cube_inP3D ), intent ( in ) :: self areaOfCube % min ( 1 ) = minval ( self % nodes (:,:,:, 1 )) areaOfCube % min ( 2 ) = minval ( self % nodes (:,:,:, 2 )) areaOfCube % min ( 3 ) = minval ( self % nodes (:,:,:, 3 )) areaOfCube % max ( 1 ) = maxval ( self % nodes (:,:,:, 1 )) areaOfCube % max ( 2 ) = maxval ( self % nodes (:,:,:, 2 )) areaOfCube % max ( 3 ) = maxval ( self % nodes (:,:,:, 3 )) end function !>cubeのエリア内に任意座標（引数）が含まれているかを返す関数 logical function isIncluded ( self , cdn ) class ( cube_inP3D ), intent ( in ) :: self real , intent ( in ) :: cdn ( 3 ) isIncluded = . false . if (( cdn ( 1 ) >= self % area % min ( 1 )). and .( cdn ( 2 ) >= self % area % min ( 2 )). and .( cdn ( 3 ) >= self % area % min ( 3 ))) then if (( cdn ( 1 ) <= self % area % max ( 1 )). and .( cdn ( 2 ) <= self % area % max ( 2 )). and .( cdn ( 3 ) <= self % area % max ( 3 ))) then isIncluded = . true . end if end if end function !>任意座標（引数）を含むcubeをメッシュの中から探してそのIDを返す関数 integer function get_cubeID_contains ( self , cdn ) class ( Plot3dMesh ), intent ( in ) :: self real , intent ( in ) :: cdn ( 3 ) integer i_cube , num_cube get_cubeID_contains = 0 num_cube = self % get_numCube () do i_cube = 1 , num_cube if ( self % cubes ( i_cube )% isIncluded ( cdn )) then get_cubeID_contains = i_cube return end if end do print * , 'ERROR : The Point is Out of Area.' , cdn error stop end function !>任意座標（引数）に最近傍な節点を探してそのIDを返す関数 function nearest_nodeID ( self , cdn ) result ( nodeID ) class ( cube_inP3D ), intent ( in ) :: self real , intent ( in ) :: cdn ( 3 ) integer nodeID ( 3 ) integer i , j , k , cubeShape ( 4 ) real relation ( 3 ) real , allocatable :: distance (:,:,:) cubeShape = shape ( self % nodes ) allocate ( distance ( cubeShape ( 1 ), cubeShape ( 2 ), cubeShape ( 3 )), source = 1.e9 ) !$OMP parallel private(relation) !$OMP do collapse(3) do k = 1 , cubeShape ( 3 ) do j = 1 , cubeShape ( 2 ) do i = 1 , cubeShape ( 1 ) relation (:) = cdn (:) - self % nodes ( i , j , k , :) distance ( i , j , k ) = norm2 ( relation (:)) end do end do end do !$OMP end do !$OMP end parallel nodeID = minloc ( distance ) end function ! function nearer_nodeID(self, cdn, inodeID) result(rnodeID) !     class(cube_inP3D), intent(in) :: self !     real, intent(in) :: cdn(3) !     integer, intent(in) :: inodeID(3) !     integer nodeID(3), rnodeID(3), i, maxID !     real distance_min, relation(3) !     integer,parameter :: diff(3,6) & !                         = reshape([1,0,0, -1,0,0, 0,1,0, 0,-1,0, 0,0,1, 0,0,-1], shape(diff)) !     logical update !     type(cube_inP3D) cube_ !     type(node_inCUBE) node_ !     node_ = self%nodes(inodeID(1), inodeID(2), inodeID(3)) !     relation(1) = cdn(1) - node_%x !     relation(2) = cdn(2) - node_%y !     relation(3) = cdn(3) - node_%z !     distance_min = norm2(relation(:)) !     rnodeID = inodeID !     update = .true. !     maxID = size(cube_%nodes(:,:,:), dim=1) !     do while(update) !         update = .false. !         check : do i = 1, 6 !             nodeID(:) = rnodeID(:) + diff(:,i) !             if((minval(nodeID) < 1).or.(maxval(nodeID) > maxID)) cycle check !             node_ = cube_%nodes(nodeID(1), nodeID(2), nodeID(3)) !             relation(1) = cdn(1) - node_%x !             relation(2) = cdn(2) - node_%y !             relation(3) = cdn(3) - node_%z !             if(norm2(relation(:)) < distance_min) then !                 distance_min = norm2(relation(:)) !                 rnodeID = nodeID !                 update = .true. !             end if !         end do check !     end do ! end function !>任意座標（引数）に最近傍な節点を探し、その情報（cubeID,nodeID）を返す関数 type ( plot3dNodeInfo ) function nearestNodeInfo ( self , cdn ) class ( Plot3dMesh ), intent ( in ) :: self real , intent ( in ) :: cdn ( 3 ) integer cubeID !, nodeID(3) cubeID = self % get_cubeID_contains ( cdn ) nearestNodeInfo % cubeID = cubeID nearestNodeInfo % nodeID (:) = self % cubes ( cubeID )% nearest_nodeID ( cdn ) ! nodeID = self%cubes(cubeID)%nearest_nodeID(cdn, 4) ! nearestNodeInfo%nodeID(:) = self%cubes(cubeID)%nearer_nodeID(cdn, nodeID) end function ! subroutine write_plot3d_multigrid(mesh_in, fName) !     type(cube_inP3D), intent(in) :: mesh_in(:) !     character(*), intent(in) :: fName !     integer n_unit, i,j,k, i_cube, num_cube !     integer, allocatable :: ni(:), nj(:), nk(:) !     num_cube = size(mesh_in) !     allocate(ni(num_cube), nj(num_cube), nk(num_cube)) !     do i_cube = 1, num_cube !         ni(i_cube) = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !         nj(i_cube) = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !         nk(i_cube) = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !     end do !     open(newunit=n_unit , form='unformatted', file=fName, status='replace') !         write(n_unit) num_cube !         write(n_unit) (ni(i_cube), nj(i_cube), nk(i_cube), i_cube=1,num_cube) !         do i_cube = 1, num_cube !             write(n_unit) & !                 ((( mesh_in(i_cube)%nodes(i,j,k)%x, & !                     i = 1, ni(i_cube) ), j = 1, nj(i_cube) ), k = 1, nk(i_cube) ), & !                 ((( mesh_in(i_cube)%nodes(i,j,k)%y, & !                     i = 1, ni(i_cube) ), j = 1, nj(i_cube) ), k = 1, nk(i_cube) ), & !                 ((( mesh_in(i_cube)%nodes(i,j,k)%z, & !                     i = 1, ni(i_cube) ), j = 1, nj(i_cube) ), k = 1, nk(i_cube) ) !                 ! (((iblank(i,j,k,i_cube), i = 1, ni(i_cube) ), j = 1, nj(i_cube) ), k = 1, nk(i_cube) ) !         end do !     close(n_unit) ! end subroutine ! subroutine write_plot3d_f(mesh_in, fName) !     type(cube_inP3D), intent(in) :: mesh_in(:) !     character(*), intent(in) :: fName !     integer n_unit, i,j,k,l, i_cube, num_cube !     integer, allocatable :: ni(:), nj(:), nk(:), nf(:) !     num_cube = size(mesh_in) !     allocate(ni(num_cube), nj(num_cube), nk(num_cube), nf(num_cube)) !     do i_cube = 1, num_cube !         ni(i_cube) = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !         nj(i_cube) = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !         nk(i_cube) = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !     end do !     do i_cube = 1, num_cube !         nf(i_cube) = size(mesh_in(i_cube)%nodes(1,1,1)%f(:), dim=1) !     end do !     open(newunit=n_unit , form='unformatted', file=fName, status='replace') !         write(n_unit) num_cube !         write(n_unit) (ni(i_cube), nj(i_cube), nk(i_cube), nf(i_cube), i_cube=1,num_cube) !         do i_cube = 1, num_cube !             write(n_unit) & !             (((( mesh_in(i_cube)%nodes(i,j,k)%f(l), & !             i = 1, ni(i_cube) ), j = 1, nj(i_cube) ), k = 1, nk(i_cube) ), & !             l = 1, nf(i_cube)) !         end do !     close(n_unit) ! end subroutine ! subroutine write_plot3d_asVTK(mesh_in, fName, n_cell)   !ひとつのcubeをひとつの節点とみなしてVTK出力 !     type(cube_inP3D), intent(in) :: mesh_in(:) !     character(*), intent(in) :: fName !     integer, intent(in) :: n_cell    !CUBE一辺当たりのセル数 !     integer n_unit, i_cube, num_cube, i,j,k, num_func, i_node, num_nodes, num_cells, i_cell !     integer i_max, j_max, k_max, delta_i, delta_j, delta_k, i1,i2,i3,i4, i_n !     real :: cdn(3), velocity(3) !     num_cube = size(mesh_in) !     num_nodes = num_cube*((n_cell + 1)**3) !     num_cells = num_cube*(n_cell**3) !     print*, 'VTK informations:' !     print*, 'nodes =', num_nodes !     print*, 'cells=', num_cells !     open(newunit=n_unit , form='formatted', file=fName, status='replace') !         write(n_unit, '(A)') '# vtk DataFile Version 2.0' !         write(n_unit, '(A)') 'Header' !         write(n_unit, '(A)') 'ASCII' !         write(n_unit, '(A)') 'DATASET UNSTRUCTURED_GRID' !         write(n_unit, *) 'POINTS', num_nodes, 'float' !         do i_cube = 1, num_cube !             i_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !             j_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !             k_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !             delta_i = (i_max - 1) / n_cell !             delta_j = (j_max - 1) / n_cell !             delta_k = (k_max - 1) / n_cell !             do k = 1, k_max, delta_k !                 do j = 1, j_max, delta_j !                     do i = 1, i_max, delta_i !                         cdn(1) = mesh_in(i_cube)%nodes(i,j,k)%x !                         cdn(2) = mesh_in(i_cube)%nodes(i,j,k)%y !                         cdn(3) = mesh_in(i_cube)%nodes(i,j,k)%z !                         write(n_unit, '(3(E15.8e2,2X))') cdn(:) !                     end do !                 end do !             end do !         end do !         write(n_unit, *) 'CELLS ', num_cells, num_cells*9 !         do i_cube = 1, num_cube !             i_node =  (i_cube - 1)*((n_cell + 1)**3)    !CUBEの基準点ID !             i_n = 0 !             do i_cell = 1, n_cell**3 !                 i1 = i_node + i_n    !セルの基準点ID !                 i2 = i1 + n_cell + 1 !                 i3 = i1 + (n_cell + 1)**2 !                 i4 = i3 + n_cell + 1 !                 write(n_unit, *)  8, i1, i1+1, i2, i2+1, i3, i3+1, i4, i4+1 !                 i_n = i_n + 1 !                 if(mod(i_n +1, n_cell +1) == 0) i_n = i_n + 1 !                 if(mod(i_n +1 +n_cell, (n_cell +1)**2)==0) i_n = i_n + (n_cell + 1) !             end do !         end do !         write(n_unit, *) 'CELL_TYPES', num_cells !         do i_cell = 1, num_cells !             write(n_unit, *) 11 !11:直方体 !         end do !         num_func = size(mesh_in(1)%nodes(1,1,1)%f(:)) !         write(n_unit, *) 'POINT_DATA', num_nodes !         write(n_unit, '(A)') 'SCALARS density float' !         write(n_unit, '(A)') 'LOOKUP_TABLE default' !         do i_cube = 1, num_cube !             i_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !             j_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !             k_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !             delta_i = (i_max - 1) / n_cell !             delta_j = (j_max - 1) / n_cell !             delta_k = (k_max - 1) / n_cell !             do k = 1, k_max, delta_k !                 do j = 1, j_max, delta_j !                     do i = 1, i_max, delta_i !                         write(n_unit, '(E15.8e2)') mesh_in(i_cube)%nodes(i,j,k)%f(1) !                     end do !                 end do !             end do !         end do !         write(n_unit, '(A)') 'VECTORS velocity float' !         do i_cube = 1, num_cube !             i_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !             j_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !             k_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !             delta_i = (i_max - 1) / n_cell !             delta_j = (j_max - 1) / n_cell !             delta_k = (k_max - 1) / n_cell !             do k = 1, k_max, delta_k !                 do j = 1, j_max, delta_j !                     do i = 1, i_max, delta_i !                         velocity(:) = mesh_in(i_cube)%nodes(i,j,k)%f(2:4) / mesh_in(i_cube)%nodes(i,j,k)%f(1) !                         write(n_unit, '(3(E15.8e2,2X))') velocity(:) !                     end do !                 end do !             end do !         end do !     close(n_unit) ! end subroutine !>メッシュクラスメソッド !>保存量ファイル（.f）を読み込み、メッシュクラスに格納する subroutine read_plot3d_function ( self , fName ) class ( Plot3dMesh ) self character ( * ), intent ( in ) :: fName integer num_cube integer n_unit , i , j , k , l , i_cube real , allocatable :: min_f (:), max_f (:) integer , allocatable :: ni (:), nj (:), nk (:), nf (:) print * , 'READ_function:' , fName open ( newunit = n_unit , form = 'unformatted' , file = fName , status = 'old' , action = 'read' ) read ( n_unit ) num_cube ; print * , 'num_cube=' , num_cube if ( num_cube /= size ( self % cubes )) then print * , 'ERROR:the number of cube is not macth' , num_cube , size ( self % cubes ) error stop end if allocate ( ni ( num_cube ), nj ( num_cube ), nk ( num_cube ), nf ( num_cube )) read ( n_unit ) ( ni ( i_cube ), nj ( i_cube ), nk ( i_cube ), nf ( i_cube ), i_cube = 1 , num_cube ) print * , 'nf=' , minval ( nf (:)), maxval ( nf (:)) if (. not . allocated ( self % cubes ( 1 )% f )) then do i_cube = 1 , num_cube allocate ( self % cubes ( i_cube )% f ( ni ( i_cube ), nj ( i_cube ), nk ( i_cube ), nf ( i_cube ))) end do end if do i_cube = 1 , num_cube read ( n_unit ) & (((( self % cubes ( i_cube )% f ( i , j , k , l ), & i = 1 , ni ( i_cube )), j = 1 , nj ( i_cube )), k = 1 , nk ( i_cube )), l = 1 , nf ( i_cube )) end do allocate ( min_f ( maxval ( nf (:))), source = 1.e9 ) allocate ( max_f ( maxval ( nf (:))), source =- 1.e9 ) do i_cube = 1 , num_cube do l = 1 , nf ( i_cube ) min_f ( l ) = min ( min_f ( l ), minval ( self % cubes ( i_cube )% f (:,:,:, l ))) max_f ( l ) = max ( max_f ( l ), maxval ( self % cubes ( i_cube )% f (:,:,:, l ))) end do end do print * , min_f print * , max_f close ( n_unit ) end subroutine ! function extract_cube(mesh_in, min_cdn, max_cdn) result(mesh_extracted) !     type(cube_inP3D), intent(in) :: mesh_in(:) !     type(cube_inP3D), allocatable :: mesh_extracted(:) !     real, intent(in) :: min_cdn(3), max_cdn(3) !     real :: center(3) !     integer i_cube, l, cube_cnt, num_cube !     logical extract !     integer :: original_ID(size(mesh_in)) !     num_cube = size(mesh_in) !     cube_cnt = 0 !     do i_cube = 1, num_cube !         extract = .false. !         center(:) = get_center_position(mesh_in(i_cube)%nodes) !         do l = 1, 3 !             if(center(l) < min_cdn(l)) extract = .true. !             if(center(l) > max_cdn(l)) extract = .true. !         end do !         if(extract) cycle !         cube_cnt = cube_cnt +1 !         original_ID(cube_cnt) = i_cube !     end do !     print*, 'cube_count=', cube_cnt !     allocate(mesh_extracted(cube_cnt)) !     do i_cube = 1, cube_cnt !         mesh_extracted(i_cube) = mesh_in(original_ID(i_cube)) !     end do ! end function ! function change_resolution(mesh_in, resolution) result(mesh_changed) !     type(cube_inP3D), intent(in) :: mesh_in(:) !     type(cube_inP3D) :: mesh_changed(size(mesh_in)) !     integer, intent(in) :: resolution   !一辺当たりのセル数 !     integer i_cube, i,j,k, num_cube, i_max, j_max, k_max, delta_i, delta_j, delta_k !     integer ii,jj,kk !     num_cube = size(mesh_in) !     do i_cube = 1, num_cube !         allocate(mesh_changed(i_cube)%nodes(resolution+1, resolution+1, resolution+1)) !         ! do k = 1, resolution+1 !         !     do j = 1, resolution+1 !         !         do i = 1, resolution+1 !         !             nf = size(mesh_in(i_cube)%nodes(i,j,k)%f(:)) !         !             allocate(mesh_changed(i_cube)%nodes(i,j,k)%f(nf)) !         !         end do !         !     end do !         ! end do !     end do !     do i_cube = 1, num_cube !         i_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !         j_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !         k_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !         delta_i = (i_max - 1) / resolution !         delta_j = (j_max - 1) / resolution !         delta_k = (k_max - 1) / resolution !         kk = 1 !         do k = 1, k_max, delta_k !             jj = 1 !             do j = 1, j_max, delta_j !                 ii = 1 !                 do i = 1, i_max, delta_i !                     mesh_changed(i_cube)%nodes(ii,jj,kk) = mesh_in(i_cube)%nodes(i,j,k) !                     ii = ii + 1 !                 end do !                 jj = jj + 1 !             end do !             kk = kk + 1 !         end do !     end do ! end function ! function extract_function(mesh_in, nf) result(mesh_extracted) !     type(cube_inP3D), intent(in) :: mesh_in(:) !     type(cube_inP3D) :: mesh_extracted(size(mesh_in)) !     integer, intent(in) :: nf   !関数の数 !     integer i_cube, i,j,k, num_cube, i_max, j_max, k_max !     num_cube = size(mesh_in) !     do i_cube = 1, num_cube !         i_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=1) !         j_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=2) !         k_max = size(mesh_in(i_cube)%nodes(:,:,:), dim=3) !         allocate(mesh_extracted(i_cube)%nodes(i_max, j_max, k_max)) !         do k = 1, k_max !             do j = 1, j_max !                 do i = 1, i_max !                     allocate(mesh_extracted(i_cube)%nodes(i,j,k)%f(nf)) !                     mesh_extracted(i_cube)%nodes(i,j,k)%f(:) = mesh_in(i_cube)%nodes(i,j,k)%f(:nf) !                 end do !             end do !         end do !     end do ! end function ! function get_center_position(nodes) result(center) !     type(node_inCUBE) :: nodes(:,:,:) !     real :: center(3) !     integer ni,nj,nk,num_nodes !     ni = size(nodes(:,:,:), dim=1) !     nj = size(nodes(:,:,:), dim=2) !     nk = size(nodes(:,:,:), dim=3) !     num_nodes = ni * nj * nk !     center(1) = sum(nodes(:,:,:)%x) !     center(2) = sum(nodes(:,:,:)%y) !     center(3) = sum(nodes(:,:,:)%z) !     center(:) = center(:) / num_nodes ! end function ! real function mean_value(nodes, n_func) !     type(node_inCUBE) :: nodes(:,:,:) !     integer, intent(in) :: n_func !     integer ni,nj,nk,num_nodes, i,j,k !     ni = size(nodes(:,:,:), dim=1) !     nj = size(nodes(:,:,:), dim=2) !     nk = size(nodes(:,:,:), dim=3) !     num_nodes = ni * nj * nk !     mean_value = 0.0 !     do k = 1, nk !         do j = 1, nj !             do i = 1, ni !                 mean_value = mean_value+ nodes(i,j,k)%f(n_func) !             end do !         end do !     end do !     mean_value = mean_value / num_nodes ! end function !>メッシュを構成するcube数を返す関数 integer function get_numCube ( self ) class ( Plot3dMesh ), intent ( in ) :: self get_numCube = size ( self % cubes ) end function !>cubeの形状（i,j,k節点数）を返す関数 function get_cubeShape ( self ) result ( cubeShape ) class ( Plot3dMesh ), intent ( in ) :: self integer shapeArray ( 4 ), cubeShape ( 3 ) shapeArray = shape ( self % cubes ( 1 )% nodes ) cubeShape = shapeArray ( 1 : 3 ) end function !>任意節点（引数）における流速を返す関数 function get_velocity ( self , node ) result ( velocity ) class ( Plot3dMesh ) self type ( plot3dNodeInfo ), intent ( in ) :: node !!節点 type ( cube_inP3D ) cube real velocity ( 3 ) cube = self % cubes ( node % cubeID ) !質量流束（第2〜第4成分）を密度（第1成分）で割ることで流速を取得する velocity (:) = cube % f ( node % nodeID ( 1 ), node % nodeID ( 2 ), node % nodeID ( 3 ), 2 : 4 ) & / cube % f ( node % nodeID ( 1 ), node % nodeID ( 2 ), node % nodeID ( 3 ), 1 ) end function end module plot3d_operator","tags":"","loc":"sourcefile\\plot3d_operator.f90.html"},{"title":"SCFfile_reader.f90 – Droplets Simulation","text":"This file depends on sourcefile~~scffile_reader.f90~~EfferentGraph sourcefile~scffile_reader.f90 SCFfile_reader.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~scffile_reader.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~scffile_reader.f90~~AfferentGraph sourcefile~scffile_reader.f90 SCFfile_reader.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~scffile_reader.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules SCF_file_reader_m Source Code SCFfile_reader.f90 Source Code module SCF_file_reader_m !================================================================================================================ !   version : 1.0.1     (2022/11/22) !   author : Miyoshi !summary : !   SCFlow　出力ファイルを読み込み，データを取り出す !   このプログラム単体で独立して扱えるようにする !================================================================================================================ implicit none real ( 8 ), parameter :: MissingValueSize = 1.0d20 !SCFlowでの欠測値の大きさ character ( 10 ), parameter :: EC_Scalar_HeadName = 'EC_Scalar:' character ( 10 ), parameter :: EC_Vector_HeadName = 'EC_Vector:' character ( 10 ), parameter :: FC_Scalar_HeadName = 'FC_Scalar:' character ( 10 ), parameter :: FC_Vector_HeadName = 'FC_Vector:' character ( 32 ), parameter :: OverlapEndLabel = 'OverlapEnd' integer , parameter :: EC_Scalar_DataSize = 50 !FPH内のセル重心の持つスカラーデータの個数上限（決め打ち） integer , parameter :: EC_Vector_DataSize = 50 !FPH内のセル重心の持つベクトルデータの個数上限（決め打ち） integer , parameter :: FC_Scalar_DataSize = 50 !FPH内の面重心の持つスカラーデータの個数上限（決め打ち） integer , parameter :: FC_Vector_DataSize = 50 !FPH内の面重心の持つベクトルデータの個数上限（決め打ち） type :: EC_Scalar_t character (:), allocatable :: name character (:), allocatable :: abbreviated_name integer ( 4 ) ndata real ( 4 ), allocatable :: data (:) end type type :: EC_Vector_t character (:), allocatable :: name character (:), allocatable :: abbreviated_name integer ( 4 ) ndata real ( 4 ), allocatable :: x (:), y (:), z (:) end type type :: FC_Scalar_t character (:), allocatable :: name character (:), allocatable :: abbreviated_name integer ( 4 ) ndata integer ( 4 ), allocatable :: face_num (:) , face_flag (:) real ( 4 ), allocatable :: data (:) end type type :: FC_Vector_t character (:), allocatable :: name character (:), allocatable :: abbreviated_name integer ( 4 ) ndata integer ( 4 ), allocatable :: face_num (:), face_flag (:) real ( 4 ), allocatable :: x (:), y (:), z (:) end type type :: data_name_list_t character (:), allocatable :: name character (:), allocatable :: abbreviated_name end type type :: content_t integer , allocatable :: vertexIDs (:) integer , allocatable :: faceIDs (:) integer , allocatable :: adjacentCellIDs (:) integer , allocatable :: boundFaceID (:) real ( 4 ) center ( 3 ) real ( 4 ) coordinate ( 3 ) end type type :: scf_grid_t real ( 4 ), private :: TIME = 0 !!時間 integer ( 4 ), private :: NCYC = 0 !!サイクル数 integer ( 4 ), private :: NODES = 0 !!節点数 real ( 4 ), allocatable , private :: CAN_X (:), CAN_Y (:), CAN_Z (:) !!節点座標 integer ( 4 ), private :: NFACE = 0 !!要素界面数 integer ( 4 ), private :: NELEM = 0 !!要素数 real ( 4 ), allocatable , private :: CCE_X (:), CCE_Y (:), CCE_Z (:) !!要素中心座標 integer ( 4 ), allocatable , private :: IE1 (:), IE2 (:) !!面の裏表の要素番号 integer ( 4 ), allocatable , private :: NDNUM (:) !!界面を構成する節点数 integer ( 4 ), private :: NDTOT !!全界面を構成する節点数 integer ( 4 ), allocatable , private :: IDNO (:) !!界面を構成する節点番号 type ( content_t ), allocatable , private :: face2vertices (:) type ( content_t ), allocatable , private :: mainCell (:) type ( content_t ), allocatable , private :: cell2faces (:) type ( content_t ), allocatable :: node (:) type ( content_t ), allocatable :: face (:) integer , allocatable , private :: face2cells (:,:) integer , private :: EC_scalar_data_count = 0 integer , private :: EC_vector_data_count = 0 integer , private :: FC_scalar_data_count = 0 integer , private :: FC_vector_data_count = 0 type ( EC_Scalar_t ), allocatable , private :: EC_Scalars (:) type ( EC_Vector_t ), allocatable , private :: EC_Vectors (:) type ( FC_Scalar_t ), allocatable , private :: FC_Scalars (:) type ( FC_Vector_t ), allocatable , private :: FC_Vectors (:) integer , private :: num_boundFace integer , allocatable , private :: boundFaceIDs (:) integer , allocatable , private :: num_face2vertex (:) integer , allocatable , private :: offsets (:) contains procedure , public :: read_SCF_file procedure , public :: get_fph_element_count procedure , public :: get_fph_vertex_count procedure , public :: get_fph_face_count procedure , public :: get_fph_2d_array_of_point_coords procedure , public :: get_fph_2d_array_of_cell_coords procedure , public :: get_face2vertices procedure , public :: get_face2cells procedure , public :: get_cell2faces procedure , public :: get_cell_offsets procedure , public :: get_fph_boundFaceIDs procedure , public :: get_fph_faceCenter procedure , public :: get_fph_boundFaceCenter procedure , public :: output_fph_cell2face procedure , public :: output_fph_boundFace procedure , public :: output_fph_vtk procedure , public :: get_cell2boundFace procedure , public :: get_fph_adjacentCellIDs procedure , public :: output_fph_adjacentCell procedure , public :: search_fph_vector_data end type contains logical function open_binary_sequential_ ( unit , filename ) result ( is_opened ) !! バイナリファイルをシーケンシャル形式で開く. 開けない場合.false. integer , intent ( inout ) :: unit !! 装置番号. character ( * ), intent ( in ) :: filename character ( 256 ) iomessage integer iostatus open ( newunit = unit , file = filename , iostat = iostatus , iomsg = iomessage , & form = 'unformatted' , access = 'sequential' , status = 'old' , convert = 'big_endian' ) if ( iostatus == 0 ) then is_opened = . true . else is_opened = . false . print \"('error:',i0,1x,A)\" , iostatus , trim ( iomessage ) end if end function subroutine read_SCF_file ( this , filename ) implicit none class ( scf_grid_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: filename integer unit !割り付けされている物があれば解放する. call destructor ( this ) if (. not . open_binary_sequential_ ( unit , filename )) then print * , 'cannot open' stop end if call read_FPH_Header_data ( unit , this % NCYC , this % TIME ) call read_FPH_Main_data ( unit , this % CAN_X , this % CAN_Y , this % CAN_Z , this % CCE_X , this % CCE_Y , this % CCE_Z , & this % EC_Scalars , this % EC_Vectors , this % FC_Scalars , this % FC_Vectors , & this % EC_scalar_data_count , this % EC_vector_data_count , & this % FC_scalar_data_count , this % FC_vector_data_count , & this % NODES , this % NFACE , this % NELEM , this % NDTOT , this % IE1 , this % IE2 , this % NDNUM , this % IDNO ) end subroutine subroutine read_FPH_Header_data ( unit , NCYC , TIME ) implicit none integer , intent ( in ) :: unit integer ( 4 ), intent ( inout ) :: NCYC real ( 4 ), intent ( inout ) :: TIME character ( 8 ) header_name integer ( 4 ) version_num , NNAMS , n character ( 32 ) title_text read ( unit ) header_name ! print*, 'header_name: ',header_name read ( unit ) version_num ! print*, 'version_num :',version_num do read ( unit ) title_text ! print*,title_text if ( trim ( title_text ) == 'HeaderDataEnd' ) then exit else if ( trim ( title_text ) == 'Cycle' ) then call get_data_int32_ ( unit , NCYC ) call get_data_float64_ ( unit , TIME ) read ( unit ) cycle else if ( trim ( title_text ) == 'Unused' ) then read ( unit ) read ( unit ) elseif ( trim ( title_text ) == 'Unit:$TEMP' ) then read ( unit ) read ( unit ) read ( unit ) read ( unit ) read ( unit ) NNAMS !NNAMS : 温度とみなす変数の数 do n = 1 , NNAMS read ( unit ) end do read ( unit ) cycle end if read ( unit ) read ( unit ) read ( unit ) end do end subroutine subroutine read_FPH_Main_data ( unit , CAN_X , CAN_Y , CAN_Z , CCE_X , CCE_Y , CCE_Z ,& EC_Scalars , EC_Vectors , FC_Scalars , FC_Vectors ,& EC_Scalar_cnt , EC_Vector_cnt , FC_Scalar_cnt , FC_Vector_cnt ,& NODES , NFACE , NELEM , NDTOT , IE1 , IE2 , NDNUM , IDNO ) implicit none integer , intent ( in ) :: unit real ( 4 ), allocatable , intent ( inout ) :: CAN_X (:), CAN_Y (:), CAN_Z (:), CCE_X (:), CCE_Y (:), CCE_Z (:) type ( EC_Scalar_t ), allocatable , intent ( inout ) :: EC_Scalars (:) type ( EC_Vector_t ), allocatable , intent ( inout ) :: EC_Vectors (:) type ( FC_Scalar_t ), allocatable , intent ( inout ) :: FC_Scalars (:) type ( FC_Vector_t ), allocatable , intent ( inout ) :: FC_Vectors (:) integer , intent ( inout ) :: EC_Scalar_cnt , EC_Vector_cnt , FC_Scalar_cnt , FC_Vector_cnt integer , intent ( inout ) :: NODES , NFACE , NELEM , NDTOT integer , allocatable , intent ( inout ) :: IE1 (:), IE2 (:), NDNUM (:), IDNO (:) integer :: NMAT , NMLEN , NPART , NPLEN , NREGN , NLEN , NN , REV , NSIZE , LENG integer , allocatable :: NFA (:), FLG (:), ID (:), MAT (:), MAT_PART (:) integer i character ( 32 ) main_data_title character ( 32 ) TITLE character , allocatable :: LMAT (:), LPART (:), LRGN (:), LRGN_S (:) character (:), allocatable :: TEXT , STRXML read ( unit ) main_data_title !'OverlapStart_n'<バイト数32> do read ( unit ) TITLE ! print*,TITLE if ( trim ( TITLE ) == 'LS_Nodes' ) then read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_int32_ ( unit , NODES ) !接点数 call get_data_array_float64_ ( unit , CAN_X , NODES ) !接点のX座標 call get_data_array_float64_ ( unit , CAN_Y , NODES ) !接点のY座標 call get_data_array_float64_ ( unit , CAN_Z , NODES ) !接点のZ座標 read ( unit ) !0,0,0 else if ( trim ( TITLE ) == 'LS_Links' ) then read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_int32_ ( unit , NFACE ) !要素界面数 call get_data_array_int32_ ( unit , IE1 , NFACE ) !裏面の要素番号 call get_data_array_int32_ ( unit , IE2 , NFACE ) !表面の要素番号（-1の場合、IE1の相手要素が存在しない） call get_data_array_int32_ ( unit , NDNUM , NFACE ) !面を構成する頂点数 call get_data_int32_ ( unit , NDTOT ) !全界面を構成する接点数 call get_data_array_int32_ ( unit , IDNO , NDTOT ) !界面を構成する接点番号（IE1からIE2へ向かう軸を右ねじ周りに構成） read ( unit ) !0,0,0 else if ( trim ( TITLE ) == 'LS_MaterialOfParts' ) then read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_int32_ ( unit , NMAT ) !物性数 call get_data_int32_ ( unit , NMLEN ) !LMATの文字数 allocate ( MAT ( NMAT )) allocate ( LMAT ( NMAT )) do i = 1 , NMAT read ( unit ) !4,1,1 read ( unit ) MAT ( i ) !物性番号 read ( unit ) !1,1,1 read ( unit ) LMAT ( i ) !物性名 end do call get_data_int32_ ( unit , NPART ) !部品数 call get_data_int32_ ( unit , NPLEN ) !LPARTの文字数 !allocate(LPART(NPART)) allocate ( MAT_PART ( NPART )) do i = 1 , NPART read ( unit ) !1,1,1 read ( unit ) LPART ( i ) !部品名 read ( unit ) !4,1,1 read ( unit ) MAT_PART ( i ) !部品に割り当てられた物性番号 end do read ( unit ) !0,0,0 else if ( trim ( TITLE ) == 'LS_CvolIdOfElements' ) then read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) !要素数 call get_data_array_int32_ ( unit , ID , NELEM ) !要素番号IEの閉空間ID read ( unit ) !0,0,0 else if ( trim ( TITLE ) == 'LS_SurfaceRegions' ) then read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_int32_ ( unit , NREGN ) !領域データ数 call get_data_int32_ ( unit , NLEN ) !LRGNの文字数 allocate ( LRGN_S ( NREGN )) do i = 1 , NREGN read ( unit ) !1,1,1 read ( unit ) LRGN_S ( i ) !面領域名 read ( unit ) !4,1,1 read ( unit ) NN !面領域を構成する面数 call get_data_array_int32_ ( unit , NFA , NN ) !面領域を構成する面番号 call get_data_array_int32_ ( unit , FLG , NN ) !面の裏表を指定するフラグ（1:IE1→IE2,2:IE2→IE1,3:IE1↔IE2） end do read ( unit ) !0,0,0 else if ( trim ( TITLE ) == 'LS_VolumeRegions' ) then read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_int32_ ( unit , NREGN ) !領域データ数 call get_data_int32_ ( unit , NLEN ) !LRGNの文字数 allocate ( LRGN ( NREGN )) do i = 1 , NREGN read ( unit ) !1,1,1 read ( unit ) LRGN ( i ) !領域名 read ( unit ) !4,1,1 read ( unit ) NN !体積領域を構成する閉空間数 call get_data_array_int32_ ( unit , ID , NN ) !体積領域を構成する閉空間ID end do read ( unit ) !0,0,0 else if ( trim ( TITLE ) == 'LS_Parts' ) then read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_int32_ ( unit , NPART ) !部品データ数 call get_data_int32_ ( unit , NLEN ) !LPRTの文字数 allocate ( LPART ( NPART )) do i = 1 , NPART read ( unit ) !1,1,1 read ( unit ) LPART ( i ) !部品名 read ( unit ) !4,4,4 read ( unit ) NN !部品を構成する閉空間数 call get_data_array_int32_ ( unit , ID , NN ) !部品を構成する閉空間ID end do read ( unit ) !0,0,0 else if ( trim ( TITLE ) == 'LS_Assemblies' ) then read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_int32_ ( unit , NLEN ) !STRXMLのバイト数 call get_data_char_ ( unit , NLEN , STRXML ) !部品とアセンブリの関する情報（xml形式） ! print*,STRXML read ( unit ) !0,0,0 else if ( trim ( TITLE ) == 'LS_PartialInformation' ) then read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_int32_ ( unit , REV ) !リビジョン番号1を指定 call get_data_int32_ ( unit , NSIZE ) !TEXTのバイト単位でのサイズ call get_data_char_ ( unit , NSIZE , TEXT ) !部分図化ファイルの位置情報（無視しても良い?） read ( unit ) !0,0,0 else if ( trim ( TITLE ) == 'Element_Center' ) then read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) !フィールド変数のデータ数[=要素数] call get_data_array_float64_ ( unit , CCE_X , NELEM ) !要素中心のX座標 call get_data_array_float64_ ( unit , CCE_Y , NELEM ) !要素中心のY座標 call get_data_array_float64_ ( unit , CCE_Z , NELEM ) !要素中心のZ座標 read ( unit ) !0,0,0 else if ( trim ( TITLE ) == 'LS_SPHFile' ) then read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_int32_ ( unit , LENG ) !TEXTの文字数 call get_data_char_ ( unit , LENG , TEXT ) !SPHファイルの中身のテキスト（いらん?） ! print*,TEXT read ( unit ) !0,0,0 else if ( TITLE ( 1 : 10 ) == 'EC_Scalar:' ) then !EC_Scalar:以下はループ外で処理するので、1行戻ってループを抜ける backspace ( unit ) exit else if ( TITLE ( 1 : 10 ) == 'EC_Vector:' ) then !EC_Scalar:以下はループ外で処理するので、1行戻ってループを抜ける backspace ( unit ) exit else print * , '(error) readFPH_main_data :: UnKnown title data was detected.' , trim ( TITLE ) return end if end do if (. not . allocated ( EC_Scalars )) allocate ( EC_Scalars ( EC_Scalar_DataSize )) if (. not . allocated ( EC_Vectors )) allocate ( EC_Vectors ( EC_Vector_DataSize )) if (. not . allocated ( FC_Scalars )) allocate ( FC_Scalars ( FC_Scalar_DataSize )) if (. not . allocated ( FC_Vectors )) allocate ( FC_Vectors ( FC_Vector_DataSize )) datas_reader : block logical is_end integer EC_s_cnt , EC_v_cnt , FC_s_cnt , FC_v_cnt , n is_end = . false . EC_v_cnt = 0 do while (. not . is_end ) EC_v_cnt = EC_v_cnt + 1 call EC_Vector_reader ( EC_Vectors ( EC_v_cnt ), unit , is_end ) end do EC_Vector_cnt = EC_v_cnt - 1 is_end = . false . EC_s_cnt = 0 do while (. not . is_end ) !is_endが.ture.になるまでdoループが回る。 EC_s_cnt = EC_s_cnt + 1 call EC_Scalar_reader ( EC_Scalars ( EC_s_cnt ), unit , is_end ) end do EC_Scalar_cnt = EC_s_cnt - 1 is_end = . false . FC_v_cnt = 0 do while (. not . is_end ) FC_v_cnt = FC_v_cnt + 1 call FC_Vector_reader ( FC_Vectors ( FC_v_cnt ), unit , is_end ) end do FC_Vector_cnt = FC_v_cnt - 1 is_end = . false . FC_s_cnt = 0 do while (. not . is_end ) FC_s_cnt = FC_s_cnt + 1 call FC_Scalar_reader ( FC_Scalars ( FC_s_cnt ), unit , is_end ) end do FC_Scalar_cnt = FC_s_cnt - 1 do n = EC_s_cnt , size ( EC_Scalars ) EC_Scalars ( n )% name = 'NONE' end do do n = EC_v_cnt , size ( EC_Vectors ) EC_Vectors ( n )% name = 'NONE' end do do n = FC_s_cnt , size ( FC_Scalars ) FC_Scalars ( n )% name = 'NONE' end do do n = FC_v_cnt , size ( FC_Vectors ) FC_Vectors ( n )% name = 'NONE' end do end block datas_reader end subroutine subroutine EC_Scalar_reader ( scalar , unit , is_end ) implicit none type ( EC_Scalar_t ) :: scalar integer ( 4 ), intent ( in ) :: unit logical , intent ( out ) :: is_end character ( 32 ) title is_end = . false . read ( unit ) title ! print*,title select case ( title ( 1 : 10 )) case ( EC_Scalar_HeadName ) scalar % abbreviated_name = title ( 11 : 14 ) read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_char_ ( unit , 32 , scalar % name ) call get_data_int32_ ( unit , scalar % ndata ) call get_data_array_float64_ ( unit , scalar % data , scalar % ndata ) read ( unit ) !0,0,0 case ( EC_Vector_HeadName ) backspace ( unit ) is_end = . true . return case ( FC_Scalar_HeadName ) backspace ( unit ) is_end = . true . return case ( FC_Vector_HeadName ) backspace ( unit ) is_end = . true . return case ( OverlapEndLabel ) is_end = . true . return case default print * , 'something is wrong.' , trim ( title ( 1 : 10 )) end select end subroutine subroutine EC_Vector_reader ( vector , unit , is_end ) implicit none type ( EC_Vector_t ) :: vector integer ( 4 ), intent ( in ) :: unit logical , intent ( out ) :: is_end character ( 32 ) title is_end = . false . read ( unit ) title ! print*,title select case ( title ( 1 : 10 )) case ( EC_Scalar_HeadName ) backspace ( unit ) is_end = . true . return case ( EC_Vector_HeadName ) vector % abbreviated_name = title ( 11 : 14 ) read ( unit ) !4,1,1 read ( unit ) !LNX call ignore_data_ ( unit ) !LVCT 位置ベクトルなら1・そうでないなら0　必要ないと思うので無視 call get_data_char_ ( unit , 32 , vector % name ) call get_data_int32_ ( unit , vector % ndata ) call get_data_array_float64_ ( unit , vector % x , vector % ndata ) call get_data_array_float64_ ( unit , vector % y , vector % ndata ) call get_data_array_float64_ ( unit , vector % z , vector % ndata ) read ( unit ) !0,0,0 case ( FC_Scalar_HeadName ) backspace ( unit ) is_end = . true . return case ( FC_Vector_HeadName ) backspace ( unit ) is_end = . true . return case ( OverlapEndLabel ) is_end = . true . return case default print * , 'something is wrong.' , trim ( title ( 1 : 10 )) end select end subroutine subroutine FC_Scalar_reader ( scalar , unit , is_end ) implicit none type ( FC_Scalar_t ) :: scalar integer ( 4 ), intent ( in ) :: unit logical , intent ( out ) :: is_end character ( 32 ) title is_end = . false . read ( unit ) title ! print*,title select case ( title ( 1 : 10 )) case ( EC_Scalar_HeadName ) backspace ( unit ) is_end = . true . return case ( EC_Vector_HeadName ) backspace ( unit ) is_end = . true . return case ( FC_Scalar_HeadName ) scalar % abbreviated_name = title ( 11 : 14 ) read ( unit ) !4,1,1 read ( unit ) !LNX call get_data_char_ ( unit , 32 , scalar % name ) call get_data_int32_ ( unit , scalar % ndata ) call get_data_array_int32_ ( unit , scalar % face_num , scalar % ndata ) call get_data_array_int32_ ( unit , scalar % face_flag , scalar % ndata ) call get_data_array_float64_ ( unit , scalar % data , scalar % ndata ) read ( unit ) !0,0,0 case ( FC_Vector_HeadName ) backspace ( unit ) is_end = . true . return case ( OverlapEndLabel ) is_end = . true . return case default print * , 'something is wrong.' , trim ( title ( 1 : 10 )) end select end subroutine subroutine FC_Vector_reader ( vector , unit , is_end ) implicit none type ( FC_Vector_t ) :: vector integer ( 4 ), intent ( in ) :: unit logical , intent ( out ) :: is_end character ( 32 ) title is_end = . false . read ( unit ) title ! print*,title select case ( title ( 1 : 10 )) case ( EC_Scalar_HeadName ) backspace ( unit ) is_end = . true . return case ( EC_Vector_HeadName ) backspace ( unit ) is_end = . true . return case ( FC_Scalar_HeadName ) backspace ( unit ) is_end = . true . return case ( FC_Vector_HeadName ) vector % abbreviated_name = title ( 11 : 14 ) read ( unit ) !4,1,1 read ( unit ) !LNX call ignore_data_ ( unit ) !LVCT 位置ベクトルなら1・そうでないなら0　必要ないと思うので無視 call get_data_char_ ( unit , 32 , vector % name ) call get_data_int32_ ( unit , vector % ndata ) call get_data_array_int32_ ( unit , vector % face_num , vector % ndata ) call get_data_array_int32_ ( unit , vector % face_flag , vector % ndata ) call get_data_array_float64_ ( unit , vector % x , vector % ndata ) call get_data_array_float64_ ( unit , vector % y , vector % ndata ) call get_data_array_float64_ ( unit , vector % z , vector % ndata ) read ( unit ) !0,0,0 case ( OverlapEndLabel ) is_end = . true . return case default print * , 'something is wrong.' , trim ( title ( 1 : 10 )) error stop end select end subroutine subroutine get_data_int32_ ( unit , retval ) implicit none integer ( 4 ), intent ( in ) :: unit integer ( 4 ), intent ( inout ) :: retval integer ( 4 ) ibyte , iretn , irecn read ( unit ) ibyte , iretn , irecn read ( unit ) retval end subroutine subroutine get_data_float64_ ( unit , retval ) implicit none integer ( 4 ), intent ( in ) :: unit real ( 4 ), intent ( inout ) :: retval integer ( 4 ) ibyte , iretn , irecn read ( unit ) ibyte , iretn , irecn read ( unit ) retval end subroutine !> 整数型配列の読み込み subroutine get_data_array_int32_ ( unit , ret_array , ret_array_size ) implicit none integer ( 4 ), intent ( in ) :: unit integer ( 4 ), allocatable , intent ( out ) :: ret_array (:) integer ( 4 ), intent ( in ) :: ret_array_size integer ( 4 ) ibyte , iretn , irecn integer ( 4 ) irec , L , ios integer ( 4 ) subrecn read ( unit ) ibyte , iretn , irecn subrecn = irecn - 1 if (. not . allocated ( ret_array )) allocate ( ret_array ( ret_array_size )) if ( subrecn == 0 ) then read ( unit , iostat = ios ) ( ret_array ( L ), L = 1 , irecn * iretn ) return else do irec = 1 , subrecn read ( unit , iostat = ios ) ( ret_array ( L ), L = 1 + ( irec - 1 ) * iretn , irec * iretn ) if ( ios /= 0 ) then ! print*,'iostat: ', ios, 'at L=', L exit end if end do read ( unit ) ( ret_array ( L ), L = 1 + ( irecn - 1 ) * iretn , ret_array_size ) endif end subroutine !> 倍精度実数型配列の読み込み subroutine get_data_array_float64_ ( unit , ret_array , ret_array_size ) implicit none integer ( 4 ), intent ( in ) :: unit real ( 4 ), allocatable , intent ( out ) :: ret_array (:) integer ( 4 ), intent ( in ) :: ret_array_size integer ( 4 ) ibyte , iretn , irecn integer ( 4 ) irec , L , ios integer ( 4 ) subrecn read ( unit ) ibyte , iretn , irecn subrecn = irecn - 1 if (. not . allocated ( ret_array )) allocate ( ret_array ( ret_array_size )) if ( subrecn == 0 ) then read ( unit , iostat = ios ) ( ret_array ( L ), L = 1 , irecn * iretn ) return else do irec = 1 , subrecn read ( unit , iostat = ios ) ( ret_array ( L ), L = 1 + ( irec - 1 ) * iretn , irec * iretn ) if ( ios /= 0 ) then print * , 'iostat: ' , ios , 'at L=' , L exit end if end do read ( unit ) ( ret_array ( L ), L = 1 + ( irecn - 1 ) * iretn , ret_array_size ) endif end subroutine !> データを読み飛ばす処理 subroutine ignore_data_ ( unit ) implicit none integer ( 4 ), intent ( in ) :: unit integer ( 4 ) ibyte , iretn , irecn integer ( 4 ) irec read ( unit ) ibyte , iretn , irecn do irec = 1 , irecn read ( unit ) end do end subroutine !> 文字列（バイト数指定） subroutine get_data_char_ ( unit , byte , ret_char ) implicit none integer ( 4 ), intent ( in ) :: unit integer ( 4 ), intent ( in ) :: byte character (:), allocatable , intent ( inout ) :: ret_char if (. not . allocated ( ret_char )) allocate ( character ( byte ) :: ret_char ) read ( unit ) read ( unit ) ret_char end subroutine subroutine destructor ( this ) implicit none type ( scf_grid_t ), intent ( inout ) :: this if ( allocated ( this % CAN_X )) deallocate ( this % CAN_X ) if ( allocated ( this % CAN_Y )) deallocate ( this % CAN_Y ) if ( allocated ( this % CAN_Z )) deallocate ( this % CAN_Z ) if ( allocated ( this % CCE_X )) deallocate ( this % CCE_X ) if ( allocated ( this % CCE_Y )) deallocate ( this % CCE_Y ) if ( allocated ( this % CCE_Z )) deallocate ( this % CCE_Z ) if ( allocated ( this % EC_Scalars )) deallocate ( this % EC_Scalars ) if ( allocated ( this % EC_Vectors )) deallocate ( this % EC_Vectors ) if ( allocated ( this % FC_Scalars )) deallocate ( this % FC_Scalars ) if ( allocated ( this % EC_Vectors )) deallocate ( this % EC_Vectors ) if ( allocated ( this % face2vertices )) deallocate ( this % face2vertices ) this % NODES = 0 this % NFACE = 0 this % NELEM = 0 this % EC_scalar_data_count = 0 this % EC_vector_data_count = 0 this % FC_scalar_data_count = 0 this % FC_vector_data_count = 0 end subroutine integer function get_fph_element_count ( this ) implicit none class ( scf_grid_t ), intent ( in ) :: this get_fph_element_count = this % NELEM end function integer function get_fph_vertex_count ( this ) implicit none class ( scf_grid_t ), intent ( in ) :: this get_fph_vertex_count = this % NODES end function integer function get_fph_face_count ( this ) implicit none class ( scf_grid_t ), intent ( in ) :: this get_fph_face_count = this % NFACE end function subroutine get_fph_2d_array_of_point_coords ( this , points ) !! 節点座標を2次元配列で出力する. implicit none class ( scf_grid_t ), intent ( inout ) :: this real ( 4 ), allocatable , intent ( inout ) :: points (:,:) allocate ( this % node ( this % NODES )) this % node (:)% coordinate ( 1 ) = this % CAN_X (:) this % node (:)% coordinate ( 2 ) = this % CAN_Y (:) this % node (:)% coordinate ( 3 ) = this % CAN_Z (:) call packing_vector_into_2Darray_ ( points , this % CAN_X , this % CAN_Y , this % CAN_Z ) end subroutine subroutine get_fph_2d_array_of_cell_coords ( this , cells ) !! 要素中心座標を2次元配列で出力する. implicit none class ( scf_grid_t ), intent ( inout ) :: this real ( 4 ), allocatable , intent ( inout ) :: cells (:,:) call packing_vector_into_2Darray_ ( cells , this % CCE_X , this % CCE_Y , this % CCE_Z ) end subroutine subroutine get_face2vertices ( this ) implicit none class ( scf_grid_t ), intent ( inout ) :: this integer :: jj , kk , cnt allocate ( this % face2vertices ( this % NFACE )) allocate ( this % num_face2vertex ( this % NFACE )) do jj = 1 , this % NFACE allocate ( this % face2vertices ( jj )% vertexIDs ( this % NDNUM ( jj ))) end do cnt = 1 ! 頂点番号を0番スタートから1番スタートにする do jj = 1 , this % NFACE do kk = 1 , this % NDNUM ( jj ) this % face2vertices ( jj )% vertexIDs ( kk ) = this % IDNO ( cnt ) + 1 cnt = cnt + 1 end do this % num_face2vertex ( JJ ) = size ( this % face2vertices ( jj )% vertexIDs ) end do end subroutine subroutine get_cell_offsets ( this ) implicit none class ( scf_grid_t ), intent ( inout ) :: this integer cell_id , sum_content , sum_vertex , element_id integer , allocatable :: offset (:) allocate ( offset ( this % NELEM )) ! offset(n)は第nセルの面数,面を構成する頂点数,各面を構成する頂点番号の合計情報数となる ! 例えば第nセルがテトラの場合,面数は4(情報1個),第1面を構成する頂点数は3(情報1個),第1面を構成する各頂点番号(情報3個) ! 第2~4面も同様にして合計情報数17をoffset(n)に格納する do cell_id = 1 , this % NELEM sum_vertex = 1 do element_id = 1 , size ( this % cell2faces ( cell_id )% faceIDs ) sum_vertex = sum_vertex + 1 + this % num_face2vertex ( this % cell2faces ( cell_id )% faceIDs ( element_id )) end do offset ( cell_id ) = sum_vertex end do allocate ( this % offsets ( this % NELEM + 1 )) ! self%offsets(n)は第nセル情報のスタート位置を格納する ! 例えば第1~2セルがテトラ格子の場合 ! self%offsets(1)(=第1セル情報スタート位置)は0 ! self%offsets(2)(=第2セル情報スタート位置)は17 ! self%offsets(3)(=第3セル情報スタート位置)は34 sum_content = 0 this % offsets ( 1 ) = 0 do cell_id = 2 , this % NELEM + 1 this % offsets ( cell_id ) = this % offsets ( cell_id - 1 ) + offset ( cell_id - 1 ) end do end subroutine subroutine get_face2cells ( this ) implicit none class ( scf_grid_t ), intent ( inout ) :: this integer :: jj allocate ( this % face2cells ( 2 , this % NFACE )) ! セル番号を0番から1番スタートにする do jj = 1 , this % NFACE this % face2cells ( 1 , jj ) = this % IE1 ( jj ) + 1 this % face2cells ( 2 , jj ) = this % IE2 ( jj ) + 1 !0のときは存在しない end do end subroutine subroutine get_cell2faces ( this ) use terminalControler_m implicit none class ( scf_grid_t ), intent ( inout ) :: this integer cellID , faceID , contentID logical first_flag allocate ( this % cell2faces ( this % NFACE )) print * , \"Now get cell2face ...\" call set_formatTC ( '(\"completed ... [ #cellID : \",i8,\" / \",i8,\" ]\")' ) do cellID = 1 , this % NELEM call print_progress ([ cellID , this % NELEM ]) first_flag = . true . do faceID = 1 , this % NFACE do contentID = 1 , 2 if ( this % face2cells ( contentID , faceID ) == cellID ) & this % cell2faces ( cellID )% faceIDs & = append2list_int ( this % cell2faces ( cellID )% faceIDs , faceID , first_flag ) end do end do end do end subroutine subroutine get_fph_boundFaceIDs ( this , num_boundFaces ) implicit none class ( scf_grid_t ), intent ( inout ) :: this integer , intent ( out ) :: num_boundFaces integer jj logical first_flag first_flag = . true . ! セル番号0を有する面は境界面(外部表面) do jj = 1 , this % NFACE if ( this % face2cells ( 1 , jj ) == 0 ) this % boundFaceIDs = append2list_int ( this % boundFaceIDs , jj , first_flag ) if ( this % face2cells ( 2 , jj ) == 0 ) this % boundFaceIDs = append2list_int ( this % boundFaceIDs , jj , first_flag ) end do this % num_boundFace = size ( this % boundFaceIDs ) num_boundFaces = this % num_boundFace end subroutine subroutine get_fph_faceCenter ( this , face_center ) implicit none class ( scf_grid_t ), intent ( inout ) :: this real ( 4 ), allocatable , intent ( out ) :: face_center (:,:) real ( 4 ) sum_vertices ( 3 ) integer jj , vertexID allocate ( face_center ( 3 , this % NFACE )) allocate ( this % face ( this % NFACE )) do jj = 1 , this % NFACE sum_vertices (:) = 0.0 do vertexID = 1 , size ( this % face2vertices ( jj )% vertexIDs ) sum_vertices = sum_vertices + & this % node ( this % face2vertices ( jj )% vertexIDs ( vertexID ))% coordinate end do this % face ( jj )% center (:) = sum_vertices / size ( this % face2vertices ( jj )% vertexIDs ) face_center (:, jj ) = this % face ( jj )% center (:) end do end subroutine subroutine get_fph_boundFaceCenter ( this , bound_center ) implicit none class ( scf_grid_t ), intent ( in ) :: this real ( 4 ), allocatable , intent ( inout ) :: bound_center (:,:) integer JB allocate ( bound_center ( 3 , this % num_boundFace )) do JB = 1 , this % num_boundFace bound_center (:, JB ) = this % face ( this % boundFaceIDs ( JB ))% center (:) end do end subroutine subroutine output_fph_cell2face ( this , dir ) implicit none class ( scf_grid_t ), intent ( in ) :: this character ( * ), intent ( in ) :: dir integer n_unit , cellID print * , 'OUTPUT:' , dir // \"cell2face.txt\" open ( newunit = n_unit , file = dir // \"cell2face.txt\" , status = 'replace' ) do cellID = 1 , this % NELEM write ( n_unit , '(*(g0:,\" \"))' ) size ( this % cell2faces ( cellID )% faceIDs ), & this % cell2faces ( cellID )% faceIDs end do close ( n_unit ) end subroutine subroutine output_fph_boundFace ( this , dir ) implicit none class ( scf_grid_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: dir integer JB , n_unit print * , 'OUTPUT:' , dir // \"boundary.txt\" open ( newunit = n_unit , file = dir // \"boundary.txt\" , status = 'replace' ) write ( n_unit , '(i0)' ) this % num_boundFace do JB = 1 , this % num_boundFace write ( n_unit , '(*(g0:,\" \"))' ) size ( this % face2vertices ( this % boundFaceIDs ( JB ))% vertexIDs ) ,& this % face2vertices ( this % boundFaceIDs ( JB ))% vertexIDs end do close ( n_unit ) end subroutine subroutine get_cell2boundFace ( this ) implicit none class ( scf_grid_t ), intent ( inout ) :: this integer JB , boundFace2cellID , ii logical first_flag if (. not . allocated ( this % mainCell )) allocate ( this % mainCell ( this % NELEM )) ! 境界セルに境界面番号を割り当てる do JB = 1 , this % num_boundFace first_flag = . true . if ( this % face2cells ( 1 , this % boundFaceIDs ( JB )) == 0 ) then boundFace2cellID = this % face2cells ( 2 , this % boundFaceIDs ( JB )) if ( allocated ( this % mainCell ( boundFace2cellID )% boundFaceID )) first_flag = . false . this % mainCell ( boundFace2cellID )% boundFaceID & = append2list_int ( this % mainCell ( boundFace2cellID )% boundFaceID , JB , first_flag ) end if if ( this % face2cells ( 2 , this % boundFaceIDs ( JB )) == 0 ) then boundFace2cellID = this % face2cells ( 1 , this % boundFaceIDs ( JB )) if ( allocated ( this % mainCell ( boundFace2cellID )% boundFaceID )) first_flag = . false . this % mainCell ( boundFace2cellID )% boundFaceID & = append2list_int ( this % mainCell ( boundFace2cellID )% boundFaceID , JB , first_flag ) end if end do ! 未割り当ての配列は内部セル do ii = 1 , this % NELEM if (. not . allocated ( this % mainCell ( ii )% boundFaceID )) then allocate ( this % mainCell ( ii )% boundFaceID ( 1 )) this % mainCell ( ii )% boundFaceID ( 1 ) = 0 end if end do end subroutine subroutine get_fph_adjacentCellIDs ( this ) use terminalControler_m implicit none class ( scf_grid_t ), intent ( inout ) :: this integer ii , jj logical first_flag first_flag = . true . ! 計算コスト大,要改善 print * , \"Now solve adjacent cells ...\" call set_formatTC ( '(\"Completed ... [ #cellID : \",i8,\" / \",i8,\" ]\")' ) do ii = 1 , this % NELEM call print_progress ([ ii , this % NELEM ]) do jj = 1 , this % NFACE if ( this % face2cells ( 1 , jj ) == 0 . or . this % face2cells ( 2 , jj ) == 0 ) cycle if ( this % face2cells ( 1 , jj ) == ii ) & this % mainCell ( ii )% adjacentCellIDs & = append2list_int ( this % mainCell ( ii )% adjacentCellIDs , this % face2cells ( 2 , jj ), first_flag ) if ( this % face2cells ( 2 , jj ) == ii ) & this % mainCell ( ii )% adjacentCellIDs & = append2list_int ( this % mainCell ( ii )% adjacentCellIDs , this % face2cells ( 1 , jj ), first_flag ) end do first_flag = . true . end do end subroutine subroutine output_fph_adjacentCell ( this , dir ) implicit none class ( scf_grid_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: dir integer n_unit , ii print * , 'OUTPUT:' , dir // \"adjacency.txt\" open ( newunit = n_unit , file = dir // \"adjacency.txt\" , status = 'replace' ) write ( n_unit , '(*(g0:,\" \"))' ) this % NELEM write ( n_unit , '(*(g0:,\" \"))' ) 100 !任意の数で大丈夫そう do ii = 1 , this % NELEM write ( n_unit , '(*(g0:,\" \"))' ) size ( this % mainCell ( ii )% adjacentCellIDs ), this % mainCell ( ii )% adjacentCellIDs end do do ii = 1 , this % NELEM if ( this % mainCell ( ii )% boundFaceID ( 1 ) == 0 ) then write ( n_unit , '(*(g0:,\" \"))' ) 0 else write ( n_unit , '(*(g0:,\" \"))' ) size ( this % mainCell ( ii )% boundFaceID ), this % mainCell ( ii )% boundFaceID end if end do close ( n_unit ) end subroutine subroutine output_fph_vtk ( this , dir ) implicit none class ( scf_grid_t ), intent ( in ) :: this character ( * ), intent ( in ) :: dir integer n_unit , node_id , cell_id , element_id print * , 'OUTPUT:' , dir // \"shape.vtk\" open ( newunit = n_unit , file = dir // \"shape.vtk\" , status = \"replace\" ) write ( n_unit , '(a)' ) '# vtk DataFile Version 5.1' write ( n_unit , '(a)' ) 'vtk output' write ( n_unit , '(a)' ) 'ASCII' write ( n_unit , '(a)' ) 'DATASET UNSTRUCTURED_GRID' write ( n_unit , '(a,1x,i0,1x,a)' ) 'POINTS' , this % NODES , 'float' do node_id = 1 , this % NODES write ( n_unit , '(3(e12.5,2x))' ) this % node ( node_id )% coordinate (:) end do write ( n_unit , '()' ) write ( n_unit , '(a,i0,2x,i0)' ) 'CELLS ' , this % NELEM + 1 , this % offsets ( this % NELEM + 1 ) write ( n_unit , '(a)' ) 'OFFSETS vtktypeint64' write ( n_unit , '(*(g0:,\" \"))' ) this % offsets (:) write ( n_unit , '()' ) ! 第nセルがテトラの場合,以下のような記述になる ! 4         (第nセルの面数) ! 3 0 1 3   (第nセル第1面を構成する頂点数),(第1面を構成する第1~3頂点の番号) ! 3 0 1 2   (第nセル第2面を構成する頂点数),(第2面を構成する第1~3頂点の番号) ! 3 0 2 3   (第nセル第3面を構成する頂点数),(第3面を構成する第1~3頂点の番号) ! 3 1 2 3   (第nセル第4面を構成する頂点数),(第4面を構成する第1~3頂点の番号) write ( n_unit , '(a)' ) \"CONNECTIVITY vtktypeint64\" do cell_id = 1 , this % NELEM write ( n_unit , '(i0)' ) size ( this % cell2faces ( cell_id )% faceIDs ) do element_id = 1 , size ( this % cell2faces ( cell_id )% faceIDs ) write ( n_unit , '(*(g0:,\" \"))' ) & this % num_face2vertex ( this % cell2faces ( cell_id )% faceIDs ( element_id )), & this % face2vertices ( this % cell2faces ( cell_id )% faceIDs ( element_id ))% vertexIDs - 1 end do end do write ( n_unit , '()' ) write ( n_unit , '(a,i0)' ) \"CELL_TYPES \" , this % NELEM do cell_id = 1 , this % NELEM write ( n_unit , '(i0)' ) 42 end do write ( n_unit , '()' ) close ( n_unit ) end subroutine subroutine search_fph_vector_data ( this , key , vector ) implicit none class ( scf_grid_t ), intent ( in ) :: this character ( * ), intent ( in ) :: key real ( 4 ), allocatable , intent ( inout ) :: vector (:,:) integer i do i = 1 , size ( this % EC_Vectors ) if ( trim ( this % EC_Vectors ( i )% abbreviated_name ) == trim ( key ) ) then call packing_vector_into_2Darray_ ( vector , & this % EC_Vectors ( i )% x , this % EC_Vectors ( i )% y , this % EC_Vectors ( i )% z ) return end if end do end subroutine subroutine packing_vector_into_2Darray_ ( array , x , y , z ) !! 実数のベクトル配列を2次元配列に詰め直す implicit none real ( 4 ), allocatable , intent ( out ) :: array (:,:) real ( 4 ), intent ( in ) :: x (:), y (:), z (:) integer size_of_array size_of_array = size ( x ) if ( size_of_array /= size ( y ) . or . size_of_array /= size ( z )) then print \"('ERROR(SCTfile_reader, packing_): size of x is different from y or z')\" return end if if (. not . allocated ( array )) allocate ( array ( 3 , size_of_array )) array ( 1 ,:) = x (:) array ( 2 ,:) = y (:) array ( 3 ,:) = z (:) end subroutine function append2list_int ( list , element , first_flag ) result ( after_list ) integer , intent ( in ) :: list (:) integer , intent ( in ) :: element logical , intent ( inout ) :: first_flag integer , allocatable :: after_list (:) integer n if ( first_flag ) then allocate ( after_list ( 1 )) after_list ( 1 ) = element else n = size ( list ) allocate ( after_list ( n + 1 )) after_list (: n ) = list (: n ) after_list ( n + 1 ) = element end if first_flag = . false . end function end module","tags":"","loc":"sourcefile\\scffile_reader.f90.html"},{"title":"SCTfile_reader.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~sctfile_reader.f90~~AfferentGraph sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules SCT_file_reader_m Source Code SCTfile_reader.f90 Source Code module SCT_file_reader_m !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !!version: 2.5.2 !!author: T.Ikeda, Y.Ida !!summary: !!- SC/TETRA 出力のファイルを読み取り，データを取り出す. !!- 今までのconverterと異なり, 本モジュールで独立して扱えるようになっている. !!- 並列化には対応していない. !! !!@note !! !!- セルの節点の並び順はwedge以外はvtkのものと同じ. !!- SC/TETRAでは，セル番号および節点番号は0スタートなので, fortran運用のためインデックス+1. !!- 頂点配列(NDNO)はセルタイプ毎に並んでいない. !!- cell2verticesのrank 1には最大で8つ(hexahedron), face2verticesには4つの値が入るが, !!  値が入っていない箇所は全て-1に統一されている. !! !!@endnote !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ implicit none private integer ( 4 ) LCORD !!座標番号(=0固定): 多分不要 integer , parameter :: LengthOfSubRecord = 4194304 !!サブレコード1行あたりの長さの上限. 必要はないがメモとして !面の定義. [頂点数, ローカル節点番号の並び].ローカル節点番号は1~最大8. integer , private , target :: SCTTetraFaces_ ( 3 + 1 , 4 ) = reshape ( & [ 3 , 4 , 3 , 2 , & 3 , 4 , 1 , 3 , & 3 , 4 , 2 , 1 , & 3 , 1 , 2 , 3 ], shape ( SCTTetraFaces_ )) integer , private , target :: SCTPyramidFaces_ ( 4 + 1 , 5 ) = reshape ( & [ 3 , 1 , 5 , 2 , - 1 , & 3 , 2 , 5 , 3 , - 1 , & 3 , 3 , 5 , 4 , - 1 , & 3 , 4 , 5 , 1 , - 1 , & 4 , 1 , 2 , 3 , 4 ], shape ( SCTPyramidFaces_ )) integer , private , target :: SCTPrismFaces_ ( 4 + 1 , 5 ) = reshape ( & [ 4 , 1 , 4 , 5 , 2 , & 4 , 2 , 5 , 6 , 3 , & 4 , 3 , 6 , 4 , 1 , & 3 , 1 , 2 , 3 , - 1 , & 3 , 6 , 5 , 4 , - 1 ], shape ( SCTPrismFaces_ )) integer , private , target :: SCTHexahedronFaces_ ( 4 + 1 , 6 ) = reshape ( & [ 4 , 1 , 5 , 6 , 2 , & 4 , 2 , 6 , 7 , 3 , & 4 , 3 , 7 , 8 , 4 , & 4 , 4 , 8 , 5 , 1 , & 4 , 1 , 2 , 3 , 4 , & 4 , 8 , 7 , 6 , 5 ], shape ( SCTHexahedronFaces_ )) real ( 8 ), parameter , public :: MissingValueSize = 1.0d20 !! SC/TETRAで規定された欠測値の大きさ. character ( 10 ), parameter :: LS_Scalar_HeadName = \"LS_Scalar:\" character ( 10 ), parameter :: LS_Vector_HeadName = \"LS_Vector:\" character ( 32 ), parameter :: OverLapEndLabel = \"OverlapEnd\" integer , parameter :: LS_Scalar_DataSize = 30 !!.fldに含まれるスカラーデータの個数上限. integer , parameter :: LS_Vector_DataSize = 30 !!.fldに含まれるベクトルデータの個数上限. type , private :: LS_Scalar_t character (:), allocatable :: name character (:), allocatable :: abbreviated_name integer ( 4 ) ndata real ( 8 ), allocatable :: data (:) end type type , private :: LS_Vector_t character (:), allocatable :: name character (:), allocatable :: abbreviated_name integer ( 4 ) ndata real ( 8 ), allocatable :: x (:), y (:), z (:) end type type , private :: sctregion_t integer ( 4 ) NE character (:), allocatable :: LRGN integer ( 4 ), allocatable :: IE (:) !!領域を構成する要素番号 integer ( 4 ), allocatable :: IFA (:) !!領域を構成するローカル面番号. contains procedure , private :: get_data => get_sctregion_data_ procedure , private :: extract_region_surface_ end type sctregion_t type sct_data_name_list_t !! スカラーorベクトルデータの名前だけを取り出す. 構造体の配列にして使用する. !! region用に使うことも出来る. その場合abbreviatedは使わない. !! 異なる文字長の配列が実装できなかったのでこれで代用する. character (:), allocatable :: name character (:), allocatable :: abbreviated_name end type type sct_grid_t !! SC/TETRA メッシュクラス. !! 必要最低限の変数のみ保持. 変数名はフォーマットに準拠. !! メッシュそのものを取り扱うのでメモリ圧迫する可能性大. !! ソルバ内で使う場合はサブルーチンのローカル変数として扱う方が無難(自動開放されるはず) logical , private :: is_FLD logical , private :: includes_topo ! integer,private :: error_code integer ( 4 ), private :: NELEM = 0 !!要素数 integer ( 4 ), private :: NTTE = 0 !!1要素あたりの節点数の合計 integer ( 4 ), allocatable , private :: IETYP (:) !! 要素タイプ. !! 34:tetrahedron, 35:pyramid, 36:wedge, 38:hexahedron integer ( 4 ), allocatable , private :: NDNO (:) !! 節点番号 integer ( 4 ), allocatable , private :: GRP (:) !! グループ番号 integer ( 4 ), allocatable , private :: MAT (:) !! 物性番号 !! 多分使えないけど念のため... integer ( 4 ), private :: NNODS = 0 !! 節点の総数 real ( 8 ), allocatable , private :: CDN_X (:), CDN_Y (:), CDN_Z (:) !! 節点座標 integer ( 4 ), private :: NDATA = 0 !! 場の変数のデータ数(=NNODS) ! SctRegion用変数 integer ( 4 ), private :: NRGN = 0 !! NRGN: 領域の個数, 配列regionの次元 integer ( 4 ), private :: NLEN = 0 !! NLEN: 領域名LRGNのバイト数 type ( sctregion_t ), allocatable , private :: region (:) !test 2021/10/12 !連結リストの方が良い? integer , private :: scalar_data_count = 0 integer , private :: vector_data_count = 0 type ( LS_Scalar_t ), allocatable , private :: scalars (:) type ( LS_Vector_t ), allocatable , private :: vectors (:) integer , private :: tetra_count_ = 0 integer , private :: pyramid_count_ = 0 integer , private :: wedge_count_ = 0 integer , private :: hexa_count_ = 0 contains procedure , public :: includes_topology procedure , public :: is_fld_file procedure , public :: print_self procedure , public :: read_SCT_file procedure , public :: extract_original_cell_vertices procedure , public :: extract_cell_vertices procedure , public :: extract_ordered_cell_vertices procedure , public :: get_2d_array_of_point_coords ! procedure get_2d_array_of_point_velocity !データをsearch_vector_dataで探す方針なので削除. procedure , public :: get_cell_types procedure , public :: get_element_count procedure , public :: get_vertex_count procedure , public :: get_tetrahedron_count procedure , public :: get_wedge_count procedure , public :: get_pyramid_count procedure , public :: get_hexahedron_count procedure , public :: get_region_count procedure , public :: get_region_namelist procedure , public :: extract_face2vertices_on_region procedure , public :: search_scalar_data procedure , public :: search_vector_data procedure , public :: get_data_titles final destructor end type interface get_data_array_ module procedure get_data_array_int32_ module procedure get_data_array_float64_ end interface get_data_array_ public sct_grid_t , sct_data_name_list_t , get_cell_data_from_cellvertices contains !========================================================================== ! PUBLIC : subroutine !========================================================================== subroutine get_cell_data_from_cellvertices ( cell_data , cell2vertices , point_data ) !! 各セル毎の頂点配列に関連する節点中心データからセル中心データを構築する. !! 値はセルを構成する節点データの算術平均として計算する. implicit none integer , intent ( inout ) :: cell_data (:) !!出力されるセル中心データ. integer , intent ( in ) :: cell2vertices (:,:) !!頂点配列. integer , intent ( in ) :: point_data (:) !!任意の節点データ. integer cell , node_count node_count = ubound ( cell2vertices , dim = 1 ) do cell = 1 , size ( cell2vertices , dim = 2 ) cell_data ( cell ) = sum ( point_data ( cell2vertices ( 1 : node_count , cell ))) / node_count end do end subroutine !========================================================================== ! type bounded procedure : sct_grid_t !========================================================================== logical function includes_topology ( this ) !! 格子ファイルがトポロジを含むか. implicit none class ( sct_grid_t ), intent ( in ) :: this includes_topology = this % includes_topo end function logical function is_fld_file ( this ) !!ファイルがFLDか. implicit none class ( sct_grid_t ), intent ( in ) :: this is_fld_file = this % is_FLD end function subroutine print_self ( this , unit ) implicit none class ( sct_grid_t ), intent ( in ) :: this integer , intent ( in ) :: unit integer i , nrg write ( unit , \"('sct grid information ')\" , advance = \"no\" ) if ( this % includes_topo ) then write ( unit , \"(A)\" ) \"from \" // merge ( \"fld file\" , \"pre file\" , this % is_FLD ) write ( unit , \"(' cell      :: ', i0)\" ) this % NELEM write ( unit , \"(' - tetra   :: ', i0)\" ) this % tetra_count_ write ( unit , \"(' - pyramid :: ', i0)\" ) this % pyramid_count_ write ( unit , \"(' - wedge   :: ', i0)\" ) this % wedge_count_ write ( unit , \"(' - hexa    :: ', i0)\" ) this % hexa_count_ write ( unit , \"(' node      :: ', i0)\" ) this % NNODS if ( allocated ( this % region )) then write ( unit , \"(' region info ')\" ) do nrg = 1 , this % NRGN write ( unit , \"(2x,A,1x,A)\" ) trim ( this % region ( nrg )% LRGN ), merge ( \"(vol )\" , \"(surf)\" , all ( this % region ( nrg )% IFA == 0 )) end do endif else write ( unit , \"('topology information not found.')\" ) endif if ( this % is_FLD ) then write ( unit , \"(' scalar data  :: ', i0)\" ) this % scalar_data_count write ( unit , \"(A,' = ',A)\" ) ( this % scalars ( i )% abbreviated_name , this % scalars ( i )% name , i = 1 , this % scalar_data_count ) write ( unit , \"(' vector data  :: ', i0)\" ) this % vector_data_count write ( unit , \"(A,' = ',A)\" ) ( this % vectors ( i )% abbreviated_name , this % vectors ( i )% name , i = 1 , this % vector_data_count ) endif end subroutine subroutine read_SCT_file ( this , filename ) !! SCTファイルを開き，データを取得する. 事実上のコンストラクタ. !! 既に別のファイルを開いていた場合，そのデータを破棄して開く. implicit none class ( sct_grid_t ), intent ( inout ) :: this character ( * ), intent ( in ) :: filename ! character(256) :: errmsg integer unit !割り付けされている物があれば解放する. call destructor ( this ) if (. not . open_binary_sequential_ ( unit , filename )) then return endif select case ( get_extension_ ( filename )) case ( \".pre\" ) ! メッシュファイルの場合 this % is_FLD = . false . this % includes_topo = . true . call readPRE_Header_data_ ( unit ) call readPRE_Main_data_ ( unit , this % NELEM , this % IETYP , this % NTTE , this % NDNO , this % GRP , this % MAT , this % NNODS , & this % CDN_X , this % CDN_Y , this % CDN_Z , this % region , this % NRGN , this % NLEN ) case ( \".fld\" ) ! fldファイルの場合 ! fldの初期ファイルでないとトポロジー情報が入手できないらしい. this % is_FLD = . true . call readFLD_Header_data_ ( unit ) !call readFLD_Main_data_(unit, this%NELEM, this%IETYP, this%NTTE, this%NDNO, this%MAT, this%NNODS, & !                       this%CDN_X, this%CDN_Y, this%CDN_Z, this%NDATA, this%VEL_X, this%VEL_Y, this%VEL_Z, this%PRES) call readFLD_Main_data_2 ( unit , this % NELEM , this % IETYP , this % NTTE , this % NDNO , this % MAT , this % NNODS , & this % CDN_X , this % CDN_Y , this % CDN_Z , this % scalars , this % vectors , & this % scalar_data_count , this % vector_data_count , this % includes_topo ) case default print \"(A,' is not supported. STOP')\" , trim ( filename ) return end  select !各セル数. if ( this % includes_topo ) then this % tetra_count_ = count ( this % IETYP == 34 ) this % pyramid_count_ = count ( this % IETYP == 35 ) this % wedge_count_ = count ( this % IETYP == 36 ) this % hexa_count_ = count ( this % IETYP == 38 ) end if close ( unit ) ! if(this%error_code == -3) stop \"invalid data format. \" end subroutine subroutine extract_original_cell_vertices ( this , cell2vertices ) !!Sc/Tetraで出力されたセル-頂点関係の配列をそのまま出力する. !!セルの種類毎に並んでいないのが特徴.  頂点番号は1から始まる. implicit none class ( sct_grid_t ), intent ( in ) :: this integer , allocatable , intent ( inout ) :: cell2vertices (:,:) !!頂点配列. 1st arg: vertex count, 2nd arg: cell number integer II integer offset integer nc integer KK_beg , KK_end if (. not . this % includes_topo ) return if (. not . allocated ( cell2vertices )) allocate ( cell2vertices ( 1 : 8 , 1 : this % NELEM ), source = - 1 ) nc = 1 KK_beg = 1 do II = 1 , this % NELEM offset = this % IETYP ( II ) - 30 KK_end = KK_beg + offset - 1 cell2vertices ( 1 : offset , nc ) = this % NDNO ( KK_beg : KK_end ) nc = nc + 1 KK_beg = KK_end + 1 end do end subroutine subroutine extract_cell_vertices ( this , tetras , pyramids , wedges , hexas ) !!afdet solver との互換性のため, セルタイプごとの頂点配列を出力する. !!頂点配列にはセル毎の頂点のインデックスが格納される. 頂点番号は1から始まる. implicit none class ( sct_grid_t ), intent ( in ) :: this integer , allocatable , intent ( inout ), optional :: tetras (:,:), pyramids (:,:), wedges (:,:), hexas (:,:) if (. not . this % includes_topo ) return if ( present ( tetras )) call extract_primitives_ ( this , tetras , \"tetra\" ) if ( present ( pyramids )) call extract_primitives_ ( this , pyramids , \"pyramid\" ) if ( present ( wedges )) call extract_primitives_ ( this , wedges , \"wedge\" ) if ( present ( hexas )) call extract_primitives_ ( this , hexas , \"hexa\" ) end subroutine subroutine extract_ordered_cell_vertices ( this , cell2vertices ) !!セルの種類毎に並んだ格子全体の頂点配列を作成する. !!セルはtetra→pyramid→wedge→hexaの順に並べられる. 頂点番号は1から始まる. implicit none class ( sct_grid_t ), intent ( in ) :: this integer , allocatable , intent ( inout ) :: cell2vertices (:,:) integer , allocatable :: tmp (:,:) integer :: celltypes ( 4 ) = [ 34 , 35 , 36 , 38 ] character ( 5 ), dimension ( 4 ) :: typename = [ \"tetra\" , \"pyram\" , \"wedge\" , \"hexah\" ] !gfortranだと文字数が同じでないとerrorになるため無理矢理揃えた. !ifortなら問題ないのだが... integer i , cell_beg , cell_end if (. not . this % includes_topo ) return if (. not . allocated ( cell2vertices )) allocate ( cell2vertices ( 1 : 8 , 1 : this % NELEM )) cell_beg = 1 do i = 1 , 4 if ( count ( this % IETYP == celltypes ( i )) > 0 ) then call extract_primitives_ ( this , tmp , typename ( i )) cell_end = cell_beg + size ( tmp , dim = 2 ) - 1 cell2vertices ( 1 : size ( tmp , dim = 1 ), cell_beg : cell_end ) = tmp (:,:) cell_beg = cell_end + 1 deallocate ( tmp ) end if end do end subroutine subroutine get_2d_array_of_point_coords ( this , xyz ) !! 節点座標を2次元配列で出力する. implicit none class ( sct_grid_t ), intent ( in ) :: this real ( 8 ), allocatable , intent ( inout ) :: xyz (:,:) if (. not . this % includes_topo ) return call packing_vector_into_2Darray_ ( xyz , this % CDN_X , this % CDN_Y , this % CDN_Z ) end subroutine ! subroutine get_2d_array_of_point_velocity(this, velocity) !     !! 節点流速データを2次元配列で出力する. !     implicit none !     class(sct_grid_t),intent(in) :: this !     real(8),allocatable,intent(inout) :: velocity(:,:) !     if(this%error_code /= 0) return !     call packing_vector_into_2Darray_(velocity, this%VEL_X, this%VEL_Y, this%VEL_Z) ! end subroutine subroutine get_cell_types ( this , celltypes , conversion ) !!セルタイプ配列を出力する. !!extract_original_cell_verticesで出力したセル-節点配列に対して有効. implicit none class ( sct_grid_t ), intent ( in ) :: this integer , allocatable , intent ( inout ) :: celltypes (:) !!セルタイプ配列 character ( * ), intent ( in ), optional :: conversion !!セルタイプ番号をvtk, xdmfいずれかに変換する. if (. not . this % includes_topo ) return allocate ( celltypes , source = this % IETYP ) if (. not . present ( conversion )) return select case ( trim ( conversion )) case ( \"vtk\" , \"VTK\" ) where ( celltypes == 34 ) celltypes = 10 elsewhere ( celltypes == 35 ) celltypes = 14 elsewhere ( celltypes == 36 ) celltypes = 13 elsewhere ( celltypes == 38 ) celltypes = 12 endwhere case ( \"xdmf\" , \"XDMF\" ) where ( celltypes == 34 ) celltypes = 6 elsewhere ( celltypes == 35 ) celltypes = 7 elsewhere ( celltypes == 36 ) celltypes = 8 elsewhere ( celltypes == 38 ) celltypes = 9 endwhere case default print * , trim ( conversion ), \" is not implemented. \" return end select end subroutine integer function get_element_count ( this ) !!要素数を取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this if ( this % includes_topo ) get_element_count = this % NELEM end function integer function get_vertex_count ( this ) !!節点数を取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this if ( this % includes_topo ) get_vertex_count = this % NNODS end function integer function get_tetrahedron_count ( this ) !!格子に含まれるテトラ格子数を取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this if ( this % includes_topo ) get_tetrahedron_count = this % tetra_count_ end function integer function get_pyramid_count ( this ) !!格子に含まれるピラミッド格子数を取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this if ( this % includes_topo ) get_pyramid_count = this % pyramid_count_ end function integer function get_wedge_count ( this ) !!格子に含まれるプリズム格子数を取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this if ( this % includes_topo ) get_wedge_count = this % wedge_count_ end function integer function get_hexahedron_count ( this ) !!格子に含まれるヘキサ格子数を取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this if ( this % includes_topo ) get_hexahedron_count = this % hexa_count_ end function integer function get_region_count ( this ) !!領域の個数. implicit none class ( sct_grid_t ), intent ( in ) :: this get_region_count = this % NRGN end function subroutine get_region_namelist ( this , name_list ) implicit none class ( sct_grid_t ), intent ( in ) :: this type ( sct_data_name_list_t ), allocatable , intent ( inout ) :: name_list (:) integer nrg allocate ( name_list ( 1 : this % NRGN )) do nrg = 1 , this % NRGN name_list ( nrg )% name = this % region ( nrg )% LRGN enddo end subroutine subroutine extract_face2vertices_on_region ( this , region_num , cell2vertices , face2vertices ) !!任意のregionを構成する頂点配列を取得する. 体積領域は無視する. !!cell2verticesはoriginalの物でなければならない. implicit none class ( sct_grid_t ), intent ( in ) :: this integer , intent ( in ) :: region_num !!region番号. integer , allocatable , intent ( in ) :: cell2vertices (:,:) !!並べ替えのされていないセル-頂点配列. integer , allocatable , intent ( inout ) :: face2vertices (:,:) !!regionを構成する面-頂点配列. ! integer nrg if (. not . this % includes_topo ) return if ( region_num > this % NRGN ) then print * , \"error(sct_grid_t) :: region_num must be less than \" , this % NRGN return endif call this % region ( region_num )% extract_region_surface_ ( this % IETYP , cell2vertices , face2vertices ) end subroutine subroutine search_scalar_data ( this , key , scalar ) !! .fldに含まれるスカラー場データを取得する. !! keyにタイトル名を入れて検索する. 該当しない場合含まれるデータ一覧を表示. implicit none class ( sct_grid_t ), intent ( in ) :: this character ( * ), intent ( in ) :: key !!取り出したいデータのSC/TETRAでの名称. real ( 8 ), allocatable , intent ( inout ) :: scalar (:) integer i if (. not . this % is_FLD ) return !FLDファイルなら場のデータは含まれると判断. do i = 1 , size ( this % scalars ) if ( trim ( this % scalars ( i )% abbreviated_name ) == trim ( key ) ) then if ( . not . allocated ( scalar ) ) then allocate ( scalar , source = this % scalars ( i )% data ) else scalar (:) = this % scalars ( i )% data (:) end if return end if end do print \"(A,' does not exists.')\" , key print \"('Existing Scalar data are listed below:')\" do i = 1 , this % scalar_data_count print \"(A,1x,':',A)\" , this % scalars ( i )% name , this % scalars ( i )% abbreviated_name end do end subroutine subroutine search_vector_data ( this , key , vector ) !! .fldに含まれるベクトル場データを取得する. !! keyにタイトル名を入れて検索する. 該当しない場合含まれるデータ一覧を表示. implicit none class ( sct_grid_t ), intent ( in ) :: this character ( * ), intent ( in ) :: key !!取り出したいデータのSC/TETRAでの名称. real ( 8 ), allocatable , intent ( inout ) :: vector (:,:) integer i if (. not . this % is_FLD ) return do i = 1 , size ( this % vectors ) if ( trim ( this % vectors ( i )% abbreviated_name ) == trim ( key ) ) then call packing_vector_into_2Darray_ ( vector , this % vectors ( i )% x , this % vectors ( i )% y , this % vectors ( i )% z ) return end if end do print \"(A,' does not exists.')\" , key print \"('Existing Vector data are listed below:')\" do i = 1 , this % vector_data_count print \"(A,1x,':',A)\" , this % vectors ( i )% name , this % vectors ( i )% abbreviated_name end do end subroutine subroutine get_data_titles ( this , titles , data_type ) !! .fldに含まれるデータのタイトルを取得する. implicit none class ( sct_grid_t ), intent ( in ) :: this type ( sct_data_name_list_t ), allocatable , intent ( inout ) :: titles (:) character ( * ), intent ( in ) :: data_type integer i if (. not . this % is_FLD ) return select case ( data_type ) case ( \"scalar\" ) allocate ( titles ( this % scalar_data_count )) do i = 1 , this % scalar_data_count titles ( i )% abbreviated_name = this % scalars ( i )% abbreviated_name titles ( i )% name = this % scalars ( i )% name end do case ( \"vector\" ) allocate ( titles ( this % vector_data_count )) do i = 1 , this % vector_data_count titles ( i )% abbreviated_name = this % vectors ( i )% abbreviated_name titles ( i )% name = this % vectors ( i )% name end do case default end select end subroutine subroutine destructor ( this ) implicit none type ( sct_grid_t ), intent ( inout ) :: this ! integer i if ( allocated ( this % IETYP )) deallocate ( this % IETYP ) if ( allocated ( this % MAT )) deallocate ( this % MAT ) if ( allocated ( this % NDNO )) deallocate ( this % NDNO ) if ( allocated ( this % GRP )) deallocate ( this % GRP ) if ( allocated ( this % CDN_X )) deallocate ( this % CDN_X ) if ( allocated ( this % CDN_Y )) deallocate ( this % CDN_Y ) if ( allocated ( this % CDN_Z )) deallocate ( this % CDN_Z ) ! if (allocated(this%VEL_X)) deallocate(this%VEL_X) ! if (allocated(this%VEL_Y)) deallocate(this%VEL_Y) ! if (allocated(this%VEL_Z)) deallocate(this%VEL_Z) if ( allocated ( this % region )) deallocate ( this % region ) if ( allocated ( this % scalars )) deallocate ( this % scalars ) if ( allocated ( this % vectors )) deallocate ( this % vectors ) this % NELEM = 0 this % NNODS = 0 this % NDATA = 0 this % NTTE = 0 this % NLEN = 0 this % NRGN = 0 this % tetra_count_ = 0 this % pyramid_count_ = 0 this % wedge_count_ = 0 this % hexa_count_ = 0 this % scalar_data_count = 0 this % vector_data_count = 0 end subroutine !========================================================================== ! PRIVATE : extraction !========================================================================== subroutine extract_primitives_ ( sct_grid , primitive , cell_type ) !!格子からセルタイプ毎の頂点配列を抜き出す. implicit none type ( sct_grid_t ), intent ( in ) :: sct_grid integer , allocatable , intent ( inout ) :: primitive (:,:) !!セルタイプ毎の頂点配列. 1st arg: local node number, 2nd arg: cell number !!頂点インデックスが格納される. インデックスは1スタートになっている. character ( * ), intent ( in ) :: cell_type !!セルの種類. !!\"tetra(or tetrahedron)\", \"prizm(or wedge)\", \"pyramid\", \"hexa(or hexahedron)\" integer ( 4 ) :: nc , offset integer ( 4 ) :: II , node_of_cell integer ( 4 ) :: KK_beg , KK_end integer a_err character ( 512 ) msg nc = 1 select case ( trim ( cell_type )) case ( \"tetra\" , \"tetrahedron\" ) node_of_cell = 4 case ( \"prizm\" , \"wedge\" ) node_of_cell = 6 case ( \"pyramid\" , \"pyram\" ) node_of_cell = 5 case ( \"hexa\" , \"hexahedron\" , \"hexah\" ) node_of_cell = 8 case default print \"('Unclassifiable cell type was detected. choose cell type below:')\" print \"('tetra or tetrahedron')\" print \"('prizm or wedge      ')\" print \"('pyramid             ')\" print \"('hexa  or hexahedron ')\" stop end select if ( count ( sct_grid % IETYP == 30 + node_of_cell ) == 0 ) then print \"('error: cell_type ', A, ' possibly does not exists on your mesh file...')\" , cell_type ! return end if !仮に対応するセルタイプが存在しなくても割り付けは出来るが，その場合は以下の処理も自動的にスルーされる allocate ( primitive ( 1 : node_of_cell , count ( sct_grid % IETYP == 30 + node_of_cell )), source = - 1 , & stat = a_err , errmsg = msg ) if ( a_err /= 0 ) then print \"(i0,1x,A)\" , a_err , msg return end if KK_beg = 1 do II = 1 , size ( sct_grid % IETYP ) offset = sct_grid % IETYP ( II ) - 30 KK_end = KK_beg + offset - 1 if ( sct_grid % IETYP ( II ) == 30 + node_of_cell ) then primitive ( 1 : node_of_cell , nc ) = sct_grid % NDNO ( KK_beg : KK_end ) nc = nc + 1 end if KK_beg = KK_end + 1 end do end subroutine extract_primitives_ ! subroutine get_cell_data_from_point_data_(cell_data, cell_types, node_numbers, point_data) !     !! 節点中心データからセル中心データを取り出す !     !! セルの値はセルを構成する節点データの平均として扱われる !     !!~~~ CAUTION :: THIS IS DEPRICATED METHOD ~~~ !     !! REASON) 作ってみたが，あとでセルタイプ毎に並び替えるためこの方法では矛盾する. !     !!         セル中心データへの補間は外部で行うとする方が都合が良い. !     !!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !     implicit none !     integer,allocatable,intent(inout) :: cell_data(:) !     integer,intent(in) :: cell_types(:) !     integer,intent(in) :: node_numbers(:) !     integer,intent(in) :: point_data(:) !     integer cell, node_beg, node_end, node_count !     allocate(cell_data(size(cell_types))) !     node_beg = 1 !     do cell = 1, size(cell_types) !         node_count = cell_types(cell) - 30 !         node_end = node_beg + node_count - 1 !         cell_data(cell) = sum(point_data(node_numbers(node_beg:node_end))) / node_count !         node_beg = node_end + 1 !     end do ! end subroutine !========================================================================== ! PRIVATE : utility !========================================================================== logical function open_binary_sequential_ ( unit , filename ) result ( is_opened ) !! バイナリファイルをシーケンシャル形式で開く. 開けない場合.false. integer , intent ( inout ) :: unit !! 装置番号. character ( * ), intent ( in ) :: filename character ( 256 ) iomessage integer iostatus open ( newunit = unit , file = filename , iostat = iostatus , iomsg = iomessage , & form = 'unformatted' , access = 'sequential' , status = 'old' , convert = 'big_endian' ) if ( iostatus == 0 ) then is_opened = . true . else is_opened = . false . print \"('error:',i0,1x,A)\" , iostatus , trim ( iomessage ) end if end function function get_extension_ ( filename ) result ( extension_name ) !! ファイル名の拡張子を取得する. !! e.g.) hoge.f90なら\".f90\"が返される. \".\"が2つ以上ある場合は保証しない. character ( * ), intent ( in ) :: filename character (:), allocatable :: extension_name integer extension_start extension_start = index ( filename , \".\" , back = . true .) extension_name = filename ( extension_start : len_trim ( filename )) end function subroutine packing_vector_into_2Darray_ ( array , x , y , z ) !! 実数のベクトル配列を2次元配列に詰め直す implicit none real ( 8 ), allocatable , intent ( out ) :: array (:,:) real ( 8 ), intent ( in ) :: x (:), y (:), z (:) integer size_of_array size_of_array = size ( x ) if ( size_of_array /= size ( y ) . or . size_of_array /= size ( z )) then print \"('ERROR(SCTfile_reader, packing_): size of x is different from y or z')\" return end if if (. not . allocated ( array )) allocate ( array ( 3 , size_of_array )) array ( 1 ,:) = x (:) array ( 2 ,:) = y (:) array ( 3 ,:) = z (:) end subroutine !========================================================================== ! PRIVATE: reading header !========================================================================== subroutine readPRE_Header_data_ ( unit ) !!preファイルのヘッダ部分を読み取る implicit none integer , intent ( in ) :: unit integer ( 4 ) header_num character ( 8 ) header_text character ( 32 ) title_text read ( unit ) header_text read ( unit ) header_num ! 序文データの読み取り ! おそらくvtk化するためには不要なので ! 無限ループでHeaderDataEndを検出した時点でexit do read ( unit ) title_text if ( trim ( title_text ) == 'HeaderDataEnd' ) exit read ( unit ) read ( unit ) read ( unit ) end do end subroutine subroutine readFLD_Header_data_ ( unit ) implicit none integer , intent ( in ) :: unit integer ( 4 ) header_num , NNAMS , n character ( 8 ) header_text character ( 32 ) title_text read ( unit ) header_text read ( unit ) header_num ! 序文データの読み取り ! おそらくvtk化するためには不要なので ! 無限ループでHeaderDataEndを検出した時点でexit do read ( unit ) title_text if ( trim ( title_text ) == 'HeaderDataEnd' ) then exit elseif (( trim ( title_text ) == 'Cycle' ). or .( trim ( title_text ) == 'Unused' )) then read ( unit ) read ( unit ) elseif ( trim ( title_text ) == 'Unit:$TEMP' ) then read ( unit ) read ( unit ) read ( unit ) read ( unit ) read ( unit ) NNAMS do n = 1 , NNAMS read ( unit ) end do read ( unit ) cycle end if read ( unit ) read ( unit ) read ( unit ) end do end subroutine !========================================================================== ! PRIVATE: reading main data !========================================================================== !> 本文データの読み取り．とにかく全て読み取るようにしている subroutine readPRE_Main_data_ ( unit , NELEM , IETYP , NTTE , NDNO , GRP , MAT , NNODS , CDN_X , CDN_Y , CDN_Z , region , NRGN , NLEN ) implicit none integer , intent ( in ) :: unit integer , intent ( inout ) :: NELEM integer , intent ( inout ) :: NTTE integer , allocatable , intent ( inout ) :: IETYP (:) integer , allocatable , intent ( inout ) :: NDNO (:) integer , allocatable , intent ( inout ) :: GRP (:) integer , allocatable , intent ( inout ) :: MAT (:) integer , intent ( inout ) :: NNODS real ( 8 ), allocatable , intent ( inout ) :: CDN_X (:), CDN_Y (:), CDN_Z (:) integer , intent ( inout ) :: NRGN integer , intent ( inout ) :: NLEN type ( sctregion_t ), allocatable , intent ( inout ) :: region (:) integer ( 4 ) nrg character ( 32 ) main_data_title character ( 32 ) TITLE !> OVerlapStart_nの読み取り read ( unit ) main_data_title !本文データの読み取り ! irecn == 1 なら タイトル内のサブレコードは1つ ! iretn == 1 なら サブレコード内のデータは1つ ! ibyte == 4:int32, 8:real64, 1:char(32 or 80 or 1) ! 本文データにて ibyte = 1となることはなさそう !> LS_CoordinateSystem read ( unit ) TITLE read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , LCORD ) read ( unit ) !0, 0, 0 !> LS_Elements read ( unit ) TITLE read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , IETYP , NELEM ) call get_data_int32_ ( unit , NTTE ) call get_data_array_ ( unit , NDNO , NTTE ) !NDNOは0スタートのため, 都合+1する. NDNO ( 1 : NTTE ) = NDNO ( 1 : NTTE ) + 1 read ( unit ) !0, 0, 0 !> LS_GrpOfElements read ( unit ) TITLE read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , GRP , NELEM ) read ( unit ) !> LS_MatOfElements read ( unit ) TITLE read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , MAT , NELEM ) read ( unit ) !> LS_Nodes read ( unit ) TITLE read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NNODS ) call get_data_array_ ( unit , CDN_X , NNODS ) call get_data_array_ ( unit , CDN_Y , NNODS ) call get_data_array_ ( unit , CDN_Z , NNODS ) read ( unit ) !> OverlapEndならそのまま終了 !> そうで無い場合，任意データLS_SctRegionsが存在しうるが !> vtk化のためには不要と思われるので現状は素通り !> 追記：2021/05/30　境界面の指定番号なのでIFACE.DATへ利用可能かも read ( unit ) TITLE if ( trim ( TITLE ) == 'OverlapEnd' ) then print * , 'SctRegion is not included in this file. ' else print * , 'SctRegions is included.' read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NRGN ) allocate ( region ( NRGN )) call get_data_int32_ ( unit , NLEN ) do nrg = 1 , NRGN call region ( nrg )% get_data ( unit , NLEN ) end do read ( unit ) end if end subroutine subroutine readFLD_Main_data_ ( unit , NELEM , IETYP , NTTE , NDNO , MAT , & NNODS , CDN_X , CDN_Y , CDN_Z , & NDATA , VEL_X , VEL_Y , VEL_Z , & PRES ) implicit none integer , intent ( in ) :: unit integer , intent ( inout ) :: NELEM integer , intent ( inout ) :: NTTE integer , allocatable , intent ( inout ) :: IETYP (:) integer , allocatable , intent ( inout ) :: NDNO (:) integer , allocatable , intent ( inout ) :: MAT (:) integer , intent ( inout ) :: NNODS real ( 8 ), allocatable , intent ( inout ) :: CDN_X (:), CDN_Y (:), CDN_Z (:) integer , intent ( inout ) :: NDATA real ( 8 ), allocatable , intent ( inout ) :: VEL_X (:), VEL_Y (:), VEL_Z (:) real ( 8 ), allocatable , intent ( inout ) :: PRES (:) integer ( 4 ) N , NTRY character ( 32 ) main_data_title character ( 32 ) TITLE !> OVerlapStart_nの読み取り read ( unit ) main_data_title !本文データの読み取り ! irecn == 1 なら タイトル内のサブレコードは1つ ! iretn == 1 なら サブレコード内のデータは1つ ! ibyte == 4:int32, 8:real64, 1:char(32 or 80 or 1) ! 本文データにて ibyte = 1となることはなさそう do read ( unit ) TITLE ; print * , TITLE select case ( trim ( TITLE )) case ( 'LS_CoordinateSystem' ) read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , LCORD ) read ( unit ) !0, 0, 0 case ( 'LS_SurfaceGeometryArray' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !NGFAX call ignore_data_ ( unit ) !LLEN call ignore_data_ ( unit ) !LRGNS call ignore_data_ ( unit ) !NBNNS call ignore_data_ ( unit ) !IPTYP call ignore_data_ ( unit ) !IPMAT call ignore_data_ ( unit ) !NTTSS call ignore_data_ ( unit ) !NDFA read ( unit ) !0, 0, 0 case ( 'LS_Elements' ) read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , IETYP , NELEM ) call get_data_int32_ ( unit , NTTE ) call get_data_array_ ( unit , NDNO , NTTE ) !NDNOは0スタートのため, 都合+1する. NDNO ( 1 : NTTE ) = NDNO ( 1 : NTTE ) + 1 read ( unit ) !0, 0, 0 case ( 'LS_MatOfElements' ) read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , MAT , NELEM ) read ( unit ) case ( 'LS_Nodes' ) read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NNODS ) call get_data_array_ ( unit , CDN_X , NNODS ) call get_data_array_ ( unit , CDN_Y , NNODS ) call get_data_array_ ( unit , CDN_Z , NNODS ) read ( unit ) case ( 'LS_VolumeGeometryArray' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !NVORG call ignore_data_ ( unit ) !LLEN call ignore_data_ ( unit ) !LRGNS call ignore_data_ ( unit ) !NELES call ignore_data_ ( unit ) !IELE read ( unit ) case ( 'LS_RegionName&Type' ) call ignore_data_ ( unit ) !LNX call get_data_int32_ ( unit , NTRY ) call ignore_data_ ( unit ) !NLEN do N = 1 , NTRY call ignore_data_ ( unit ) !ITRY call ignore_data_ ( unit ) !MRGN end do read ( unit ) case ( 'LS_SFile' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !NLEN call ignore_data_ ( unit ) !TEXT read ( unit ) !ここを切り分ける. scalar dataは要求するデータのみ探索し, 後は捨てる !一致するもののみよみとり，あとはignoreする. case ( 'LS_Scalar:PRES' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call get_data_int32_ ( unit , NDATA ) !NDATA call get_data_array_ ( unit , PRES , NDATA ) !VAR read ( unit ) case ( 'LS_Scalar:TEMP' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Scalar:TURK' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Scalar:TEPS' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Scalar:EVIS' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Scalar:YPLS' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Scalar:HTRC' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Scalar:USTR' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'LS_Vector:VEL' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LVCT call ignore_data_ ( unit ) !LNAM call get_data_int32_ ( unit , NDATA ) !NDATA call get_data_array_ ( unit , VEL_X , NDATA ) call get_data_array_ ( unit , VEL_Y , NDATA ) call get_data_array_ ( unit , VEL_Z , NDATA ) read ( unit ) case ( 'LS_Vector:HVEC' ) call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !LVCT call ignore_data_ ( unit ) !LNAM call ignore_data_ ( unit ) !NDATA call ignore_data_ ( unit ) !VAR call ignore_data_ ( unit ) !VAR call ignore_data_ ( unit ) !VAR read ( unit ) case ( 'OverlapEnd' ) exit case default print * , 'TITLE_ERROR:' , TITLE stop end select end do end subroutine subroutine readFLD_Main_data_2 ( unit , NELEM , IETYP , NTTE , NDNO , MAT , & NNODS , CDN_X , CDN_Y , CDN_Z , & scalars , vectors , scalar_cnt , vector_cnt , topo_included ) !!FLDのメインデータ部分を読み取る. ! !fldが解析スタートファイルでない場合,toporogy情報が含まれない可能性が高い. !したがって, 初期ファイル以外のものを最初に読み取るとトポロジ情報が入手できない． ! implicit none integer , intent ( in ) :: unit integer , intent ( inout ) :: NELEM integer , intent ( inout ) :: NTTE integer , allocatable , intent ( inout ) :: IETYP (:) integer , allocatable , intent ( inout ) :: NDNO (:) integer , allocatable , intent ( inout ) :: MAT (:) integer , intent ( inout ) :: NNODS real ( 8 ), allocatable , intent ( inout ) :: CDN_X (:), CDN_Y (:), CDN_Z (:) type ( LS_Scalar_t ), allocatable , intent ( inout ) :: scalars (:) type ( LS_Vector_t ), allocatable , intent ( inout ) :: vectors (:) integer , intent ( inout ) :: scalar_cnt integer , intent ( inout ) :: vector_cnt logical , intent ( inout ) :: topo_included integer ( 4 ) N , NTRY character ( 32 ) main_data_title character ( 32 ) TITLE !> OVerlapStart_nの読み取り read ( unit ) main_data_title !本文データの読み取り ! irecn == 1 なら タイトル内のサブレコードは1つ ! iretn == 1 なら サブレコード内のデータは1つ ! ibyte == 4:int32, 8:real64, 1:char(32 or 80 or 1) ! 本文データにて ibyte = 1となることはなさそう topo_included = . false . !TITLEは以下の順に並んでいると仮定する. do read ( unit ) TITLE if ( trim ( TITLE ) == 'LS_CoordinateSystem' ) then read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , LCORD ) read ( unit ) !0, 0, 0 else if ( trim ( TITLE ) == 'LS_SurfaceGeometryArray' ) then call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !NGFAX call ignore_data_ ( unit ) !LLEN call ignore_data_ ( unit ) !LRGNS call ignore_data_ ( unit ) !NBNNS call ignore_data_ ( unit ) !IPTYP call ignore_data_ ( unit ) !IPMAT call ignore_data_ ( unit ) !NTTSS call ignore_data_ ( unit ) !NDFA read ( unit ) !0, 0, 0 else if ( trim ( TITLE ) == 'LS_Elements' ) then read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , IETYP , NELEM ) call get_data_int32_ ( unit , NTTE ) call get_data_array_ ( unit , NDNO , NTTE ) !NDNOは0スタートのため, 都合+1する. NDNO ( 1 : NTTE ) = NDNO ( 1 : NTTE ) + 1 read ( unit ) !0, 0, 0 else if ( trim ( TITLE ) == 'LS_MatOfElements' ) then read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NELEM ) call get_data_array_ ( unit , MAT , NELEM ) read ( unit ) else if ( trim ( TITLE ) == 'LS_Nodes' ) then read ( unit ) !4, 1, 1 read ( unit ) !LNX call get_data_int32_ ( unit , NNODS ) call get_data_array_ ( unit , CDN_X , NNODS ) call get_data_array_ ( unit , CDN_Y , NNODS ) call get_data_array_ ( unit , CDN_Z , NNODS ) read ( unit ) !順番的にこれがトポロジー情報の最後とみる. topo_included = . true . !ここでループ抜けすると,LS_Scalar以外の物が前に残っている可能性があるのでNG. ! exit else if ( trim ( TITLE ) == 'LS_VolumeGeometryArray' ) then call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !NVORG call ignore_data_ ( unit ) !LLEN call ignore_data_ ( unit ) !LRGNS call ignore_data_ ( unit ) !NELES call ignore_data_ ( unit ) !IELE read ( unit ) else if ( trim ( TITLE ) == 'LS_RegionName&Type' ) then call ignore_data_ ( unit ) !LNX call get_data_int32_ ( unit , NTRY ) call ignore_data_ ( unit ) !NLEN do N = 1 , NTRY call ignore_data_ ( unit ) !ITRY call ignore_data_ ( unit ) !MRGN end do read ( unit ) else if ( trim ( TITLE ) == 'LS_SFile' ) then call ignore_data_ ( unit ) !LNX call ignore_data_ ( unit ) !NLEN call ignore_data_ ( unit ) !TEXT read ( unit ) !必須データでないらしい. 確実にここでループ抜け出来るとは限らない. ! exit else if ( TITLE ( 1 : 10 ) == \"LS_Scalar:\" ) then !LS_Scalar:以下はループ外で処理するので，1行前に戻ってループ抜けする. backspace ( unit ) exit !もしLS_elementsなどを介せずここに来た場合, トポロジは含まれないと判断. else print * , \"(error) readFLD_main_data_2 :: UnKnown title data was detected. \" , trim ( TITLE ) return end if end do !LS_scalar, LS_vector if (. not . allocated ( scalars )) allocate ( scalars ( LS_Scalar_DataSize )) if (. not . allocated ( vectors )) allocate ( vectors ( LS_Vector_DataSize )) datas_reader : block logical EOR integer s_cnt , v_cnt , i EOR = . false . s_cnt = 0 do while (. not . EOR ) s_cnt = s_cnt + 1 call LS_Scalar_reader ( scalars ( s_cnt ), unit , EOR ) end do scalar_cnt = s_cnt - 1 EOR = . false . v_cnt = 0 do while (. not . EOR ) v_cnt = v_cnt + 1 call LS_Vector_reader ( vectors ( v_cnt ), unit , EOR ) end do vector_cnt = v_cnt - 1 do i = s_cnt , size ( scalars ) scalars ( i )% name = \"NONE\" enddo do i = v_cnt , size ( vectors ) vectors ( i )% name = \"NONE\" enddo ! do i = 1, size(scalars) !     print *, scalars(i)%name !     print *, scalars(i)%abbreviated_name ! enddo ! do i = 1, size(vectors) !     print *, vectors(i)%name !     print *, scalars(i)%abbreviated_name ! enddo end block datas_reader end subroutine !========================================================================== ! LS_Scalar_t !========================================================================== subroutine LS_Scalar_reader ( ls_scalar , unit , is_ended ) !!LS_Scalar:で始まる行のデータ読み取り. implicit none type ( LS_Scalar_t ), intent ( inout ) :: ls_scalar !!LS_Scalar_t 構造体 integer ( 4 ), intent ( in ) :: unit !!装置番号 logical , intent ( out ) :: is_ended !!LS_Scalarの終端かどうか. ! character(:),allocatable,intent(inout) :: LNAME ! integer(4),intent(inout) :: NDATA ! real(8),allocatable,intent(inout) :: VAR(:) character ( 32 ) title is_ended = . false . read ( unit ) title select case ( title ( 1 : 10 )) case ( LS_Scalar_HeadName ) ls_scalar % abbreviated_name = title ( 11 : 14 ) call ignore_data_ ( unit ) call get_data_char_ ( unit , 32 , ls_scalar % name ) call get_data_int32_ ( unit , ls_scalar % ndata ) call get_data_array_ ( unit , ls_scalar % data , ls_scalar % ndata ) read ( unit ) case ( LS_Vector_HeadName ) backspace ( unit ) is_ended = . true . return case ( OverLapEndLabel ) is_ended = . true . return case default print \"('something is wrong. ')\" , trim ( title ( 1 : 10 )) error stop end select end subroutine subroutine LS_Vector_reader ( ls_vector , unit , is_ended ) implicit none type ( LS_Vector_t ), intent ( inout ) :: ls_vector integer ( 4 ), intent ( in ) :: unit logical , intent ( inout ) :: is_ended ! character(:),allocatable,intent(inout) :: LNAME ! integer(4),intent(inout) :: NDATA ! real(8),allocatable,intent(inout) :: VAR(:) character ( 32 ) title is_ended = . false . read ( unit ) title select case ( title ( 1 : 10 )) case ( LS_Vector_HeadName ) ls_vector % abbreviated_name = title ( 11 : 14 ) call ignore_data_ ( unit ) call ignore_data_ ( unit ) call get_data_char_ ( unit , 32 , ls_vector % name ) call get_data_int32_ ( unit , ls_vector % ndata ) call get_data_array_ ( unit , ls_vector % x , ls_vector % ndata ) call get_data_array_ ( unit , ls_vector % y , ls_vector % ndata ) call get_data_array_ ( unit , ls_vector % z , ls_vector % ndata ) read ( unit ) case ( OverLapEndLabel ) is_ended = . true . return case default print \"('something is wrong. ')\" , trim ( title ( 1 : 10 )) error stop end select end subroutine !========================================================================== ! sctregion_t !========================================================================== !> sctregion_tクラスのメソッド subroutine get_sctregion_data_ ( this , unit , n_length ) implicit none class ( sctregion_t ), intent ( inout ) :: this integer ( 4 ), intent ( in ) :: unit , n_length call get_data_char_ ( unit , n_length , this % LRGN ) call get_data_int32_ ( unit , this % NE ) call get_data_array_ ( unit , this % IE , this % NE ) call get_data_array_ ( unit , this % IFA , this % NE ) !要素番号, ローカル面番号は全て1スタートに揃える. 従って体積領域は0番. this % IE ( 1 : this % NE ) = this % IE ( 1 : this % NE ) + 1 this % IFA ( 1 : this % NE ) = this % IFA ( 1 : this % NE ) + 1 end subroutine subroutine extract_region_surface_ ( this , celltypes , cell2vertices , face2vert_on_region ) !! regionを構成する頂点番号の抜き出し. 体積領域はスルー. !! したがってregionの面-頂点関係が取得できる. implicit none class ( sctregion_t ), intent ( in ) :: this integer , intent ( in ) :: celltypes (:) integer , intent ( in ) :: cell2vertices (:,:) !!セル-頂点関係の配列. オリジナルのものでなければならない. integer , allocatable , intent ( inout ) :: face2vert_on_region (:,:) integer i , nv , cell , face integer , dimension (:,:), pointer :: SCTElementFacesDef if ( all ( this % IFA == 0 )) then print * , \"this region :\" // trim ( this % LRGN ) // \" is not a surface region.\" return endif if ( allocated ( face2vert_on_region )) deallocate ( face2vert_on_region ) allocate ( face2vert_on_region ( 1 : 8 , this % NE ), source = - 1 ) do i = 1 , this % NE cell = this % IE ( i ) face = this % IFA ( i ) select case ( celltypes ( cell )) case ( 34 ) SCTElementFacesDef => SCTTetraFaces_ case ( 35 ) SCTElementFacesDef => SCTPyramidFaces_ case ( 36 ) SCTElementFacesDef => SCTPrismFaces_ case ( 38 ) SCTElementFacesDef => SCTHexahedronFaces_ case default print * , \"sctregion_t :: not implemented celltype.\" , celltypes ( cell ) error stop end select nv = SCTElementFacesDef ( 1 , face ) face2vert_on_region ( 1 : nv , i ) = cell2vertices ( SCTElementFacesDef ( 2 : nv + 1 , face ), cell ) end do end subroutine !========================================================================== ! data_reader !========================================================================== !> 整数型データを読みこみ格納 subroutine get_data_int32_ ( unit , retval ) implicit none integer ( 4 ), intent ( in ) :: unit integer ( 4 ), intent ( out ) :: retval integer ( 4 ) ibyte , iretn , irecn read ( unit ) ibyte , iretn , irecn read ( unit ) retval end subroutine !> 整数型配列の読み込み subroutine get_data_array_int32_ ( unit , ret_array , ret_array_size ) implicit none integer ( 4 ), intent ( in ) :: unit integer ( 4 ), allocatable , intent ( out ) :: ret_array (:) integer ( 4 ), intent ( in ) :: ret_array_size integer ( 4 ) ibyte , iretn , irecn integer ( 4 ) irec , L , ios integer ( 4 ) subrecn read ( unit ) ibyte , iretn , irecn subrecn = irecn - 1 if (. not . allocated ( ret_array )) allocate ( ret_array ( ret_array_size )) if ( subrecn == 0 ) then read ( unit , iostat = ios ) ( ret_array ( L ), L = 1 , irecn * iretn ) return else do irec = 1 , subrecn read ( unit , iostat = ios ) ( ret_array ( L ), L = 1 + ( irec - 1 ) * iretn , irec * iretn ) if ( ios /= 0 ) then ! print*,'iostat: ', ios, 'at L=', L exit end if end do read ( unit ) ( ret_array ( L ), L = 1 + ( irecn - 1 ) * iretn , ret_array_size ) endif end subroutine !> 倍精度実数型配列の読み込み subroutine get_data_array_float64_ ( unit , ret_array , ret_array_size ) implicit none integer ( 4 ), intent ( in ) :: unit real ( 8 ), allocatable , intent ( out ) :: ret_array (:) integer ( 4 ), intent ( in ) :: ret_array_size integer ( 4 ) ibyte , iretn , irecn integer ( 4 ) irec , L , ios integer ( 4 ) subrecn read ( unit ) ibyte , iretn , irecn subrecn = irecn - 1 if (. not . allocated ( ret_array )) allocate ( ret_array ( ret_array_size )) if ( subrecn == 0 ) then read ( unit , iostat = ios ) ( ret_array ( L ), L = 1 , irecn * iretn ) return else do irec = 1 , subrecn read ( unit , iostat = ios ) ( ret_array ( L ), L = 1 + ( irec - 1 ) * iretn , irec * iretn ) if ( ios /= 0 ) then ! print*,'iostat: ', ios, 'at L=', L exit end if end do read ( unit ) ( ret_array ( L ), L = 1 + ( irecn - 1 ) * iretn , ret_array_size ) endif end subroutine !> データを読み飛ばす処理 subroutine ignore_data_ ( unit ) implicit none integer ( 4 ), intent ( in ) :: unit integer ( 4 ) ibyte , iretn , irecn integer ( 4 ) irec read ( unit ) ibyte , iretn , irecn do irec = 1 , irecn read ( unit ) end do end subroutine !> 文字列（バイト数指定） subroutine get_data_char_ ( unit , byte , ret_char ) implicit none integer ( 4 ), intent ( in ) :: unit integer ( 4 ), intent ( in ) :: byte character (:), allocatable , intent ( inout ) :: ret_char if (. not . allocated ( ret_char )) allocate ( character ( byte ) :: ret_char ) read ( unit ) read ( unit ) ret_char end subroutine end module SCT_file_reader_m","tags":"","loc":"sourcefile\\sctfile_reader.f90.html"},{"title":"simpleFile_reader.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~simplefile_reader.f90~~AfferentGraph sourcefile~simplefile_reader.f90 simpleFile_reader.f90 sourcefile~boxcounter.f90 boxCounter.f90 sourcefile~boxcounter.f90->sourcefile~simplefile_reader.f90 sourcefile~casename.f90 caseName.f90 sourcefile~casename.f90->sourcefile~simplefile_reader.f90 sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~dropletequation.f90->sourcefile~simplefile_reader.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~simplefile_reader.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletgenerator.f90->sourcefile~simplefile_reader.f90 sourcefile~dropletgenerator.f90->sourcefile~dropletequation.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~boxcounter.f90 sourcefile~dropletcount.f90->sourcefile~casename.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletequation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~boxcounter.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~casename.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 sourcefile~initial_translate.f90 initial_translate.f90 sourcefile~initial_translate.f90->sourcefile~casename.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules simpleFile_reader Source Code simpleFile_reader.f90 Source Code !>簡単なファイル（CSV、TXTなど）の読込手続き集モジュール module simpleFile_reader implicit none private !>CSV読込手続き interface read_CSV module procedure read_csv_dble , read_csv_int , read_csv_char end interface public read_CSV , read_textRecord contains subroutine read_csv_char ( filename , matrix , column , header ) integer i , Num_unit character ( * ), intent ( in ) :: filename character ( * ), intent ( inout ), allocatable :: matrix (:,:) integer :: mat_size ( 2 ) integer , intent ( in ), optional :: column logical , optional :: header logical :: header_flag = . true . if ( present ( header )) header_flag = header print * , 'CSV_READER:' , filename open ( newunit = Num_unit , file = filename , status = 'old' , action = 'read' ) mat_size = get_size_csv ( Num_unit , header_flag ) if ( present ( column )) mat_size ( 1 ) = column allocate ( matrix ( mat_size ( 1 ), mat_size ( 2 ))) print * , 'Size =' , mat_size (:) if ( header_flag ) read ( Num_unit , '()' ) !ヘッダーの読み飛ばし do i = 1 , mat_size ( 2 ) !本読み込み read ( Num_unit , * ) matrix (:, i ) ! print *, matrix(:,i) end do close ( Num_unit ) end subroutine read_csv_char subroutine read_csv_dble ( filename , matrix , column , header ) integer i , Num_unit character ( * ), intent ( in ) :: filename double precision , intent ( inout ), allocatable :: matrix (:,:) integer :: mat_size ( 2 ) integer , intent ( in ), optional :: column logical , optional :: header logical :: header_flag = . true . if ( present ( header )) header_flag = header print * , 'CSV_READER:' , filename open ( newunit = Num_unit , file = filename , status = 'old' , action = 'read' ) mat_size = get_size_csv ( Num_unit , header_flag ) if ( present ( column )) mat_size ( 1 ) = column allocate ( matrix ( mat_size ( 1 ), mat_size ( 2 ))) print * , 'Size =' , mat_size (:) if ( header_flag ) read ( Num_unit , '()' ) !ヘッダーの読み飛ばし do i = 1 , mat_size ( 2 ) !本読み込み read ( Num_unit , * ) matrix (:, i ) ! print *, matrix(:,i) end do close ( Num_unit ) end subroutine read_csv_dble subroutine read_csv_int ( filename , matrix , column , header ) integer i , Num_unit character ( * ), intent ( in ) :: filename integer , intent ( inout ), allocatable :: matrix (:,:) integer :: mat_size ( 2 ) integer , intent ( in ), optional :: column logical , optional :: header logical :: header_flag = . true . if ( present ( header )) header_flag = header print * , 'CSV_READER:' , filename open ( newunit = Num_unit , file = filename , status = 'old' , action = 'read' ) mat_size = get_size_csv ( Num_unit , header_flag ) if ( present ( column )) mat_size ( 1 ) = column allocate ( matrix ( mat_size ( 1 ), mat_size ( 2 ))) print * , 'Size =' , mat_size (:) if ( header_flag ) read ( Num_unit , '()' ) !ヘッダーの読み飛ばし do i = 1 , mat_size ( 2 ) !本読み込み read ( Num_unit , * ) matrix (:, i ) ! print *, matrix(:,i) end do close ( Num_unit ) end subroutine read_csv_int !>TXTファイルを、全行読み込む。 !>1行あたりの文字数は引数に依存。 subroutine read_textRecord ( filename , array ) character ( * ), intent ( in ) :: filename !!ファイル名（パス） character ( * ), intent ( out ), allocatable :: array (:) !!文字列配列 !!要素数はallocatableだが、1要素あたりの文字数は予め指定 integer i , Num_unit integer :: num_record print * , 'simpleREADER : ' , filename open ( newunit = Num_unit , file = filename , status = 'old' , action = 'read' ) num_record = get_num_records ( Num_unit , header_flag = . false .) allocate ( array ( num_record )) print * , '#Records =' , num_record do i = 1 , num_record read ( Num_unit , '(A)' ) array ( i ) end do close ( Num_unit ) end subroutine function get_size_csv ( Num_unit , header_flag ) result ( mat_size ) integer , intent ( in ) :: Num_unit logical , intent ( in ) :: header_flag integer :: mat_size ( 2 ) character ( 255 ) A mat_size (:) = 0 read ( Num_unit , '(A)' ) A mat_size ( 1 ) = get_num_columns ( A ) mat_size ( 2 ) = get_num_records ( Num_unit , header_flag ) end function get_size_csv integer function get_num_records ( Num_unit , header_flag ) integer , intent ( in ) :: Num_unit logical , intent ( in ) :: header_flag character ( 20 ) A integer ios rewind ( Num_unit ) ! ファイルの最初に戻る get_num_records = 0 if ( header_flag ) read ( Num_unit , '()' ) !ヘッダーの読み飛ばし do !レコード数を調べるループ read ( Num_unit , '(A)' , iostat = ios ) A !ファイル終端であればiosに-1が返る if (( trim ( A ) == '' ). or .( ios /= 0 )) exit !終端もしくは空白行であればループ脱出 get_num_records = get_num_records + 1 end do rewind ( Num_unit ) ! ファイルの最初に戻る end function integer function get_num_columns ( str ) character ( * ), intent ( in ) :: str character ( 1 ) delimiter integer i , j delimiter = ',' if ( index ( str , ',' ) == 0 ) delimiter = ' ' get_num_columns = 1 i = 1 do j = index ( str ( i :), delimiter ) if ( j > 0 ) then if ( j > 1 ) get_num_columns = get_num_columns + 1 i = i + j else exit end if end do end function end module simpleFile_reader","tags":"","loc":"sourcefile\\simplefile_reader.f90.html"},{"title":"sort.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~sort.f90~~AfferentGraph sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~sort_test.f90 sort_test.f90 sourcefile~sort_test.f90->sourcefile~sort.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~kdtree.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules sort_m Source Code sort.f90 Source Code module sort_m !!author: Shohei Kishi, Hikaru Konishi, Tatsuya Miyoshi, Yuta Ida !!ソートモジュール implicit none private !>コンテンツ構造体 !>実数とIDをメンバに持つ type , public :: content_t integer originID real value end type !>ヒープ木クラス !>実体は単なる配列だがツリー構造を表現している !>要素 i に注目すると、親ノードは要素 i/2(小数切り捨て) であり、子ノードは要素 2i, 2i + 1 である type HeapTree type ( content_t ), allocatable :: node (:) contains procedure totalHeaplification !, partialHeaplification procedure rebuild_tree !, get_featuredChildID end type public heap_sort public real2content public merge_sort contains !>ヒープ木のコンストラクタ type ( HeapTree ) function HeapTree_ ( array ) type ( content_t ), intent ( in ) :: array (:) HeapTree_ % node = array call HeapTree_ % totalHeaplification () end function !>全体ヒープ化（親子の大小関係解決）メソッド subroutine totalHeaplification ( self ) class ( HeapTree ) self integer num_node integer parentID , child1ID , child2ID !, featuredChildID num_node = size ( self % node ) do parentID = num_node / 2 , 1 , - 1 !子を持つノードに対してのみ下（葉の方）からループ child1ID = parentID * 2 child2ID = parentID * 2 + 1 ! featuredChildID = self%get_featuredChildID(child1ID, child2ID) !これ使わんほうが速い if ( self % node ( parentID )% value > self % node ( child1ID )% value ) call swap_content ( self % node , parentID , child1ID ) if ( child2ID <= num_node ) then if ( self % node ( parentID )% value > self % node ( child2ID )% value ) call swap_content ( self % node , parentID , child2ID ) end if end do end subroutine !入れ替えの起こった部分だけヒープ化（親子の大小関係解決）メソッド !こっちのほうが速いと思うが、現在バグってます ! subroutine partialHeaplification(self) !     class(HeapTree) self !     integer parentID, child1ID, child2ID, featuredChildID !     integer num_node !     num_node = size(self%node) !     parentID = 1 !     do !         child1ID = parentID*2 !         if(child1ID > num_node) exit    !第一子すら存在しなければループ終了 !         child2ID = parentID*2 + 1 !         featuredChildID = self%get_featuredChildID(child1ID, child2ID) !         if(self%node(parentID)%value > self%node(featuredChildID)%value) then !             call swap_content(self%node, parentID, featuredChildID) !             parentID = featuredChildID !         else !             exit    !入れ替えが起こらなければループ終了 !         end if !     end do ! end subroutine subroutine rebuild_tree ( self ) !!根ノードを除去し、ノード配列を左詰めにする。 !!このとき、配列のサイズが一つ減る。 class ( HeapTree ) self self % node = self % node ( 2 :) end subroutine subroutine swap_content ( array , ID1 , ID2 ) integer , intent ( in ) :: ID1 , ID2 type ( content_t ), intent ( inout ) :: array (:) type ( content_t ) temp !一時的に格納する変数 temp = array ( ID1 ) array ( ID1 ) = array ( ID2 ) array ( ID2 ) = temp end subroutine ! function get_featuredChildID(self, child1ID, child2ID) result(featuredChildID) !     class(HeapTree) self !     integer, intent(in) :: child1ID, child2ID !     integer featuredChildID !     if(child2ID <= size(self%node)) then !         !第2子が存在する（配列サイズ内）場合 !         !値の小さい方を返す !         if (self%node(child1ID)%value < self%node(child2ID)%value) then !             featuredChildID = child1ID !         else !             featuredChildID = child2ID !         end if !         !self%node(:)%valueの臨時配列生成に時間がかかってたぽい !         ! featuredChildID = get_smallerID(self%node(:)%value, child1ID, child2ID) !     else !         !第2子が存在しない（配列サイズ外）場合 !         featuredChildID = child1ID !     end if ! end function ! function get_smallerID(array, ID1, ID2) result(smaller_ID) !     real,intent(in) :: array(:) !     integer, intent(in) :: ID1, ID2 !     integer smaller_ID !     if (array(ID1) < array(ID2)) then !         smaller_ID = ID1 !     else !         smaller_ID = ID2 !     end if ! end function !>ヒープソート function heap_sort ( array_origin ) result ( array_sorted ) type ( content_t ), intent ( in ) :: array_origin (:) type ( content_t ) array_sorted ( size ( array_origin )) type ( HeapTree ) heap_tree integer i heap_tree = HeapTree_ ( array_origin ) do i = 1 , size ( array_origin ) !ソート後の配列に格納するループ array_sorted ( i ) = heap_tree % node ( 1 ) call heap_tree % rebuild_tree () call heap_tree % totalHeaplification () ! call heap_tree%partialHeaplification() end do end function !>実数型配列をコンテンツ配列に変換する function real2content ( real_array ) result ( content_array ) real , intent ( in ) :: real_array (:) type ( content_t ), allocatable :: content_array (:) integer i allocate ( content_array ( size ( real_array ))) do i = 1 , size ( real_array ) content_array ( i )% originID = i content_array ( i )% value = real_array ( i ) end do end function function merge_sort ( array_origin ) result ( array_sorted ) !!マージソート type ( content_t ), intent ( in ) :: array_origin (:) type ( content_t ) array_sorted ( size ( array_origin )) array_sorted = array_origin call merge_sort_recursive ( array_sorted , 1 , size ( array_sorted )) end function recursive subroutine merge_sort_recursive ( array , left_end , right_end ) type ( content_t ), intent ( inout ) :: array (:) integer , intent ( in ) :: left_end , right_end type ( content_t ), allocatable :: work_array (:) integer mid , i , j , k allocate ( work_array ( size ( array ))) if ( left_end < right_end ) then mid = int (( left_end + right_end ) / 2 ) call merge_sort_recursive ( array , left_end , mid ) call merge_sort_recursive ( array , mid + 1 , right_end ) do i = mid , left_end , - 1 work_array ( i ) = array ( i ) end do do j = mid + 1 , right_end work_array ( right_end - ( j - ( mid + 1 ))) = array ( j ) end do i = left_end j = right_end do k = left_end , right_end if ( work_array ( i )% value < work_array ( j )% value ) then array ( k ) = work_array ( i ) i = i + 1 else array ( k ) = work_array ( j ) j = j - 1 end if end do end if end subroutine end module sort_m","tags":"","loc":"sourcefile\\sort.f90.html"},{"title":"terminalControler.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~terminalcontroler.f90~~AfferentGraph sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~terminalcontroler.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~scffile_reader.f90 SCFfile_reader.f90 sourcefile~scffile_reader.f90->sourcefile~terminalcontroler.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~terminalcontroler.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~terminalcontroler.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~scffile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~kdtree.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules terminalControler_m Source Code terminalControler.f90 Source Code module terminalControler_m !!ターミナル操作を扱うモジュール implicit none private character ( 1 ), parameter :: esc = achar ( 27 ) integer , parameter :: stdOut = 6 character (:), allocatable :: format_str public reset_formatTC , set_formatTC , print_progress , print_sameLine interface print_progress !!進捗を表示する module procedure print_progress_int , print_progress_real end interface !|##Example !```Fortran !program sample !   use terminalControler_m ! !   call set_formatTC('(\"PROGRESS [ #progress : \",i6,\" / \",i6,\" ]\")') !   do i = 1, imax !       call print_progress([i, imax]) !   end do ! !end program sample !``` contains subroutine reset_formatTC format_str = '' end subroutine subroutine set_formatTC ( fmt_str ) !!進捗を表示するためのフォーマットを指定 !!指定時に改行が起こる（あとで戻ってくるため） character ( * ), intent ( in ) :: fmt_str if ( allocated ( format_str )) then if ( fmt_str == format_str ) return end if format_str = fmt_str write ( stdOut , '()' ) !改行（あとで戻ってくるため） end subroutine subroutine print_progress_int ( array ) integer , intent ( in ) :: array (:) write ( stdOut , \"(a)\" , advance = 'no' ) esc // 'M' !カーソルが1行戻る write ( stdOut , format_str ) array (:) end subroutine subroutine print_progress_real ( array ) real , intent ( in ) :: array (:) write ( stdOut , \"(a)\" , advance = 'no' ) esc // 'M' !カーソルが1行戻る write ( stdOut , format_str ) array (:) end subroutine subroutine print_sameLine ( str ) character ( * ), intent ( in ) :: str write ( stdOut , \"(a)\" , advance = 'no' ) esc // 'M' !カーソルが1行戻る write ( stdOut , \"(a)\" ) str end subroutine end module","tags":"","loc":"sourcefile\\terminalcontroler.f90.html"},{"title":"timeKeeper.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~timekeeper.f90~~AfferentGraph sourcefile~timekeeper.f90 timeKeeper.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~timekeeper.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~timekeeper.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules timeKeeper_m Source Code timeKeeper.f90 Source Code module timeKeeper_m implicit none private type DateAndTime character ( 8 ) date character ( 10 ) time contains procedure :: string => DateAndTime2string end type type , public :: TimeKeeper private real startCPUtime , lastLapCPUtime type ( DateAndTime ) startDAT contains procedure startDateAndTime , erapsedTime , lapTime end type public TimeKeeper_ public nowDateAndTime , second2HMS contains type ( TimeKeeper ) function TimeKeeper_ () call cpu_time ( TimeKeeper_ % startCPUtime ) TimeKeeper_ % lastLapCPUtime = TimeKeeper_ % startCPUtime call date_and_time ( TimeKeeper_ % startDAT % date , TimeKeeper_ % startDAT % time ) end function real function lapTime ( self ) class ( TimeKeeper ) self real nowCPUtime call cpu_time ( nowCPUtime ) lapTime = nowCPUtime - self % lastLapCPUtime self % lastLapCPUtime = nowCPUtime end function function startDateAndTime ( self ) result ( str ) class ( TimeKeeper ), intent ( in ) :: self character (:), allocatable :: str str = self % startDAT % string () end function real function erapsedTime ( self ) class ( TimeKeeper ), intent ( in ) :: self real nowCPUtime call cpu_time ( nowCPUtime ) erapsedTime = nowCPUtime - self % startCPUtime end function function nowDateAndTime () result ( str ) type ( DateAndTime ) dat character (:), allocatable :: str call date_and_time ( dat % date , dat % time ) str = dat % string () end function function DateAndTime2string ( self ) result ( str ) class ( DateAndTime ), intent ( in ) :: self character (:), allocatable :: str str = self % date ( 1 : 4 ) // '/' // self % date ( 5 : 6 ) // '/' // self % date ( 7 : 8 ) // ' ' & // self % time ( 1 : 2 ) // ':' // self % time ( 3 : 4 ) // ':' // self % time ( 5 : 6 ) end function function second2HMS ( seconds ) result ( str ) real , intent ( in ) :: seconds integer h , m , s character ( 9 ) str s = int ( seconds ) h = s / 3600 s = s - h * 3600 m = s / 60 s = s - m * 60 write ( str , '(i3,\":\",i2,\":\",i2)' ) h , m , s end function end module timeKeeper_m","tags":"","loc":"sourcefile\\timekeeper.f90.html"},{"title":"unstructuredElement.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~unstructuredelement.f90~~AfferentGraph sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~unstructuredelement.f90 sourcefile~cube2usg.f90->sourcefile~vtkmesh_operator.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~vtkmesh_operator.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~vtkmesh_operator.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules unstructuredElement_m Source Code unstructuredElement.f90 Source Code module unstructuredElement_m !!非構造要素モジュール !!非構造格子のベースとなる構造体を定義している implicit none private !>節点構造体（ただの座標配列） type , public :: node_t real coordinate ( 3 ) end type !>セル構造体（節点のID配列） type , public :: cell_t integer , allocatable :: nodeID (:) end type public get_MinMaxCDN , get_cellCenters contains ! function points2nodeArray(points) result(node_array) !     real, intent(in) :: points(:,:) !     type(node_t), allocatable :: node_array(:) !     integer i, num_points !     num_points = size(points, dim=2) !     allocate(node_array(num_points)) !     do i = 1, num_points !         node_array(i)%coordinate = points(:,i) !     end do ! end function function get_MinMaxCDN ( node ) result ( MinMax ) !!節点群の座標の最大最小を返す class ( node_t ), intent ( in ) :: node (:) real MinMax ( 3 , 2 ) MinMax ( 1 , 1 ) = minval ( node (:)% coordinate ( 1 )) MinMax ( 2 , 1 ) = minval ( node (:)% coordinate ( 2 )) MinMax ( 3 , 1 ) = minval ( node (:)% coordinate ( 3 )) print * , 'MIN_coordinates=' , MinMax (:, 1 ) MinMax ( 1 , 2 ) = maxval ( node (:)% coordinate ( 1 )) MinMax ( 2 , 2 ) = maxval ( node (:)% coordinate ( 2 )) MinMax ( 3 , 2 ) = maxval ( node (:)% coordinate ( 3 )) print * , 'MAX_coordinates=' , MinMax (:, 2 ) end function function get_cellCenters ( node , cell ) result ( centers ) !!すべてのセル重心を計算し、配列で返す class ( node_t ), intent ( in ) :: node (:) class ( cell_t ), intent ( in ) :: cell (:) real , allocatable :: centers (:,:) real x ( 3 ) integer i , k , num_node , num_cell , nodeID num_cell = size ( cell ) allocate ( centers ( 3 , num_cell )) do i = 1 , num_cell x (:) = 0.0 num_node = size ( cell ( i )% nodeID ) do k = 1 , num_node nodeID = cell ( i )% nodeID ( k ) x (:) = x (:) + node ( nodeID )% coordinate (:) end do centers (:, i ) = x (:) / real ( num_node ) end do end function end module unstructuredElement_m","tags":"","loc":"sourcefile\\unstructuredelement.f90.html"},{"title":"unstructuredGrid.f90 – Droplets Simulation","text":"This file depends on sourcefile~~unstructuredgrid.f90~~EfferentGraph sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~vector.f90 vector.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~array.f90 array.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~scffile_reader.f90 SCFfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~scffile_reader.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~scffile_reader.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~unstructuredgrid.f90~~AfferentGraph sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules unstructuredGrid_m Source Code unstructuredGrid.f90 Source Code module unstructuredGrid_m use unstructuredElement_m use kdTree_m use vector_m implicit none private type , extends ( cell_t ) :: cell_inFlow_t !! 流れ場格子構造体 integer , allocatable :: boundFaceID (:) !! 境界面ID配列。内部格子なら境界面を持たず、配列サイズはゼロ。 integer , allocatable :: adjacentCellID (:) !! 隣接セルID配列。 real center ( 3 ) !! セル重心 real flowVelocity ( 3 ) !! 流速 real threshold !! 近傍セル判定の閾値 integer , allocatable :: faceID (:) end type type boundaryTriangle_t !! 境界三角形面構造体 integer nodeID ( 3 ) !! 節点ID配列 real center ( 3 ) !! 面重心 real normalVector ( 3 ) !! 法線ベクトル real moveVector ( 3 ) !! 移動量ベクトル（格子移動がある場合に必要になる） integer , allocatable :: multi_nodeID (:) !! 多面体接点ID配列 end type type , public :: FlowFieldUnstructuredGrid !! 流れ場非構造格子クラス private type ( node_t ), allocatable :: NODEs (:) !! 節点配列 type ( cell_inFlow_t ), allocatable :: CELLs (:) !! セル配列 type ( boundaryTriangle_t ), allocatable :: BoundFACEs (:) !! 境界面配列 type ( boundaryTriangle_t ), allocatable :: FACEs (:) type ( kdTree ) kd_tree !! kd-tree（近傍セル探索用） real MIN_CDN ( 3 ) !! 座標の最小値(xyz) real MAX_CDN ( 3 ) !! 座標の最大値(xyz) integer :: num_refCellSearchFalse = 0 !! 参照セル探索結果が悪いと判断された回数 integer :: num_refCellSearch = 0 !! 参照セル探索が行われた回数 logical :: fph_flag = . false . contains private procedure , public :: nearest_cell , nearcell_check procedure , public :: nearest_search_exact , nearest_search_kdTree procedure , public :: get_flowVelocityInCELL , get_movementVectorOfBoundarySurface procedure , public :: get_cellCenterOf , get_allOfCellCenters procedure , public :: get_cellVerticesOf , get_MinMaxOfGrid procedure , public :: get_info => get_gridInformation procedure set_cellCenter , set_cellThreshold , set_MinMaxCDN , point2cellVelocity procedure , public :: read_VTK , read_array , read_INP , read_FLD , read_FPH !===================================================================== procedure , public :: setupWithFlowFieldFile , updateWithFlowFieldFile procedure nearer_cell procedure , public :: search_refCELL procedure , public :: adhesionCheckOnBound procedure , public :: get_num_nearerSearchFalse , get_nearerSearchFalseRate procedure AdjacencySolvingProcess procedure read_adjacency , read_boundaries , solve_adjacencyOnFlowFieldUnstructuredGrid procedure output_boundaries , output_adjacency , boundary_setting , output_STL procedure read_cell2face ! procedure setup_kdTree end type public FlowFieldUnstructuredGrid_ , FlowFieldUnstructuredGrid_withMeshFile contains function FlowFieldUnstructuredGrid_ ( FlowFieldFile ) result ( grid ) !! 流れ場のコンストラクタ !! 流れ場ファイルの読み込み、前処理、kd-treeの構築を行う use path_operator_m character ( * ), intent ( in ) :: FlowFieldFile !! 流れ場ファイル名 character (:), allocatable :: Dir type ( FlowFieldUnstructuredGrid ) grid call grid % setupWithFlowFieldFile ( FlowFieldFile ) call get_DirFromPath ( FlowFieldFile , Dir ) call grid % AdjacencySolvingProcess ( Dir ) !流れ場の前処理 ! call grid%setup_kdTree(Dir) end function function FlowFieldUnstructuredGrid_withMeshFile ( FlowFieldFile , meshFile ) result ( grid ) !! 流れ場のコンストラクタ(meshファイルと流速データファイルが分かれている場合) !! 流れ場ファイルの読み込み、前処理、kd-treeの構築を行う use path_operator_m character ( * ), intent ( in ) :: FlowFieldFile !! 流速データファイル名 character ( * ), intent ( in ) :: meshFile !! メッシュファイル character (:), allocatable :: Dir type ( FlowFieldUnstructuredGrid ) grid call grid % setupWithFlowFieldFile ( FlowFieldFile , meshFile ) call get_DirFromPath ( meshFile , Dir ) call grid % AdjacencySolvingProcess ( Dir ) !流れ場の前処理 ! call grid%setup_kdTree(Dir) end function subroutine setupWithFlowFieldFile ( self , FNAME , meshFile ) !! 流れ場ファイルの読み込み !! VTK, INP, FLDに対応 !! 独自フォーマットのArrayにも対応 !! セル重心の算出も行う class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: FNAME character ( * ), intent ( in ), optional :: meshFile select case ( extensionOf ( FNAME )) case ( 'vtk' ) call self % read_VTK ( FNAME , meshOnly = . false .) case ( 'inp' ) call self % read_INP ( FNAME ) !INPを読み込む(SHARP用) case ( 'fld' ) call self % read_FLD ( FNAME , findTopology = . true ., findVelocity = . true .) if (. not . allocated ( self % CELLs )) then !まだ未割り当てのとき block character (:), allocatable :: topologyFNAME topologyFNAME = FNAME ( : index ( FNAME , '_' , back = . true .)) // '0' // '.fld' !ゼロ番にアクセス call self % read_FLD ( topologyFNAME , findTopology = . true ., findVelocity = . false .) end block call self % read_FLD ( FNAME , findTopology = . false ., findVelocity = . true .) end if case ( 'fph' ) ! call self%read_FPH(FNAME, findTopology= .true., findVelocity = .true.) if (. not . allocated ( self % CELLs )) then !まだ未割り当てのとき block character (:), allocatable :: topologyFNAME topologyFNAME = FNAME ( : index ( FNAME , '_' , back = . true .)) // '0' // '.fph' !ゼロ番にアクセス call self % read_FPH ( topologyFNAME , findTopology = . true ., findVelocity = . false .) end block call self % read_FPH ( FNAME , findTopology = . false ., findVelocity = . true .) end if case ( 'array' ) call self % read_VTK ( meshFile , meshOnly = . true .) call self % read_Array ( FNAME ) case default print * , 'FILE_EXTENSION NG : ' , FNAME error stop end select call self % set_MinMaxCDN () if (. not . self % fph_flag ) call self % set_cellCenter () call self % set_cellThreshold () end subroutine subroutine updateWithFlowFieldFile ( self , FNAME ) !! 流れ場ファイルを読み込み、流れ場を更新する !! あくまで既存の流れ場の更新目的であり、セル数の異なるメッシュは想定していない !! セル重心の算出も行う class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: FNAME select case ( extensionOf ( FNAME )) case ( 'vtk' ) call self % read_VTK ( FNAME , meshOnly = . false .) case ( 'inp' ) call self % read_INP ( FNAME ) !INPを読み込む(SHARP用) case ( 'fld' ) call self % read_FLD ( FNAME , findTopology = . false ., findVelocity = . true .) case ( 'fph' ) call self % read_FPH ( FNAME , findTopology = . false ., findVelocity = . true .) case ( 'array' ) call self % read_Array ( FNAME ) case default print * , 'FILE_EXTENSION NG : ' , FNAME error stop end select call self % set_MinMaxCDN () if (. not . self % fph_flag ) call self % set_cellCenter () call self % set_cellThreshold () call self % boundary_setting ( first = . false .) end subroutine subroutine AdjacencySolvingProcess ( self , dir ) !! 前処理 !! 隣接関係および境界面情報を解決する class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: dir logical success call self % read_adjacency ( dir , success ) if ( success ) then call self % read_boundaries ( dir ) else call self % solve_adjacencyOnFlowFieldUnstructuredGrid () call self % output_boundaries ( dir ) call self % output_adjacency ( dir ) end if call self % boundary_setting ( first = . true .) if (. not . self % fph_flag ) call self % output_STL ( dir // 'shape.stl' ) end subroutine subroutine set_MinMaxCDN ( self ) !! 節点群の座標最大最小の算出 class ( FlowFieldUnstructuredGrid ) self real MinMax ( 3 , 2 ) MinMax = get_MinMaxCDN ( self % NODEs ) self % MIN_CDN = MinMax (:, 1 ) self % MAX_CDN = MinMax (:, 2 ) end subroutine subroutine get_MinMaxOfGrid ( self , MIN_CDN , MAX_CDN ) !! 節点群の座標最大最小を返す class ( FlowFieldUnstructuredGrid ) self real , intent ( out ) :: MIN_CDN ( 3 ), MAX_CDN ( 3 ) MIN_CDN = self % MIN_CDN MAX_CDN = self % MAX_CDN end subroutine subroutine set_cellCenter ( self ) !! セル重心の算出 class ( FlowFieldUnstructuredGrid ) self integer II , IIMX , n , num_node , nodeID real vector ( 3 ) IIMX = size ( self % CELLs ) DO II = 1 , IIMX num_node = size ( self % CELLs ( II )% nodeID ) vector (:) = 0.0 do n = 1 , num_node nodeID = self % CELLs ( II )% nodeID ( n ) vector (:) = vector (:) + self % NODEs ( nodeID )% coordinate (:) end do self % CELLs ( II )% center (:) = vector (:) / real ( num_node ) END DO end subroutine subroutine set_cellThreshold ( self ) !! セル閾値の算出 class ( FlowFieldUnstructuredGrid ) self integer II , IIMX , n , num_node , nodeID , num_face , faceID real x , vector ( 3 ) IIMX = size ( self % CELLs ) if (. not . self % fph_flag ) then DO II = 1 , IIMX num_node = size ( self % CELLs ( II )% nodeID ) x = 0.0 do n = 1 , num_node nodeID = self % CELLs ( II )% nodeID ( n ) vector (:) = self % NODEs ( nodeID )% coordinate (:) - self % CELLs ( II )% center (:) x = max ( x , norm2 ( vector )) end do self % CELLs ( II )% threshold = x ! print*, self%CELLs(II)%threshold END DO else do II = 1 , IIMX num_face = size ( self % CELLs ( II )% faceID ) x = 0.0 do n = 1 , num_face faceID = self % CELLs ( II )% faceID ( n ) vector (:) = self % FACEs ( faceID )% center (:) - self % CELLs ( II )% center (:) x = max ( x , norm2 ( vector )) end do self % CELLs ( II )% threshold = x end do end if end subroutine subroutine read_VTK ( self , FNAME , meshOnly ) !! VTKファイルから流れ場を取得する use VTK_operator_m class ( FlowFieldUnstructuredGrid ) self type ( UnstructuredGrid_inVTK ) vtk_mesh character ( * ), intent ( in ) :: FNAME !! ファイル名 logical , intent ( in ) :: meshOnly !! メッシュだけ読み込み、流速などは無視するフラグ real , allocatable :: velocity (:,:) integer II , IIMX if ( meshOnly ) then call vtk_mesh % read ( FNAME ) else call vtk_mesh % read ( FNAME , cellVector = velocity ) end if self % NODEs = vtk_mesh % node_array IIMX = size ( vtk_mesh % cell_array ) if (. not . allocated ( self % CELLs )) allocate ( self % CELLs ( IIMX )) do II = 1 , IIMX self % CELLs ( II )% nodeID = vtk_mesh % cell_array ( II )% nodeID end do if (. not . meshOnly ) then do II = 1 , IIMX self % CELLs ( II )% flowVelocity (:) = velocity (:, II ) end do endif ! print*, NODEs(KKMX)%coordinate(:) ! print*, CELLs(IIMX)%flowVelocity(:) end subroutine subroutine read_Array ( self , FNAME ) !! 独自フォーマットArrayファイルから、流速を読み込む use array_m class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: FNAME real , allocatable :: velocity (:,:) integer II call read_2dArray_asBinary ( FNAME , velocity ) if ( size ( self % CELLS ) /= size ( velocity , dim = 2 )) then print * , 'SIZE ERROR:' , size ( self % CELLS ), size ( velocity , dim = 2 ) error stop end if do II = 1 , size ( self % CELLS ) self % CELLs ( II )% flowVelocity (:) = velocity (:, II ) ! print*, velocity(:,II) end do ! print*, NODEs(KKMX)%coordinate(:) ! print*, CELLs(IIMX)%flowVelocity(:) end subroutine subroutine read_INP ( self , FNAME ) !! INPファイルを読み込み、節点データを要素データに変換する class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: FNAME INTEGER II , II2 , KK , AAmax , IIMX2 , AA , n_unit integer KKMX , IIMX character ( 6 ) cellshape real , allocatable :: UVWK (:,:) integer , allocatable :: ICN2 (:,:) integer , allocatable :: CELL_TYPE2 (:) print * , 'READ_INP:' , trim ( FNAME ) open ( newunit = n_unit , FILE = FNAME , status = 'old' , action = 'read' ) read ( n_unit , * ) KKMX , IIMX2 print * , 'KKMX,IIMX2=' , KKMX , IIMX2 if (. not . allocated ( self % NODEs )) allocate ( self % NODEs ( KKMX )) allocate ( ICN2 ( 6 , IIMX2 ), source = 0 ) allocate ( CELL_TYPE2 ( IIMX2 ), source = 0 ) DO KK = 1 , KKMX read ( n_unit , * ) AA , self % NODEs ( KK )% coordinate (:) END DO II = 0 DO II2 = 1 , IIMX2 read ( n_unit , fmt = '(I10)' , advance = 'no' ) AA !ここはセル番号なので無視 read ( n_unit , fmt = '(I6)' , advance = 'no' ) AA !ここはなんかしらん（だいたいゼロ） read ( n_unit , fmt = '(A6)' , advance = 'no' ) cellshape cellshape = adjustl ( cellshape ) !左詰め IF (( cellshape == 'tet' ). or .( cellshape == 'prism' ). or .( cellshape == 'pyr' )) THEN II = II + 1 if ( cellshape == 'tet' ) then CELL_TYPE2 ( II ) = 0 read ( n_unit , * ) ICN2 ( 1 , II ), ICN2 ( 2 , II ), ICN2 ( 3 , II ), ICN2 ( 4 , II ) if ( ICN2 ( 1 , II ) == 0. or . ICN2 ( 4 , II ) == 0 ) print * , 'ICN2_WARNING_tet:' , ICN2 (:, II ) ELSE IF ( cellshape == 'prism' ) THEN CELL_TYPE2 ( II ) = 1 read ( n_unit , * ) ICN2 ( 1 , II ), ICN2 ( 2 , II ), ICN2 ( 3 , II ), ICN2 ( 4 , II ), ICN2 ( 5 , II ), ICN2 ( 6 , II ) if ( ICN2 ( 1 , II ) == 0. or . ICN2 ( 6 , II ) == 0 ) print * , 'ICN2_WARNING_prism:' , ICN2 (:, II ) ELSE IF ( cellshape == 'pyr' ) THEN CELL_TYPE2 ( II ) = 2 read ( n_unit , * ) ICN2 ( 5 , II ), ICN2 ( 1 , II ), ICN2 ( 2 , II ), ICN2 ( 3 , II ), ICN2 ( 4 , II ) !INPは最初が山頂点であり、VTKでは最後が山頂点のため、読み込む順がこうなる。 if ( ICN2 ( 1 , II ) == 0. or . ICN2 ( 5 , II ) == 0 ) print * , 'ICN2_WARNING_pyr:' , ICN2 (:, II ) end if ELSE read ( n_unit , '()' ) !テトラでもプリズムでもピラミッドでもないならスルー ENDIF END DO IIMX = II allocate ( UVWK ( 3 , KKMX )) read ( n_unit , * ) AAmax read ( n_unit , '()' ) DO II = 1 , AAmax read ( n_unit , '()' ) END DO DO KK = 1 , KKMX read ( n_unit , * ) AA , UVWK (:, KK ) END DO close ( n_unit ) if (. not . allocated ( self % CELLs )) then allocate ( self % CELLs ( IIMX )) do II = 1 , IIMX select case ( CELL_TYPE2 ( II )) case ( 0 ) self % CELLs ( II )% nodeID = ICN2 ( 1 : 4 , II ) case ( 1 ) self % CELLs ( II )% nodeID = ICN2 ( 1 : 6 , II ) case ( 2 ) self % CELLs ( II )% nodeID = ICN2 ( 1 : 5 , II ) end select end do end if call self % point2cellVelocity ( UVWK ) end subroutine subroutine read_FLD ( self , FNAME , findTopology , findVelocity ) !! FLDファイルから流れ場を取得する use SCT_file_reader_m class ( FlowFieldUnstructuredGrid ) self type ( sct_grid_t ) grid integer ii , iitet , iiwed , iipyr , iihex , iimx , iicnt integer kk , kkmx integer , allocatable :: tetras (:,:), wedges (:,:), pyramids (:,:), hexas (:,:) real ( 8 ), allocatable :: points (:,:) real ( 8 ), allocatable :: velocity (:,:) !, pressure(:) character ( * ), intent ( in ) :: FNAME !! ファイル名 logical , intent ( in ) :: findTopology !! トポロジー情報を取得するフラグ logical , intent ( in ) :: findVelocity !! 流速情報を取得するフラグ print * , 'readFLD : ' , trim ( FNAME ) call grid % read_SCT_file ( FNAME ) if ( findTopology ) then !ファイルが存在し, かつトポロジー情報が存在する場合以下の処理が行われる. call grid % extract_cell_vertices ( tetras , pyramids , wedges , hexas ) if ( allocated ( tetras )) then call grid % get_2d_array_of_point_coords ( points ) iitet = grid % get_tetrahedron_count () iipyr = grid % get_pyramid_count () iiwed = grid % get_wedge_count () iihex = grid % get_hexahedron_count () iimx = grid % get_element_count () kkmx = grid % get_vertex_count () if ( iihex > 0 ) then print * , 'Hexahedron is not yet supported.' , iihex error stop end if allocate ( self % CELLs ( iimx )) allocate ( self % NODEs ( kkmx )) do kk = 1 , kkmx self % NODEs ( kk )% coordinate (:) = real ( points (:, kk )) end do iicnt = 1 do ii = 1 , iitet self % CELLs ( iicnt )% nodeID = tetras (:, ii ) iicnt = iicnt + 1 end do do ii = 1 , iiwed self % CELLs ( iicnt )% nodeID = wedges (:, ii ) iicnt = iicnt + 1 end do do ii = 1 , iipyr self % CELLs ( iicnt )% nodeID = pyramids (:, ii ) iicnt = iicnt + 1 end do end if end if ! call grid%search_scalar_data(\"PRES\",pressure) if ( findVelocity ) then call grid % search_vector_data ( \"VEL\" , velocity ) call self % point2cellVelocity ( real ( velocity )) end if end subroutine subroutine read_FPH ( self , FNAME , findTopology , findVelocity ) !! FPHファイルから流れ場を取得する use SCF_file_reader_m use path_operator_m class ( FlowFieldUnstructuredGrid ) self type ( scf_grid_t ) grid character (:), allocatable :: dir real ( 4 ), allocatable :: points (:,:), velocity (:,:), bound_center (:,:) real ( 4 ), allocatable :: cells (:,:), face_center (:,:) logical is_adjacencyFile , is_cell2faceFile integer iimx , kkmx , jjmx , ii , jj , kk , JB , num_boundFaces , n_unit character ( * ), intent ( in ) :: FNAME !! ファイル名 logical , intent ( in ) :: findTopology !! トポロジー情報を取得するフラグ logical , intent ( in ) :: findVelocity !! 流速情報を取得するフラグ self % fph_flag = . true . print * , 'readFPH : ' , trim ( FNAME ) call grid % read_SCF_file ( FNAME ) call get_DirFromPath ( FNAME , dir ) if ( findTopology ) then iimx = grid % get_fph_element_count () kkmx = grid % get_fph_vertex_count () jjmx = grid % get_fph_face_count () call grid % get_fph_2d_array_of_point_coords ( points ) call grid % get_fph_2d_array_of_cell_coords ( cells ) call grid % get_face2vertices () call grid % get_face2cells () call grid % get_fph_faceCenter ( face_center ) call grid % get_fph_boundFaceIDs ( num_boundFaces ) call grid % get_fph_boundFaceCenter ( bound_center ) allocate ( self % CELLs ( iimx )) allocate ( self % NODEs ( kkmx )) allocate ( self % FACEs ( jjmx )) allocate ( self % BoundFACEs ( num_boundFaces )) inquire ( file = dir // 'adjacency.txt' , exist = is_adjacencyFile ) inquire ( file = dir // 'cell2face.txt' , exist = is_cell2faceFile ) do ii = 1 , iimx self % CELLs ( ii )% center (:) = real ( cells (:, ii )) end do do kk = 1 , kkmx self % NODEs ( kk )% coordinate (:) = real ( points (:, kk )) end do do jj = 1 , jjmx self % FACEs ( jj )% center (:) = real ( face_center (:, jj )) end do do JB = 1 , num_boundFaces self % BoundFACEs ( JB )% center (:) = real ( bound_center (:, JB )) end do if (. not . is_cell2faceFile ) then call grid % get_cell2faces () call grid % output_fph_cell2face ( dir ) end if call self % read_cell2face ( dir ) if (. not . is_adjacencyFile ) then call grid % get_cell_offsets () call grid % get_cell2boundFace () call grid % get_fph_adjacentCellIDs () call grid % output_fph_boundFace ( dir ) call grid % output_fph_adjacentCell ( dir ) call grid % output_fph_vtk ( dir ) end if end if if ( findVelocity ) then call grid % search_fph_vector_data ( \"VEL\" , velocity ) iimx = size ( self % CELLs ) do ii = 1 , iimx self % CELLs ( II )% flowVelocity (:) = real ( velocity (:, II )) end do end if end subroutine subroutine read_cell2face ( self , dir ) class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: dir integer n_unit , num_cell2face , NF , ii , iimx character ( 255 ) str iimx = size ( self % CELLs ) open ( newunit = n_unit , file = dir // 'cell2face.txt' , status = 'old' ) do ii = 1 , iimx read ( n_unit , '(A)' ) str read ( str , * ) num_cell2face allocate ( self % CELLs ( II )% faceID ( num_cell2face )) read ( str , * ) NF , self % CELLs ( II )% faceID (:) end do close ( n_unit ) end subroutine subroutine read_adjacency ( self , path , success ) !! セルの隣接関係情報をTXTファイルから読み込む class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: path !! 隣接関係ファイルへのパス logical , intent ( out ) :: success !! 指定ファイルから正しく情報を取得できたら`.true.`が返る integer II , NA , n_unit , num_cells , num_adj , num_BF , NCMAX character (:), allocatable :: FNAME character ( 255 ) str character ( 13 ), parameter :: adjacencyFileName = 'adjacency.txt' FNAME = trim ( path ) // adjacencyFileName inquire ( file = FNAME , exist = success ) if (. not . success ) then print * , 'AdjacencyFile was not found.' return end if print * , 'READ : ' , FNAME open ( newunit = n_unit , FILE = FNAME , status = 'old' , action = 'read' ) read ( n_unit , * ) num_cells if ( num_cells /= size ( self % CELLs )) then print * , '**SIZE MISMATCH** :' , num_cells , size ( self % CELLs ) success = . false . return end if read ( n_unit , * ) NCMAX DO II = 1 , num_cells read ( n_unit , '(A)' ) str read ( str , * ) num_adj allocate ( self % CELLs ( II )% adjacentCellID ( num_adj )) read ( str , * ) NA , self % CELLs ( II )% adjacentCellID (:) END DO DO II = 1 , num_cells read ( n_unit , '(A)' ) str read ( str , * ) num_BF allocate ( self % CELLs ( II )% boundFaceID ( num_BF )) read ( str , * ) NA , self % CELLs ( II )% boundFaceID (:) END DO close ( n_unit ) end subroutine subroutine output_adjacency ( self , path ) !! セルの隣接関係情報をTXTファイルに出力 class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: path integer II , n_unit , num_cells , NCMAX character (:), allocatable :: FNAME character ( 13 ), parameter :: adjacencyFileName = 'adjacency.txt' FNAME = trim ( path ) // adjacencyFileName print * , 'OUTPUT:' , FNAME num_cells = size ( self % CELLs ) NCMAX = 5 !size(NEXT_CELL(:,:), dim=1) open ( newunit = n_unit , FILE = FNAME , STATUS = 'replace' ) write ( n_unit , * ) num_cells write ( n_unit , * ) NCMAX DO II = 1 , num_cells write ( n_unit , '(*(i0:,X))' ) size ( self % CELLs ( II )% adjacentCellID ), self % CELLs ( II )% adjacentCellID (:) END DO DO II = 1 , num_cells write ( n_unit , '(*(i0:,X))' ) size ( self % CELLs ( II )% boundFaceID ), self % CELLs ( II )% boundFaceID (:) END DO close ( n_unit ) end subroutine subroutine read_boundaries ( self , path ) !! 境界面情報をTXTファイルから読み込む class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: path integer JB , n_unit , JBMX , num_BF_vertex , NBV character (:), allocatable :: FNAME character ( 255 ) str character ( 12 ), parameter :: boundaryFileName = 'boundary.txt' FNAME = trim ( path ) // boundaryFileName print * , 'READ : ' , FNAME open ( newunit = n_unit , FILE = FNAME , status = 'old' , action = 'read' ) read ( n_unit , * ) JBMX if (. not . allocated ( self % BoundFACEs )) allocate ( self % BoundFACEs ( JBMX )) if (. not . self % fph_flag ) then do JB = 1 , JBMX read ( n_unit , * ) self % BoundFACEs ( JB )% nodeID (:) end do else do JB = 1 , JBMX read ( n_unit , '(A)' ) str read ( str , * ) num_BF_vertex allocate ( self % BoundFACEs ( JB )% multi_nodeID ( num_BF_vertex )) read ( str , * ) NBV , self % BoundFACEs ( JB )% multi_nodeID (:) end do end if close ( n_unit ) end subroutine subroutine output_boundaries ( self , path ) !! 境界面情報をTXTファイルに出力 class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: path integer JB , n_unit , JBMX character (:), allocatable :: FNAME character ( 12 ), parameter :: boundaryFileName = 'boundary.txt' FNAME = trim ( path ) // boundaryFileName print * , 'OUTPUT:' , FNAME JBMX = size ( self % BoundFACEs ) open ( newunit = n_unit , FILE = FNAME , STATUS = 'replace' ) write ( n_unit , * ) JBMX do JB = 1 , JBMX write ( n_unit , '(*(i0:,X))' ) self % BoundFACEs ( JB )% nodeID (:) end do close ( n_unit ) end subroutine subroutine setup_kdTree ( self , path ) !! kd-treeの構築 class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: path character (:), allocatable :: FNAME real , allocatable :: xyz (:,:) logical existance character ( 20 ), parameter :: kdTreeFName = 'kdTree.txt' FNAME = trim ( path ) // kdTreeFName xyz = self % get_allOfCellCenters () inquire ( file = FNAME , exist = existance ) if (. not . existance ) then self % kd_tree = kdTree_ ( xyz ) ! 時間かかるので、今は使わない ! call self%kd_tree%saveAsTXT(FNAME) ! print*, 'OUTPUT kdtree:', FNAME else call self % kd_tree % read_kdTree ( FNAME ) print * , 'READ kdtree:' , FNAME end if end subroutine function nearest_cell ( self , X ) result ( nearestCellID ) !! 最近傍セル探索 class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self real , intent ( in ) :: X ( 3 ) !! 探索対象座標 integer nearestCellID !!@note 厳密探索かkdツリー探索かはここで切り替える nearestCellID = self % nearest_search_exact ( X ) ! nearestCellID = self%nearest_search_kdTree(X) end function function nearest_search_exact ( self , X ) result ( nearestCellID ) !! 厳密最近傍セル探索 class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self real , intent ( in ) :: X ( 3 ) !! 探索対象座標 integer II , IIMX real , allocatable :: distance (:) integer nearestCellID IIMX = size ( self % CELLs ) allocate ( distance ( IIMX )) !$omp parallel do DO II = 1 , IIMX ! distance(II) = norm2(self%CELLs(II)%center(:) - X(:)) distance ( II ) = norm2_squared ( self % CELLs ( II )% center (:) - X (:)) END DO !$omp end parallel do nearestCellID = minloc ( distance , dim = 1 ) !最小値インデックス end function function nearest_search_kdTree ( self , X ) result ( nearestCellID ) !!kdツリーによる最近傍セル探索 class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self real , intent ( in ) :: X ( 3 ) !! 探索対象座標 real , allocatable :: xyz (:,:) integer nearestCellID xyz = self % get_allOfCellCenters () call self % kd_tree % search ( xyz , X , nearestCellID ) end function function nearer_cell ( self , X , NCN ) result ( nearCellID ) !! 隣接セルを起点に近傍セル探索 !! セルの隣接関係が悪いと上手く探索できないおそれあり class ( FlowFieldUnstructuredGrid ) self integer , intent ( in ) :: NCN !! 探索開始セルID real , intent ( in ) :: X ( 3 ) !! 探索対象座標 integer NA , featuringCellID , adjaCellID integer , allocatable :: adjacentCellIDs (:) real distance , distance_min logical update integer nearCellID nearCellID = NCN distance_min = norm2 ( self % CELLs ( nearCellID )% center (:) - X (:)) !注目セル重心と粒子との距離 update = . true . do while ( update ) !更新が起こり続ける限り繰り返し update = . false . featuringCellID = nearCellID !注目セル adjacentCellIDs = self % CELLs ( featuringCellID )% adjacentCellID (:) !注目セルの全隣接セル do NA = 1 , size ( adjacentCellIDs ) !注目セルの全隣接セルに対してループ。 adjaCellID = adjacentCellIDs ( NA ) !注目セルに隣接するセルのひとつ ! if (adjacentCELL <= 0) cycle checkAdjacent distance = norm2 ( self % CELLs ( adjaCellID )% center (:) - X (:)) !隣接セル重心と粒子との距離 if ( distance < distance_min ) then nearCellID = adjaCellID distance_min = distance update = . true . end if end do end do end function function nearcell_check ( self , X , NCN ) result ( isNear ) !! 近傍セル探索の結果が妥当かどうかをチェック class ( FlowFieldUnstructuredGrid ) self real , intent ( in ) :: X ( 3 ) !! 探索対象座標 integer , intent ( in ) :: NCN !! 近傍探索結果セルID real :: distance logical isNear distance = norm2 ( X (:) - self % CELLs ( NCN )% center (:)) !遠くのセルを参照していないかどうかのチェック !参照セルとの距離がセル閾値未満であればOK（この条件は経験則でしかない） !fph読み込みの場合,計算速度が遅いので閾値を2倍にする isNear = ( distance < 2 * self % CELLs ( NCN )% threshold ) end function subroutine search_refCELL ( self , X , reference_cell , stat ) !! 参照セル探索 !! 主に近傍探索が呼ばれるが、探索が芳しくない場合は最近傍探索が呼ばれる class ( FlowFieldUnstructuredGrid ) self real , intent ( in ) :: X ( 3 ) !! 探索対象座標 integer , intent ( inout ) :: reference_cell !! 参照セル logical , optional :: stat !! self % num_refCellSearch = self % num_refCellSearch + 1 reference_cell = self % nearer_cell ( X , reference_cell ) if ( present ( stat )) stat = . True . if (. not . self % nearcell_check ( X (:), reference_cell )) then reference_cell = self % nearest_cell ( X ) if ( present ( stat )) stat = . false . self % num_refCellSearchFalse = self % num_refCellSearchFalse + 1 end if end subroutine function get_num_nearerSearchFalse ( self ) result ( num_nearerSearchFalse ) !! 近傍セル探索の結果が悪いと判断された回数を返す class ( FlowFieldUnstructuredGrid ) self integer num_nearerSearchFalse num_nearerSearchFalse = self % num_refCellSearchFalse end function function get_nearerSearchFalseRate ( self ) result ( num_nearerSearchFalseRate ) !! 近傍セル探索の結果が悪いと判断された比率を返す class ( FlowFieldUnstructuredGrid ) self real num_nearerSearchFalseRate num_nearerSearchFalseRate = 10 0. * real ( self % num_refCellSearchFalse ) / real ( self % num_refCellSearch + 1 ) end function subroutine boundary_setting ( self , first ) !! 全境界面に対して外向き法線ベクトルと重心を算出 class ( FlowFieldUnstructuredGrid ) self logical , intent ( in ) :: first !! 初期ステップであるか否か integer II , JJ , JB , IIMX , JBMX , nodeID ( 3 ) real :: a ( 3 ), b ( 3 ), r ( 3 ), normalVector ( 3 ) integer , allocatable :: multi_nodeID (:) type ( boundaryTriangle_t ), allocatable :: BoundFACEs_pre (:) IIMX = size ( self % CELLs ) if (. not . first ) BoundFACEs_pre = self % BoundFACEs do II = 1 , IIMX do JJ = 1 , size ( self % CELLs ( II )% boundFaceID ) JB = self % CELLs ( II )% boundFaceID ( JJ ) if (. not . self % fph_flag ) then nodeID (:) = self % BoundFACEs ( JB )% nodeID (:) self % BoundFACEs ( JB )% center (:) = ( self % NODEs ( nodeID ( 1 ))% coordinate (:) & + self % NODEs ( nodeID ( 2 ))% coordinate (:) & + self % NODEs ( nodeID ( 3 ))% coordinate (:) ) / 3.0 a (:) = self % NODEs ( nodeID ( 2 ))% coordinate (:) - self % NODEs ( nodeID ( 1 ))% coordinate (:) b (:) = self % NODEs ( nodeID ( 3 ))% coordinate (:) - self % NODEs ( nodeID ( 1 ))% coordinate (:) else allocate ( multi_nodeID ( size ( self % BoundFACEs ( JB )% multi_nodeID ))) multi_nodeID (:) = self % BoundFACEs ( JB )% multi_nodeID (:) a (:) = self % NODEs ( multi_nodeID ( 1 ))% coordinate (:) - self % NODEs ( multi_nodeID ( 2 ))% coordinate (:) b (:) = self % NODEs ( multi_nodeID ( 3 ))% coordinate (:) - self % NODEs ( multi_nodeID ( 2 ))% coordinate (:) deallocate ( multi_nodeID ) end if normalVector (:) = cross_product ( a , b ) normalVector (:) = normalize_vector ( normalVector (:)) r (:) = self % CELLs ( II )% center (:) - self % BoundFACEs ( JB )% center (:) !面重心からセル重心へのベクトル if ( dot_product ( normalVector (:), r (:)) > 0.0 ) then normalVector (:) = normalVector (:) * ( - 1.0 ) !内積が正なら内向きなので、外に向ける end if self % BoundFACEs ( JB )% normalVector (:) = normalVector (:) ! print*,'center:',BoundFACEs(JB)%center(:) ! print*,'n_vector:',BoundFACEs(JB)%normalVector(:) end do end do JBMX = size ( self % BoundFACEs ) if ( first ) then do JB = 1 , JBMX self % BoundFACEs ( JB )% moveVector (:) = 0.0 end do else do JB = 1 , JBMX self % BoundFACEs ( JB )% moveVector (:) = self % BoundFACEs ( JB )% center (:) - BoundFACEs_pre ( JB )% center (:) end do end if end subroutine subroutine adhesionCheckOnBound ( self , position , radius , cellID , stat ) !! 境界面への飛沫付着判定 class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self double precision , intent ( in ) :: position ( 3 ) !! 飛沫座標 double precision , intent ( in ) :: radius !! 飛沫半径 integer , intent ( in ) :: cellID !! 判定対象セルID integer , intent ( out ) :: stat !! 付着が起こらなければゼロ、起これば付着面の境界面IDが返る integer JJ , JB double precision :: r_vector ( 3 ), inner stat = 0 do JJ = 1 , size ( self % CELLs ( CellID )% boundFaceID ) JB = self % CELLs ( CellID )% boundFaceID ( JJ ) r_vector (:) = position (:) - self % BoundFACEs ( JB )% center (:) inner = dot_product ( r_vector (:), self % BoundFACEs ( JB )% normalVector (:)) !外向き法線ベクトルと位置ベクトルの内積は、平面からの飛び出し量に相当 if ( inner + radius > 0.d0 ) then !(飛び出し量+飛沫半径)がゼロ以上なら付着判定 stat = JB !付着した境界面番号 end if end do end subroutine subroutine point2cellVelocity ( self , pointVector ) !! 節点定義のベクトル場を、セル重心定義に換算 class ( FlowFieldUnstructuredGrid ) self real , intent ( in ) :: pointVector (:,:) !! 節点定義のベクトル配列（ベクトル長さ x 節点数） integer II , IIMX , n , ID , num_node if (. not . allocated ( self % CELLs )) then print * , '**MISS point2cellVelocity** CELL_ARRAY is not yet allocated.' return end if IIMX = size ( self % CELLs ) DO II = 1 , IIMX self % CELLs ( II )% flowVelocity (:) = 0.0 num_node = size ( self % CELLs ( II )% nodeID ) do n = 1 , num_node ID = self % CELLs ( II )% nodeID ( n ) self % CELLs ( II )% flowVelocity (:) = self % CELLs ( II )% flowVelocity (:) + pointVector (:, ID ) end do self % CELLs ( II )% flowVelocity (:) = self % CELLs ( II )% flowVelocity (:) / real ( num_node ) END DO end subroutine subroutine output_STL ( self , fname ) !! 境界面形状情報をSTL形式で出力 class ( FlowFieldUnstructuredGrid ) self character ( * ), intent ( in ) :: fname integer n_unit , JB , nodeID ( 3 ) real cross ( 3 ) print * , 'output_STL : ' , fname open ( newunit = n_unit , file = fname , status = 'replace' ) write ( n_unit , '(\"solid test\")' ) do JB = 1 , size ( self % BoundFACEs ) write ( n_unit , '(\" facet normal\", 3(X,F7.4))' ) self % BoundFACEs ( JB )% normalVector (:) nodeID = self % BoundFACEs ( JB )% nodeID (:) block real , dimension ( 3 ) :: a , b a = self % NODEs ( nodeID ( 2 ))% coordinate (:) - self % NODEs ( nodeID ( 1 ))% coordinate (:) b = self % NODEs ( nodeID ( 3 ))% coordinate (:) - self % NODEs ( nodeID ( 1 ))% coordinate (:) cross = cross_product ( a , b ) end block write ( n_unit , '(\" outer loop\")' ) !面の向きによって点の並びを変えないと表示が上手く行かない（？） if ( dot_product ( cross , self % BoundFACEs ( JB )% normalVector (:)) > 0. ) then write ( n_unit , '(\"  vertex\", 3(X,E11.4))' ) self % NODEs ( nodeID ( 1 ))% coordinate (:) write ( n_unit , '(\"  vertex\", 3(X,E11.4))' ) self % NODEs ( nodeID ( 2 ))% coordinate (:) write ( n_unit , '(\"  vertex\", 3(X,E11.4))' ) self % NODEs ( nodeID ( 3 ))% coordinate (:) else write ( n_unit , '(\"  vertex\", 3(X,E11.4))' ) self % NODEs ( nodeID ( 1 ))% coordinate (:) write ( n_unit , '(\"  vertex\", 3(X,E11.4))' ) self % NODEs ( nodeID ( 3 ))% coordinate (:) write ( n_unit , '(\"  vertex\", 3(X,E11.4))' ) self % NODEs ( nodeID ( 2 ))% coordinate (:) end if write ( n_unit , '(\" endloop\")' ) write ( n_unit , '(\" endfacet\")' ) end do write ( n_unit , '(\"endsolid test\")' ) close ( n_unit ) end subroutine subroutine solve_adjacencyOnFlowFieldUnstructuredGrid ( self ) !!境界面と隣接関係を解決し、結果を非構造格子クラスに格納 use adjacencySolver_m class ( FlowFieldUnstructuredGrid ) self integer i , j , num_adjacent , num_boundFace , num_node integer max_vertex integer , allocatable :: cellVertices (:,:) integer , allocatable :: adjacentCellIDArray (:,:) integer , allocatable :: cellBoundFaces (:,:) integer , allocatable :: triangleBoundFaceVertices (:,:) max_vertex = 0 do i = 1 , size ( self % CELLs ) num_node = size ( self % CELLs ( i )% nodeID (:)) max_vertex = max ( max_vertex , num_node ) !頂点数の最大値の探索 end do allocate ( cellVertices ( max_vertex , size ( self % CELLs )), source = None ) do i = 1 , size ( self % CELLs ) num_node = size ( self % CELLs ( i )% nodeID (:)) cellVertices ( 1 : num_node , i ) = self % CELLs ( i )% nodeID ( 1 : num_node ) end do call solve_BoundaryAndAdjacency ( cellVertices , cellBoundFaces , triangleBoundFaceVertices , adjacentCellIDArray ) allocate ( self % BoundFACEs ( size ( triangleBoundFaceVertices , dim = 2 ))) do j = 1 , size ( self % BoundFACEs ) self % BoundFACEs ( j )% nodeID = triangleBoundFaceVertices (:, j ) end do do i = 1 , size ( self % CELLs ) num_boundFace = count ( cellBoundFaces (:, i ) /= None ) self % CELLs ( i )% boundFaceID = cellBoundFaces ( 1 : num_boundFace , i ) num_adjacent = count ( adjacentCellIDArray (:, i ) /= None ) self % CELLs ( i )% adjacentCellID = adjacentCellIDArray ( 1 : num_adjacent , i ) end do end subroutine function extensionOf ( FileName ) result ( extension ) !! ファイル名の拡張子を返す character ( * ), intent ( in ) :: FileName character (:), allocatable :: extension extension = FileName ( index ( FileName , '.' , back = . true .) + 1 : ) end function function get_flowVelocityInCELL ( self , ID ) result ( velocity ) !! 指定IDにおけるセルの流速を返す class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self integer , intent ( in ) :: ID real velocity ( 3 ) velocity = self % CELLs ( ID )% flowVelocity end function function get_movementVectorOfBoundarySurface ( self , ID ) result ( vector ) !! 指定IDにおける境界面の移動量ベクトルを返す class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self integer , intent ( in ) :: ID real vector ( 3 ) vector = self % BoundFACEs ( ID )% moveVector (:) end function function get_cellCenterOf ( self , ID ) result ( center ) !! 指定IDにおけるセル重心 class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self integer , intent ( in ) :: ID real center ( 3 ) center = self % CELLs ( ID )% center end function function get_allOfCellCenters ( self ) result ( centers ) !! 全セルの重心座標を２次元配列で返す class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self real , allocatable :: centers (:,:) integer i , num_cell num_cell = size ( self % CELLs ) allocate ( centers ( 3 , num_cell )) do i = 1 , num_cell centers (:, i ) = self % CELLs ( i )% center end do end function function get_cellVerticesOf ( self , ID ) result ( vertices ) !! 指定IDのセルにおける頂点座標配列を返す !! ２次元配列：（xyz、頂点） class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self integer , intent ( in ) :: ID real , allocatable :: vertices (:,:) integer i , num_node , nodeID num_node = size ( self % CELLs ( ID )% nodeID ) allocate ( vertices ( 3 , num_node )) do i = 1 , num_node nodeID = self % CELLs ( ID )% nodeID ( i ) vertices (:, i ) = self % NODEs ( nodeID )% coordinate end do end function function get_gridInformation ( self , name ) result ( info ) !! 節点数もしくはセル数を取得 class ( FlowFieldUnstructuredGrid ), intent ( in ) :: self character ( * ), intent ( in ) :: name !! 'node' or 'cell' integer info select case ( name ) case ( 'node' ) info = size ( self % NODEs ) case ( 'cell' ) info = size ( self % CELLs ) end select end function end module unstructuredGrid_m","tags":"","loc":"sourcefile\\unstructuredgrid.f90.html"},{"title":"vector.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~vector.f90~~AfferentGraph sourcefile~vector.f90 vector.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~geometry.f90->sourcefile~vector.f90 sourcefile~dropletequation.f90 dropletEquation.f90 sourcefile~dropletequation.f90->sourcefile~vector.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~cellcentercalc_test.f90->sourcefile~geometry.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletequation.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~geometry_test.f90 geometry_test.f90 sourcefile~geometry_test.f90->sourcefile~geometry.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletgenerator.f90->sourcefile~dropletequation.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules vector_m Source Code vector.f90 Source Code module vector_m !!ベクトル（3要素の配列）を扱うモジュール implicit none private interface cross_product !!ベクトルの外積を返す module procedure cross_product_dble , cross_product_real end interface interface normalize_vector !!単位ベクトルを返す module procedure normalize_vector_dble , normalize_vector_real end interface public cross_product , normalize_vector public norm2_squared contains function cross_product_dble ( a , b ) result ( cross ) double precision , intent ( in ) :: a ( 3 ), b ( 3 ) double precision cross ( 3 ) cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function function cross_product_real ( a , b ) result ( cross ) real , intent ( in ) :: a ( 3 ), b ( 3 ) real cross ( 3 ) cross ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) cross ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) cross ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function function normalize_vector_dble ( a ) result ( normalized ) double precision , intent ( in ) :: a ( 3 ) double precision norm , normalized ( 3 ) norm = norm2 ( a ) normalized (:) = a (:) / norm end function function normalize_vector_real ( a ) result ( normalized ) real , intent ( in ) :: a ( 3 ) real norm , normalized ( 3 ) norm = norm2 ( a ) normalized (:) = a (:) / norm end function real function norm2_squared ( a ) !!ベクトルのL2ノルムの2乗を返す !!組み込み関数norm2より約5倍速い(かも) real , intent ( in ) :: a ( 3 ) norm2_squared = a ( 1 ) * a ( 1 ) + a ( 2 ) * a ( 2 ) + a ( 3 ) * a ( 3 ) end function end module vector_m","tags":"","loc":"sourcefile\\vector.f90.html"},{"title":"virusDroplet.f90 – Droplets Simulation","text":"Files dependent on this one sourcefile~~virusdroplet.f90~~AfferentGraph sourcefile~virusdroplet.f90 virusDroplet.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~virusdroplet.f90 sourcefile~initial_translate.f90 initial_translate.f90 sourcefile~initial_translate.f90->sourcefile~virusdroplet.f90 sourcefile~dropletgenerator.f90 dropletGenerator.f90 sourcefile~dropletgenerator.f90->sourcefile~virusdroplet.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~virusdroplet.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~dropletgenerator.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules virusDroplet_m Source Code virusDroplet.f90 Source Code module virusDroplet_m implicit none private integer , parameter :: statusCSV ( 4 ) = [ 0 , 1 , - 1 , - 2 ] type , public :: virusDroplet_t !! ウイルス飛沫構造体 double precision :: position ( 3 ), velocity ( 3 ) = 0.d0 double precision , private :: radius , radius_min , initialRadius , deadline integer , private :: status = 0 integer :: coalesID = 0 , refCellID = 0 , adhesBoundID = 0 contains procedure :: isFloating => isDropletFloating procedure :: coalescenceID => dropletCoalescneceID procedure stop_droplet , isEvaporating , evaporation , get_radius end type public read_backup public dropletCounter , dropletIDinState , dropletIDinBox public set_dropletStatus , set_initialRadius , set_radiusLowerLimit , set_virusDeadline public survival_check public output_backup , output_droplet_CSV , output_droplet_VTK public get_dropletsArea , dropletTotalVolume public coalescence_check contains logical function isDropletFloating ( self ) !! 飛沫が浮遊しているか否かを返す class ( virusDroplet_t ), intent ( in ) :: self if ( self % status == 0 ) then isDropletFloating = . true . else isDropletFloating = . false . end if end function double precision function get_radius ( self ) !! 現時刻の飛沫半径を返す class ( virusDroplet_t ), intent ( in ) :: self get_radius = self % radius end function logical function isEvaporating ( self ) !! 飛沫が限界まで蒸発したか否かを返す class ( virusDroplet_t ), intent ( in ) :: self if ( self % radius > self % radius_min ) then isEvaporating = . true . else isEvaporating = . false . end if end function subroutine evaporation ( self , dr ) !! 蒸発の処理を行う class ( virusDroplet_t ) self double precision , intent ( in ) :: dr !!半径変化量（蒸発ならマイナスの値を指定） self % radius = max ( self % radius + dr , self % radius_min ) end subroutine integer function dropletCoalescneceID ( self ) !! 合体飛沫の合体先のIDを返す class ( virusDroplet_t ), intent ( in ) :: self dropletCoalescneceID = self % coalesID end function integer function get_statusNumber ( name ) !! 飛沫の状態を対応する整数値で返す character ( * ), intent ( in ) :: name !! 状態 select case ( name ) case ( 'floating' ) get_statusNumber = 0 case ( 'adhesion' ) get_statusNumber = 1 case ( 'death' ) get_statusNumber = - 1 case ( 'coalescence' ) get_statusNumber = - 2 case ( 'nonActive' ) get_statusNumber = - 99 case default print * , '**ERROR [statusNumber] : ' , name , ' is not found.**' error stop end select end function subroutine survival_check ( droplets , time ) !! 飛沫の不活性化判定 ! use terminalControler_m type ( virusDroplet_t ) droplets (:) double precision , intent ( in ) :: time !! 現在時刻（無次元） integer vn ! double precision rand ! double precision, save :: death_rate = 0.d0 do vn = 1 , size ( droplets ) !浮遊中であり、時刻が寿命以上であれば不活性化 if (( droplets ( vn )% isFloating ()) . and . ( time > droplets ( vn )% deadline )) then call droplets ( vn )% stop_droplet ( status = 'death' ) end if end do ! death_rate = death_rate + dble(vfloat)*(survival_rate(timeStep) - survival_rate(timeStep+1))    !このステップで死滅すべき飛沫数 ! do while(death_rate >= 1.0d0) !     call random_number(rand)    !死滅IDは乱数で決まる !     vn = int(num_droplets*rand) !     if(vn < 1) cycle !     if (droplets(vn)%status == 0) then !浮遊粒子からのみ除去する !         droplets(vn)%status = -1 !         ! droplets(vn)%position(:) = MIN_CDN(:) - 1.0d0 !計算エリア外に配置（不要かも） !         droplets(vn)%velocity(:) = 0.0d0 !         death_rate = death_rate - 1.0d0 !     end if ! end do end subroutine integer function dropletCounter ( droplets , name ) !! 指定された状態にある飛沫数をカウント type ( virusDroplet_t ) droplets (:) character ( * ), intent ( in ) :: name !! キーワード（total, floating, etc.） select case ( name ) case ( 'total' ) dropletCounter = size ( droplets ) case default dropletCounter = count ( droplets (:)% status == get_statusNumber ( name )) end select end function function dropletIDinBox ( droplets , min_cdn , max_cdn , status ) result ( ID_array ) !! 直方体領域内の飛沫のID配列を返す type ( virusDroplet_t ) droplets (:) double precision , intent ( in ) :: min_cdn ( 3 ) !! 直方体領域の最小座標 double precision , intent ( in ) :: max_cdn ( 3 ) !! 直方体領域の最大座標 integer , intent ( in ), optional :: status !! 状態 double precision position ( 3 ) integer , allocatable :: ID_array (:) integer i , id_array_ ( size ( droplets )), cnt cnt = 0 if ( present ( status )) then do i = 1 , size ( droplets ) if ( droplets ( i )% status /= status ) cycle position (:) = droplets ( i )% position (:) if ( (( min_cdn ( 1 ) <= position ( 1 )) . and . ( position ( 1 ) <= max_cdn ( 1 ))) & . and .(( min_cdn ( 2 ) <= position ( 2 )) . and . ( position ( 2 ) <= max_cdn ( 2 ))) & . and .(( min_cdn ( 3 ) <= position ( 3 )) . and . ( position ( 3 ) <= max_cdn ( 3 ))) ) then cnt = cnt + 1 id_array_ ( cnt ) = i end if end do else do i = 1 , size ( droplets ) position (:) = droplets ( i )% position (:) if ( (( min_cdn ( 1 ) <= position ( 1 )) . and . ( position ( 1 ) <= max_cdn ( 1 ))) & . and .(( min_cdn ( 2 ) <= position ( 2 )) . and . ( position ( 2 ) <= max_cdn ( 2 ))) & . and .(( min_cdn ( 3 ) <= position ( 3 )) . and . ( position ( 3 ) <= max_cdn ( 3 ))) ) then cnt = cnt + 1 id_array_ ( cnt ) = i end if end do end if ID_array = id_array_ (: cnt ) end function double precision function dropletTotalVolume ( droplets ) !! 配列内の全飛沫の総体積（無次元）を計算 type ( virusDroplet_t ) droplets (:) integer i double precision , parameter :: PI = acos ( - 1.d0 ) dropletTotalVolume = 0.d0 do i = 1 , size ( droplets ) dropletTotalVolume = dropletTotalVolume + droplets ( i )% initialRadius ** 3 end do dropletTotalVolume = dropletTotalVolume * 4.d0 / 3.d0 * PI end function function dropletIDinState ( droplets , status ) result ( ID_array ) !! 任意の状態の飛沫のID配列を返す type ( virusDroplet_t ) droplets (:) character ( * ), intent ( in ) :: status integer , allocatable :: ID_array (:) integer i , cnt , statusNumber cnt = 0 statusNumber = get_statusNumber ( status ) allocate ( ID_array ( count ( droplets (:)% status == statusNumber ))) do i = 1 , size ( droplets ) if ( droplets ( i )% status == statusNumber ) then cnt = cnt + 1 ID_array ( cnt ) = i end if end do end function subroutine get_dropletsArea ( droplets , AreaMin , AreaMax ) !! 飛沫配列内の飛沫の座標の最大最小を返す type ( virusDroplet_t ) droplets (:) double precision , intent ( out ) :: AreaMin ( 3 ), AreaMax ( 3 ) integer i , m AreaMin (:) = 1.d9 AreaMax (:) = - 1.d9 do m = 1 , size ( droplets ) if ( droplets ( m )% status == 0 ) then do i = 1 , 3 AreaMin ( i ) = min ( droplets ( m )% position ( i ), AreaMin ( i )) AreaMax ( i ) = max ( droplets ( m )% position ( i ), AreaMax ( i )) end do end if end do end subroutine subroutine coalescence_check ( droplets , stat ) !! 合体判定 type ( virusDroplet_t ) droplets (:) integer , intent ( out ), optional :: stat integer d1 , d2 , num_droplets , num_coales double precision :: distance , r1 , r2 num_coales = 0 num_droplets = size ( droplets ) !$OMP parallel do private(distance, r1, r2) drop1 : do d1 = 1 , num_droplets - 1 if ( droplets ( d1 )% status /= 0 ) cycle drop1 r1 = droplets ( d1 )% radius drop2 : do d2 = d1 + 1 , num_droplets if ( droplets ( d2 )% status /= 0 ) cycle drop2 r2 = droplets ( d2 )% radius distance = norm2 ( droplets ( d2 )% position (:) - droplets ( d1 )% position (:)) if (( r1 + r2 ) >= distance ) then ! print*, d1, 'and', d2, 'coalesce!' if ( r1 >= r2 ) then call coalescence ( droplets ( d1 ), droplets ( d2 ), d1 ) else call coalescence ( droplets ( d2 ), droplets ( d1 ), d2 ) end if num_coales = num_coales + 1 end if end do drop2 end do drop1 !$OMP end parallel do if ( present ( stat )) stat = num_coales end subroutine subroutine coalescence ( droplet1 , droplet2 , baseID ) !! 合体処理 type ( virusDroplet_t ), intent ( inout ) :: droplet1 , droplet2 integer , intent ( in ) :: baseID !! 合体先（ベースとなる飛沫）のID double precision r3_1 , r3_2 , position_c ( 3 ), velocity_c ( 3 ) r3_1 = droplet1 % radius ** 3 r3_2 = droplet2 % radius ** 3 position_c (:) = ( r3_1 * droplet1 % position (:) + r3_2 * droplet2 % position (:)) / ( r3_1 + r3_2 ) velocity_c (:) = ( r3_1 * droplet1 % velocity (:) + r3_2 * droplet2 % velocity (:)) / ( r3_1 + r3_2 ) droplet1 % radius = ( r3_1 + r3_2 ) ** ( 1.d0 / 3.d0 ) droplet1 % position (:) = position_c (:) droplet1 % velocity (:) = velocity_c (:) droplet1 % radius_min = ( droplet1 % radius_min ** 3 + droplet2 % radius_min ** 3 ) ** ( 1.d0 / 3.d0 ) ! droplet1%initialRadius = radius_afterCoalescence(droplet1%initialRadius, droplet2%initialRadius) droplet2 % radius = 0.d0 droplet2 % position (:) = position_c (:) droplet2 % velocity (:) = velocity_c (:) droplet2 % status = get_statusNumber ( 'coalescence' ) droplet2 % coalesID = baseID end subroutine subroutine output_backup ( droplets , fname ) !! backupファイルの出力。 !! 配列をループ使わずそのまま書き出すほうが多分ファイルサイズ効率が良いので、いつか修正したい。 type ( virusDroplet_t ) droplets (:) character ( * ), intent ( in ) :: fname integer i , n_unit , num_drop num_drop = size ( droplets (:)) open ( newunit = n_unit , form = 'unformatted' , file = fname , status = 'replace' ) write ( n_unit ) num_drop do i = 1 , num_drop write ( n_unit ) droplets ( i ) end do close ( n_unit ) print * , 'writeOUT:' , trim ( fname ) end subroutine subroutine output_droplet_VTK ( droplets , fname , deadline ) !! VTK形式でファイル出力 type ( virusDroplet_t ) droplets (:) character ( * ), intent ( in ) :: fname logical , optional :: deadline integer vn , n_unit , num_drop num_drop = size ( droplets ) open ( newunit = n_unit , file = fname , status = 'replace' ) !ここで出力ファイルを指定 write ( n_unit , '(A)' ) '# vtk DataFile Version 2.0' !ファイルの始め4行は文字列（決まり文句） write ( n_unit , '(A)' ) 'FOR TEST' write ( n_unit , '(A)' ) 'ASCII' write ( n_unit , '(A)' ) 'DATASET UNSTRUCTURED_GRID' write ( n_unit , '(A,I0,A)' ) 'POINTS ' , num_drop , ' float' !節点の数 DO vn = 1 , num_drop !節点の数だけループ write ( n_unit , '(3(f10.5,2X))' ) droplets ( vn )% position (:) !節点の座標（左から順にx,y,z） END DO write ( n_unit , '()' ) !改行 write ( n_unit , '(A,I0,2X,I0)' ) 'CELLS ' , num_drop , num_drop * 2 !セルの数、セルの数×2 DO vn = 1 , num_drop !セルの数だけループ write ( n_unit , '(I0,2X,I0)' ) 1 , vn - 1 !セルを構成する点の数（セル形状が点なので1）、その点のID END DO write ( n_unit , '()' ) !改行 write ( n_unit , '(A,I0)' ) 'CELL_TYPES ' , num_drop DO vn = 1 , num_drop !セルの数だけループ write ( n_unit , '(I0)' ) 1 !セルの形状（1は点であることを意味する） END DO write ( n_unit , '()' ) !改行 write ( n_unit , '(A,I0)' ) 'CELL_DATA ' , num_drop !ここからセルのデータという合図、セルの数 write ( n_unit , '(A)' ) 'SCALARS Status int' !飛沫の状態(0:浮遊、1:付着、2:回収) write ( n_unit , '(A)' ) 'LOOKUP_TABLE default' DO vn = 1 , num_drop !セルの数だけループ write ( n_unit , '(I0)' ) droplets ( vn )% status !飛沫の状態(0:浮遊、1:付着、2:回収) END DO write ( n_unit , '(A)' ) 'SCALARS Diameter float' !飛沫の直径 write ( n_unit , '(A)' ) 'LOOKUP_TABLE default' DO vn = 1 , num_drop !セルの数だけループ write ( n_unit , '(e10.3)' ) droplets ( vn )% radius * 2.0d0 !飛沫の直径 END DO if ( present ( deadline )) then if ( deadline ) then write ( n_unit , '(A)' ) 'SCALARS Deadline float' write ( n_unit , '(A)' ) 'LOOKUP_TABLE default' DO vn = 1 , num_drop !セルの数だけループ write ( n_unit , '(e10.3)' ) droplets ( vn )% deadline END DO end if end if write ( n_unit , '(A)' ) 'VECTORS Velocity float' !最後に飛沫の速度 DO vn = 1 , num_drop !セルの数だけループ write ( n_unit , '(3(f10.5,2X))' ) droplets ( vn )% velocity (:) !飛沫の速度 END DO close ( n_unit ) print * , 'writeOUT:' , trim ( fname ) end subroutine subroutine output_droplet_CSV ( droplets , fname , time , initial ) !! CSV形式で時系列データ出力 type ( virusDroplet_t ) droplets (:) character ( * ), intent ( in ) :: fname double precision , intent ( in ) :: time logical , intent ( in ) :: initial integer n_unit , J if ( initial ) then !初回ならファイル新規作成 open ( newunit = n_unit , file = fname , status = 'replace' ) else open ( newunit = n_unit , file = fname , action = 'write' , status = 'old' , position = 'append' ) end if write ( n_unit , '(*(g0:,\",\"))' ) real ( time ), ( count ( droplets (:)% status == statusCSV ( J )), J = 1 , size ( statusCSV )) close ( n_unit ) end subroutine ! subroutine append_dropletGroup(droplets, dGroup) !     type(virusDroplet_t) droplets(:) !     type(DropletGroup), intent(in) :: dGroup !     droplets = [droplets, dGroup%droplet] ! end subroutine function read_backup ( fname ) result ( droplets ) !! backupファイルを読み込み、飛沫配列を返す character ( * ), intent ( in ) :: fname type ( virusDroplet_t ), allocatable :: droplets (:) integer i , n_unit , num_drop print * , 'READ : ' , trim ( fname ) open ( newunit = n_unit , form = 'unformatted' , file = fname , status = 'old' , action = 'read' ) read ( n_unit ) num_drop allocate ( droplets ( num_drop )) do i = 1 , num_drop read ( n_unit ) droplets ( i ) end do close ( n_unit ) end function function read_droplet_VTK ( fname ) result ( droplets ) !! VTKファイルを読み込み、飛沫配列を返す implicit none character ( * ), intent ( in ) :: fname type ( virusDroplet_t ), allocatable :: droplets (:) double precision , allocatable :: diameter (:) integer vn , n_unit , num_drop character ( 10 ) str print * , 'READ : ' , fname open ( newunit = n_unit , file = fname , status = 'old' , action = 'read' ) read ( n_unit , '()' ) read ( n_unit , '()' ) read ( n_unit , '()' ) read ( n_unit , '()' ) read ( n_unit , * ) str , num_drop allocate ( droplets ( num_drop ), diameter ( num_drop )) DO vn = 1 , num_drop read ( n_unit , * ) droplets ( vn )% position (:) END DO read ( n_unit , '()' ) read ( n_unit , '()' ) DO vn = 1 , num_drop read ( n_unit , '()' ) END DO read ( n_unit , '()' ) read ( n_unit , '()' ) DO vn = 1 , num_drop read ( n_unit , '()' ) END DO read ( n_unit , '()' ) read ( n_unit , '()' ) !CELL_DATA read ( n_unit , '()' ) read ( n_unit , '()' ) DO vn = 1 , num_drop read ( n_unit , * ) droplets ( vn )% status END DO read ( n_unit , '()' ) read ( n_unit , '()' ) DO vn = 1 , num_drop read ( n_unit , * ) diameter ( vn ) END DO read ( n_unit , '()' ) read ( n_unit , '()' ) DO vn = 1 , num_drop read ( n_unit , * ) droplets ( vn )% deadline END DO read ( n_unit , '()' ) DO vn = 1 , num_drop read ( n_unit , * ) droplets ( vn )% velocity (:) END DO close ( n_unit ) droplets (:)% radius = diameter (:) * 0.5d0 end function subroutine stop_droplet ( self , status ) !! 飛沫を静止させる class ( virusDroplet_t ) self character ( * ), intent ( in ), optional :: status self % velocity (:) = 0.0d0 if ( present ( status )) then self % status = get_statusNumber ( status ) else self % status = 1 end if end subroutine subroutine set_initialRadius ( droplets , radius ) !! 飛沫の初期半径を配列からセットする type ( virusDroplet_t ) droplets (:) double precision , intent ( in ) :: radius (:) droplets (:)% initialRadius = radius (:) droplets (:)% radius = droplets (:)% initialRadius end subroutine subroutine set_radiusLowerLimit ( droplets , lowerLimitRatio ) !! 飛沫の蒸発限界半径をセットする type ( virusDroplet_t ) droplets (:) double precision , intent ( in ) :: lowerLimitRatio !! 限界半径と初期半径の比 droplets (:)% radius_min = droplets (:)% initialRadius * lowerLimitRatio end subroutine subroutine set_virusDeadline ( droplets , deadline ) !! 飛沫の寿命を配列からセットする type ( virusDroplet_t ) droplets (:) double precision , intent ( in ) :: deadline (:) droplets (:)% deadline = deadline (:) end subroutine subroutine set_dropletStatus ( droplets , status , ID ) !! 飛沫の状態を一気にセットする !! 特定のIDの飛沫だけセットしたい場合は、ID配列を引数に渡す type ( virusDroplet_t ) droplets (:) character ( * ), intent ( in ) :: status integer , intent ( in ), optional :: ID (:) if ( present ( ID )) then droplets ( ID )% status = get_statusNumber ( status ) else droplets (:)% status = get_statusNumber ( status ) end if end subroutine end module virusDroplet_m","tags":"","loc":"sourcefile\\virusdroplet.f90.html"},{"title":"vtkMesh_operator.f90 – Droplets Simulation","text":"This file depends on sourcefile~~vtkmesh_operator.f90~~EfferentGraph sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~vtkmesh_operator.f90~~AfferentGraph sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~boxflowfield.f90 boxFlowField.f90 sourcefile~boxflowfield.f90->sourcefile~vtkmesh_operator.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~boxflowfield.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletcount.f90 dropletCount.f90 sourcefile~dropletcount.f90->sourcefile~vtkmesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~cube2usg.f90 CUBE2USG.f90 sourcefile~cube2usg.f90->sourcefile~vtkmesh_operator.f90 sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~dropletmotionsimulation.f90 dropletMotionSimulation.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90 flow_field.f90 sourcefile~dropletmotionsimulation.f90->sourcefile~flow_field.f90 sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~flow_field.f90->sourcefile~unstructuredgrid.f90 sourcefile~main.f90 MAIN.f90 sourcefile~main.f90->sourcefile~dropletmotionsimulation.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules VTK_operator_m Source Code vtkMesh_operator.f90 Source Code module VTK_operator_m use unstructuredElement_m implicit none private type , extends ( cell_t ) :: cell_inVTK_t integer , private :: n_TYPE end type type , public :: UnstructuredGrid_inVTK type ( node_t ), allocatable :: node_array (:) type ( cell_inVTK_t ), allocatable :: cell_array (:) contains procedure :: read => read_UnstructuredGrid_inVTK procedure :: output => output_UnstructuredGrid_inVTK procedure get_numCell , get_numNode , get_nodeCoordinate , get_cellVertices procedure set_nodeCoordinate , set_cellVertices end type public UnstructuredGrid_inVTK_ contains type ( UnstructuredGrid_inVTK ) function UnstructuredGrid_inVTK_ ( cdn , vertices , types ) real , intent ( in ) :: cdn (:,:) integer , intent ( in ) :: vertices (:,:), types (:) call UnstructuredGrid_inVTK_ % set_nodeCoordinate ( cdn ) call UnstructuredGrid_inVTK_ % set_cellVertices ( vertices , types ) end function subroutine read_UnstructuredGrid_inVTK ( self , FNAME , action , cellScalar , cellVector ) class ( UnstructuredGrid_inVTK ) self character ( * ), intent ( in ) :: FNAME character ( * ), intent ( in ), optional :: action real , allocatable , intent ( out ), optional :: cellScalar (:), cellVector (:,:) integer II , KK , num_node , n_unit , KKMX , IIMX , ios integer l , nodeID ( 8 ) character AAA * 7 , str * 99 logical dataOnly dataOnly = . false . if ( present ( action )) then if ( action == 'dataOnly' ) dataOnly = . true . end if print * , 'READ_VTK:' , FNAME open ( newunit = n_unit , FILE = FNAME , status = 'old' , action = 'read' ) if ( dataOnly ) then do while ( index ( AAA , 'CELL_DATA' ) == 0 ) read ( n_unit , '(A)' ) AAA end do else read ( n_unit , '()' ) read ( n_unit , '()' ) read ( n_unit , '()' ) read ( n_unit , '()' ) read ( n_unit , * ) AAA , KKMX allocate ( self % node_array ( KKMX )) DO KK = 1 , KKMX read ( n_unit , * ) self % node_array ( KK )% coordinate (:) END DO read ( n_unit , '()' ) read ( n_unit , * ) AAA , IIMX allocate ( self % cell_array ( IIMX )) DO II = 1 , IIMX read ( n_unit , '(A)' ) str !一旦1行丸ごと読む read ( str , * ) num_node read ( str , * ) num_node , ( nodeID ( l ), l = 1 , num_node ) self % cell_array ( II )% nodeID = nodeID (: num_node ) + 1 END DO read ( n_unit , '()' ) read ( n_unit , '()' ) !CELL_TYPES DO II = 1 , IIMX read ( n_unit , * ) self % cell_array ( II )% n_TYPE END DO if ((. not . present ( cellScalar )) . and . (. not . present ( cellVector ))) return read ( n_unit , '()' ) read ( n_unit , '()' ) !CELL_DATA end if do read ( n_unit , '(A)' , iostat = ios ) AAA if ( ios /= 0 ) exit select case ( AAA ) case ( 'SCALARS' ) read ( n_unit , '()' ) if ( present ( cellScalar )) then allocate ( cellScalar ( IIMX )) DO II = 1 , IIMX read ( n_unit , * ) cellScalar ( II ) END DO else DO II = 1 , IIMX read ( n_unit , '()' ) END DO end if case ( 'VECTORS' ) if ( present ( cellVector )) then allocate ( cellVector ( 3 , IIMX )) DO II = 1 , IIMX read ( n_unit , * ) cellVector (:, II ) END DO end if exit end select end do close ( n_unit ) end subroutine subroutine output_UnstructuredGrid_inVTK ( self , FNAME , cellScalar , cellVector , scalarName , vectorName ) class ( UnstructuredGrid_inVTK ) self character ( * ), intent ( in ) :: FNAME real , intent ( in ), optional :: cellScalar (:), cellVector (:,:) character ( * ), intent ( in ), optional :: scalarName , vectorName integer II , KK , n_unit , KKMX , IIMX , IITOTAL integer , allocatable :: nodeID (:) print * , 'OUTPUT_VTK:' , FNAME open ( newunit = n_unit , FILE = FNAME , STATUS = 'replace' ) write ( n_unit , '(A)' ) '# vtk DataFile Version 2.0' write ( n_unit , '(A)' ) 'Header' write ( n_unit , '(A)' ) 'ASCII' write ( n_unit , '(A)' ) 'DATASET UNSTRUCTURED_GRID' KKMX = size ( self % node_array ) write ( n_unit , '(A,1x,I0,1x,A)' ) 'POINTS' , KKMX , 'float' DO KK = 1 , KKMX write ( n_unit , '(3(e12.5,2X))' ) self % node_array ( KK )% coordinate (:) END DO write ( n_unit , '()' ) IIMX = size ( self % cell_array ) IITOTAL = 0 do II = 1 , IIMX IITOTAL = IITOTAL + size ( self % cell_array ( II )% nodeID ) + 1 end do write ( n_unit , '(A,I0,2X,I0)' ) 'CELLS ' , IIMX , IITOTAL DO II = 1 , IIMX nodeID = self % cell_array ( II )% nodeID (:) - 1 write ( n_unit , '(*(g0:,\" \"))' ) size ( nodeID ), nodeID (:) END DO write ( n_unit , '()' ) write ( n_unit , '(A,I0)' ) 'CELL_TYPES ' , IIMX DO II = 1 , IIMX write ( n_unit , '(I0)' ) self % cell_array ( II )% n_TYPE END DO if ( present ( cellScalar ) . or . present ( cellVector )) then write ( n_unit , '()' ) write ( n_unit , '(A,I0)' ) 'CELL_DATA ' , IIMX if ( present ( cellScalar )) then if ( present ( scalarName )) then write ( n_unit , '(A)' ) 'SCALARS ' // scalarName // ' float' else write ( n_unit , '(A)' ) 'SCALARS scalar float' end if write ( n_unit , '(A)' ) 'LOOKUP_TABLE default' DO II = 1 , IIMX write ( n_unit , '(e12.5)' ) cellScalar ( II ) END DO end if if ( present ( cellVector )) then if ( present ( vectorName )) then write ( n_unit , '(A)' ) 'VECTORS ' // vectorName // ' float' else write ( n_unit , '(A)' ) 'VECTORS vector float' end if DO II = 1 , IIMX write ( n_unit , '(3(e12.5,2X))' ) cellVector (:, II ) END DO end if end if close ( n_unit ) end subroutine integer function get_numNode ( self ) class ( UnstructuredGrid_inVTK ), intent ( in ) :: self get_numNode = size ( self % node_array ) end function integer function get_numCell ( self ) class ( UnstructuredGrid_inVTK ), intent ( in ) :: self get_numCell = size ( self % cell_array ) end function function get_nodeCoordinate ( self ) result ( cdn ) class ( UnstructuredGrid_inVTK ), intent ( in ) :: self real , allocatable :: cdn (:,:) integer k , num_node num_node = size ( self % node_array ) allocate ( cdn ( 3 , num_node )) do k = 1 , num_node cdn (:, k ) = self % node_array ( k )% coordinate (:) end do end function subroutine get_cellVertices ( self , vertices , types ) class ( UnstructuredGrid_inVTK ), intent ( in ) :: self integer , allocatable , intent ( out ) :: vertices (:,:), types (:) integer i , num_cell , num_node num_cell = size ( self % cell_array ) allocate ( vertices ( 6 , num_cell )) allocate ( types ( num_cell )) do i = 1 , num_cell num_node = size ( self % cell_array ( i )% nodeID ) vertices ( 1 : num_node , i ) = self % cell_array ( i )% nodeID (:) types ( i ) = self % cell_array ( i )% n_TYPE end do end subroutine subroutine set_nodeCoordinate ( self , cdn ) class ( UnstructuredGrid_inVTK ) self real , intent ( in ) :: cdn (:,:) integer k , num_node num_node = size ( cdn , dim = 2 ) allocate ( self % node_array ( num_node )) do k = 1 , num_node self % node_array ( k )% coordinate (:) = cdn (:, k ) end do end subroutine subroutine set_cellVertices ( self , vertices , types ) class ( UnstructuredGrid_inVTK ) self integer , intent ( in ) :: vertices (:,:), types (:) integer i , num_cell , num_node num_cell = size ( vertices , dim = 2 ) allocate ( self % cell_array ( num_cell )) do i = 1 , num_cell select case ( types ( i )) case ( 10 ) !tetra num_node = 4 case ( 11 ) !hexa num_node = 8 case ( 13 ) !prism num_node = 6 case ( 14 ) !pyramid num_node = 5 end select self % cell_array ( i )% nodeID = vertices ( 1 : num_node , i ) self % cell_array ( i )% n_TYPE = types ( i ) end do end subroutine end module VTK_operator_m","tags":"","loc":"sourcefile\\vtkmesh_operator.f90.html"},{"title":"cellCenterCalc_test.f90 – Droplets Simulation","text":"This file depends on sourcefile~~cellcentercalc_test.f90~~EfferentGraph sourcefile~cellcentercalc_test.f90 cellCenterCalc_test.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~cellcentercalc_test.f90->sourcefile~geometry.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~cellcentercalc_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~vector.f90 vector.f90 sourcefile~geometry.f90->sourcefile~vector.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~array.f90 array.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~scffile_reader.f90 SCFfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~scffile_reader.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~scffile_reader.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs cellCenterCalc_test Source Code cellCenterCalc_test.f90 Source Code !>セル重心計算がうまく行っているかをテストする。 !>具体的には、重心をテトラの内外判定にかけている。 program cellCenterCalc_test use unstructuredGrid_m use geometry_m implicit none type ( FlowFieldUnstructuredGrid ) grid ! character(17), parameter :: cellCenterFName = 'CellCenters.array' real , allocatable :: centers (:,:), vertices (:,:) real center ( 3 ) integer i , imax integer n call grid % setupWithFlowFieldFile ( 'VTK/sax_flow.vtk' ) !このサブルーチン内で重心計算も行われる imax = grid % get_info ( 'cell' ) centers = grid % get_allOfCellCenters () do i = 1 , imax vertices = grid % get_cellVerticesOf ( i ) center = centers (:, i ) !重心がテトラ内部になければエラー if (. not . insideJudgment_tetra ( vertices , center )) then print '(\"============================\")' block real vol_sum , volume call insideJudgment_tetra_check ( vertices , center , vol_sum , volume ) print * , vol_sum , volume end block print '(\"============================\")' print * , i , imax print '(\"============================\")' do n = 1 , size ( vertices , dim = 2 ) print * , vertices (:, n ) end do print '(\"============================\")' print * , center print '(\"============================\")' error stop end if end do ! contains ! subroutine output_cellCenter(dir) !     use array_m !     character(*), intent(in) :: dir !     real, allocatable :: centers(:,:) !     integer num_cell !     num_cell = grid%get_info('cell') !     centers = grid%get_cellCenters() !     call output_2dArray_asBinary(dir//cellCenterFName, centers) ! end subroutine end program cellCenterCalc_test","tags":"","loc":"sourcefile\\cellcentercalc_test.f90.html"},{"title":"geometry_test.f90 – Droplets Simulation","text":"This file depends on sourcefile~~geometry_test.f90~~EfferentGraph sourcefile~geometry_test.f90 geometry_test.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~geometry_test.f90->sourcefile~geometry.f90 sourcefile~vector.f90 vector.f90 sourcefile~geometry.f90->sourcefile~vector.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs geometry_test Source Code geometry_test.f90 Source Code !>テトラ内外判定をテストする。 !>乱数で発生させた点群に対して判定を行う。 !>テスト用のテトラは単純な形状で、平面の方程式から即座に内外判定が行えるので、これと比較してテストする。 program geometry_test use geometry_m implicit none !テスト用テトラ real , parameter :: tetra ( 3 , 4 ) = reshape ([& 0. , 0. , 0. , & 1. , 0. , 0. , & 0. , 1. , 0. , & 0. , 0. , 1. & ], shape ( tetra )) integer , parameter :: imax = 10000 real rand ( 3 , imax ), point ( 3 ) logical plane_judge , tetra_judge integer i call random_number ( rand ) do i = 1 , imax point = rand (:, i ) plane_judge = ( point ( 3 ) < plane_equation ( point ( 1 ), point ( 2 ))) !z座標が斜面より下であればテトラ内部 tetra_judge = insideJudgment_tetra ( tetra , point (:)) if (( plane_judge . neqv . tetra_judge )) then !テトラの斜面の方程式による内外判定と、テトラの一般的な内外判定の結果が一致しなければエラー print * , i , point , plane_judge , tetra_judge error stop end if end do contains !>テスト用テトラの斜面の方程式 function plane_equation ( x , y ) result ( z ) real , intent ( in ) :: x , y real z z = 1. - x - y end function end program geometry_test","tags":"","loc":"sourcefile\\geometry_test.f90.html"},{"title":"kdTree_test.f90 – Droplets Simulation","text":"This file depends on sourcefile~~kdtree_test.f90~~EfferentGraph sourcefile~kdtree_test.f90 kdTree_test.f90 sourcefile~kdtree.f90 kdTree.f90 sourcefile~kdtree_test.f90->sourcefile~kdtree.f90 sourcefile~path_operator.f90 path_operator.f90 sourcefile~kdtree_test.f90->sourcefile~path_operator.f90 sourcefile~unstructuredgrid.f90 unstructuredGrid.f90 sourcefile~kdtree_test.f90->sourcefile~unstructuredgrid.f90 sourcefile~sort.f90 sort.f90 sourcefile~kdtree.f90->sourcefile~sort.f90 sourcefile~terminalcontroler.f90 terminalControler.f90 sourcefile~kdtree.f90->sourcefile~terminalcontroler.f90 sourcefile~unstructuredgrid.f90->sourcefile~kdtree.f90 sourcefile~unstructuredgrid.f90->sourcefile~path_operator.f90 sourcefile~vector.f90 vector.f90 sourcefile~unstructuredgrid.f90->sourcefile~vector.f90 sourcefile~unstructuredelement.f90 unstructuredElement.f90 sourcefile~unstructuredgrid.f90->sourcefile~unstructuredelement.f90 sourcefile~vtkmesh_operator.f90 vtkMesh_operator.f90 sourcefile~unstructuredgrid.f90->sourcefile~vtkmesh_operator.f90 sourcefile~sctfile_reader.f90 SCTfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~sctfile_reader.f90 sourcefile~adjacency_solver.f90 adjacency_solver.f90 sourcefile~unstructuredgrid.f90->sourcefile~adjacency_solver.f90 sourcefile~array.f90 array.f90 sourcefile~unstructuredgrid.f90->sourcefile~array.f90 sourcefile~scffile_reader.f90 SCFfile_reader.f90 sourcefile~unstructuredgrid.f90->sourcefile~scffile_reader.f90 sourcefile~vtkmesh_operator.f90->sourcefile~unstructuredelement.f90 sourcefile~adjacency_solver.f90->sourcefile~terminalcontroler.f90 sourcefile~scffile_reader.f90->sourcefile~terminalcontroler.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs kdTree_test Source Code kdTree_test.f90 Source Code program kdTree_test !!kdTreeによる探索結果と、厳密なnearest探索結果が一致するかどうかをテスト use kdTree_m use path_operator_m use unstructuredGrid_m implicit none type ( FlowFieldUnstructuredGrid ) grid real , allocatable :: xyz (:,:) type ( kdTree ) kd_tree ! integer n_unit integer iimx character (:), allocatable :: vtkFName , kd_treeFName character ( 10 ), parameter :: output_dir = 'test_check' logical existance vtkFName = \"VTK/sample.vtk\" kd_treeFName = \"kdTreeOfsample.txt\" call make_directory ( output_dir ) call grid % setupWithFlowFieldFile ( vtkFName ) iimx = grid % get_info ( 'cell' ) xyz = grid % get_allOfCellCenters () inquire ( file = output_dir // '/' // kd_treeFName , exist = existance ) if (. not . existance ) then kd_tree = kdTree_ ( xyz ) call kd_tree % saveAsDOT ( xyz , output_dir // '/kdTree.dot' ) call kd_tree % saveAsTXT ( output_dir // '/' // kd_treeFName ) else call kd_tree % read_kdTree ( output_dir // '/' // kd_treeFName ) end if call test contains subroutine test !!乱数で発生させた点に対して、kdTreeによる探索結果と、厳密なnearest探索結果が一致するかどうかをテスト integer , parameter :: num_test = 10000 integer n integer result_exact , result_kdTree real , dimension ( 3 ) :: min_cdn , max_cdn , delta , rand , point call grid % get_MinMaxOfGrid ( min_cdn , max_cdn ) delta = max_cdn - min_cdn do n = 1 , num_test call random_number ( rand ) point = min_cdn + delta * rand ! print*, point result_exact = grid % nearest_search_exact ( point ) call kd_tree % search ( xyz , point , result_kdTree ) if ( result_exact /= result_kdTree ) then print * , point print * , result_exact , xyz (:, result_exact ) print * , result_kdTree , xyz (:, result_kdTree ) error stop end if end do end subroutine end program kdTree_test","tags":"","loc":"sourcefile\\kdtree_test.f90.html"},{"title":"sort_test.f90 – Droplets Simulation","text":"This file depends on sourcefile~~sort_test.f90~~EfferentGraph sourcefile~sort_test.f90 sort_test.f90 sourcefile~sort.f90 sort.f90 sourcefile~sort_test.f90->sourcefile~sort.f90 sourcefile~array.f90 array.f90 sourcefile~sort_test.f90->sourcefile~array.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs sort_test Source Code sort_test.f90 Source Code !>ヒープソートの機能テスト program sort_test use sort_m use array_m implicit none real , parameter :: test1 ( 10 ) = [ - 9.0 , - 1.0 , 0.0 , 3.0 , 5.0 , 7.2 , 1 4.4 , 9 9.9 , 12 2.5 , 25 5.0 ] real , parameter :: test2 ( 11 ) = [ - 9 9.0 , - 9.0 , - 1.0 , 0.0 , 3.0 , 5.0 , 7.2 , 1 4.4 , 9 9.9 , 12 2.5 , 25 5.0 ] real test3 ( 10000 ) call test_sort ( test1 , sort_mode = 'heap_sort' ) call test_sort ( test1 , sort_mode = 'merge_sort' ) print '(\"==============================================================\")' call test_sort ( test2 , sort_mode = 'heap_sort' ) call test_sort ( test2 , sort_mode = 'merge_sort' ) print '(\"==============================================================\")' block integer i real rand !正解配列を乱数で生成 test3 ( 1 ) = 0. do i = 2 , size ( test3 ) call random_number ( rand ) test3 ( i ) = test3 ( i - 1 ) + rand end do end block call test_sort ( test3 , sort_mode = 'heap_sort' ) call test_sort ( test3 , sort_mode = 'merge_sort' ) contains subroutine test_sort ( array_correct , sort_mode ) !!正解配列（ソート済み配列）を引数に取り、それをシャッフルしたのちにソートを行う !!正解配列とソート後の配列を比較し、ソートが機能しているかを検証 real , intent ( in ) :: array_correct (:) character ( * ), intent ( in ) :: sort_mode real tmp ( size ( array_correct )) type ( content_t ) c_array ( size ( array_correct )), c_array_sorted ( size ( array_correct )) real array_sorted ( size ( array_correct )) integer i tmp = FisherYates_shuffle ( array_correct ) ! print *, tmp c_array = real2content ( tmp ) select case ( sort_mode ) case ( 'heap_sort' ) c_array_sorted = heap_sort ( c_array ) case ( 'merge_sort' ) c_array_sorted = merge_sort ( c_array ) case default error stop end select array_sorted = c_array_sorted (:)% value ! ひとつでも違う要素があればテスト失敗 if (. not . all ( array_sorted == array_correct )) then do i = 1 , size ( array_sorted ) print '(2(i6, x, f20.16, 4x, \"|\"))' , & c_array ( i )% originID , c_array ( i )% value , & c_array_sorted ( i )% originID , c_array_sorted ( i )% value end do error stop end if end subroutine end program sort_test","tags":"","loc":"sourcefile\\sort_test.f90.html"},{"title":"Read Me – Droplets Simulation","text":"Droplets Simulation Simulation of Virus-Laden Droplets Behavior in AFDET ドキュメント https://enehentaro.github.io/droplets_simulation/ ※ FORD を使用しています Fordは導入手順は下記の通りです. Linuxの場合 - $ pip install ford - $ ford api-doc-ford-settings.md Windowsの場合 - Anacondaをインストールして下さい.\n  - Anaconda Promptにて\n    - > conda install -c conda-forge ford - > conda install graphviz 使い方 依存関係解決・コンパイル&実行 ビルドに cmake コマンドと make コマンドを使うので, 要インストール. CMakeに関する説明はこちら ルートディレクトリ(README.mdのある階層)での作業.\n  1. 「SampleCase」ディレクトリを複製したのち, 名前を変更する. (ケース名を付ける)\n  1. ケースディレクトリ内の条件ファイル(condition.nml, initial_position.csv)を編集する.\n  1. 以下OSに応じてコンパイル&実行する. Linuxの場合 $ source build.sh でビルド・CTest・パス通しまで出来る. (コンパイル手法を変える場合は各自で編集) $ MAIN で実行. (プログラム名は自分で変える) Windowsの場合 - > .\\build.bat (Windows powershellにて実行)でビルドする. \n    - batファイル内の cmake .. の後に -G \"MinGW Makefiles\" でGeneratorを指定する.\n  - > .\\build\\bin\\main.exe で実行. (プログラム名は自分で変える)\n  ※おそらくVSCodeでコンパイラ指定のポップアップウィンドウが出るので, そこでgfortranのパスを通す. シェルスクリプトを使わない場合 $ mkdir build でビルドディレクトリ作成する. $ cd build で移動する. $ cmake .. で依存関係解決. -D CMAKE_Fortran_COMPILER=[ifort/gfortran] でコンパイラ指定. -D CMAKE_BUILD_TYPE=Debug でデバッグ用コンパイルオプション付与. $ make でコンパイル. 条件ファイル(condition.nml, initial_position.csv)解説 condition.nml リスタート位置 num_restart 通常は 0 を指定する. 1以上 にすると, その値に対応するbackupファイルが読み込まれ, そこからリスタートが始まる. 初期分布ファイル名 initialDistributionFName 指定したbackupファイル(.bu)が読み込まれ, それを飛沫初期分布とする. 初期分布を固定したくない場合はコメントアウトする. 飛沫周期発生 periodicGeneration 1秒当たりの発生飛沫数(整数)を指定する. 初期配置飛沫をすべてNonActiveにしたのち, 順次Activateしていくので, 初期配置数が飛沫数の上限となる. 気流データファイル名 path2FlowFile 実行ディレクトリからの相対パス, もしくは絶対パスを指定する. 現在可能な流れ場ファイル: VTK INP FLD CUBE格子(PLOT3D)は、予め非構造格子に変換してから計算してください. .arrayファイルを指定する場合、別途メッシュファイルが必要なので, meshFile = *** と指定する. ステップ数オフセット OFFSET 飛沫計算を, 流体連番ファイルの途中の番号から始めたいときに指定する. 気流データを周期的に用いる場合の先頭と末尾 LoopHead, LoopTail 任意の区間の流体連番ファイルを繰り返し用いるときに指定する. (例えば呼吸のサイクル) (先頭) = (末尾) とすると, そのステップ数到達後は流れ場の更新が起こらなくなる. (先頭) > (末尾) とすれば, 特殊な処理は起こらず, 流体連番ファイルが順番に読み込まれる. initial_position.csv 初期飛沫の配置帯（直方体）を設定する. 左から順に, 直方体の中心座標(x,y,z), 直方体の幅(x,y,z). 改行すれば配置帯を複数設定できる. 方程式 飛沫の蒸発方程式 プログラム内では,2次精度ルンゲクッタ法で解いている. 飛沫の運動方程式 プログラム内では,上式を無次元化・離散化した次式を解いている. サブプログラム CUBE2USG CUBE格子を非構造格子に変換できる. droplet2CSV 飛沫計算結果を再度読み込み, 統計データ(浮遊数推移など)をCSVファイルに書き出す. dropletCount 飛沫計算結果を再度読み込み, カウントボックスを通過した飛沫数を調べる. optionディレクトリ内の\"boxList.csv\"を, ケースディレクトリに配置する必要がある. initialTranslate 飛沫の初期配置データを読み込み, 任意の座標への回転, 平行移動を行う. by Konishi おまけ機能 複数ケース連続実行 実行時にTXTファイル名を入力すると, そのファイルに列挙された複数ケースを連続実行できる. basicSetting.nml optionディレクトリ内にある, 付着判定のオンオフや, 飛沫間合体の設定が可能.初期半径分布ファイルの指定も可能. CTest コンパイル後, $ ctest でCTestが実行可. (buildディレクトリにて) CTestの実行ディレクトリは、 test/ になる. (buildディレクトリではない) テスト用プログラムはすべて test/ で管理しよう.","tags":"","loc":"page\\index.html"}]}